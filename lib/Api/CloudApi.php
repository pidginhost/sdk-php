<?php
/**
 * CloudApi
 * PHP version 7.4
 *
 * @category Class
 * @package  PidginHost\\Sdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Pidgin Host API
 *
 * The Pidgin Host API allows you to manage Services and resources within the Pidgin Host cloud in a simple, programmatic way using conventional HTTP requests. All of the functionality that you are familiar with in the Pidgin Host control panel is also available through the API, allowing you to script the complex actions that your situation requires.
 *
 * The version of the OpenAPI document: 1.0.0 (v1)
 * Contact: support@pidginhost.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace PidginHost\\Sdk\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use PidginHost\\Sdk\ApiException;
use PidginHost\\Sdk\Configuration;
use PidginHost\\Sdk\HeaderSelector;
use PidginHost\\Sdk\ObjectSerializer;

/**
 * CloudApi Class Doc Comment
 *
 * @category Class
 * @package  PidginHost\\Sdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class CloudApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'cloudFirewallRulesSetCreate' => [
            'application/json',
        ],
        'cloudFirewallRulesSetCreate2' => [
            'application/json',
        ],
        'cloudFirewallRulesSetDestroy' => [
            'application/json',
        ],
        'cloudFirewallRulesSetDestroy2' => [
            'application/json',
        ],
        'cloudFirewallRulesSetList' => [
            'application/json',
        ],
        'cloudFirewallRulesSetList2' => [
            'application/json',
        ],
        'cloudFirewallRulesSetPartialUpdate' => [
            'application/json',
        ],
        'cloudFirewallRulesSetPartialUpdate2' => [
            'application/json',
        ],
        'cloudFirewallRulesSetRetrieve' => [
            'application/json',
        ],
        'cloudFirewallRulesSetRetrieve2' => [
            'application/json',
        ],
        'cloudFirewallRulesSetRulesCreate' => [
            'application/json',
        ],
        'cloudFirewallRulesSetRulesCreate2' => [
            'application/json',
        ],
        'cloudFirewallRulesSetRulesDestroy' => [
            'application/json',
        ],
        'cloudFirewallRulesSetRulesDestroy2' => [
            'application/json',
        ],
        'cloudFirewallRulesSetRulesList' => [
            'application/json',
        ],
        'cloudFirewallRulesSetRulesList2' => [
            'application/json',
        ],
        'cloudFirewallRulesSetRulesPartialUpdate' => [
            'application/json',
        ],
        'cloudFirewallRulesSetRulesPartialUpdate2' => [
            'application/json',
        ],
        'cloudFirewallRulesSetRulesRetrieve' => [
            'application/json',
        ],
        'cloudFirewallRulesSetRulesRetrieve2' => [
            'application/json',
        ],
        'cloudFirewallRulesSetRulesUpdate' => [
            'application/json',
        ],
        'cloudFirewallRulesSetRulesUpdate2' => [
            'application/json',
        ],
        'cloudFirewallRulesSetUpdate' => [
            'application/json',
        ],
        'cloudFirewallRulesSetUpdate2' => [
            'application/json',
        ],
        'cloudImagesList' => [
            'application/json',
        ],
        'cloudImagesList2' => [
            'application/json',
        ],
        'cloudImagesRetrieve' => [
            'application/json',
        ],
        'cloudImagesRetrieve2' => [
            'application/json',
        ],
        'cloudIpv4Create' => [
            'application/json',
        ],
        'cloudIpv4Create2' => [
            'application/json',
        ],
        'cloudIpv4Destroy' => [
            'application/json',
        ],
        'cloudIpv4Destroy2' => [
            'application/json',
        ],
        'cloudIpv4DetachCreate' => [
            'application/json',
        ],
        'cloudIpv4DetachCreate2' => [
            'application/json',
        ],
        'cloudIpv4List' => [
            'application/json',
        ],
        'cloudIpv4List2' => [
            'application/json',
        ],
        'cloudIpv4Retrieve' => [
            'application/json',
        ],
        'cloudIpv4Retrieve2' => [
            'application/json',
        ],
        'cloudIpv6Create' => [
            'application/json',
        ],
        'cloudIpv6Create2' => [
            'application/json',
        ],
        'cloudIpv6Destroy' => [
            'application/json',
        ],
        'cloudIpv6Destroy2' => [
            'application/json',
        ],
        'cloudIpv6DetachCreate' => [
            'application/json',
        ],
        'cloudIpv6DetachCreate2' => [
            'application/json',
        ],
        'cloudIpv6List' => [
            'application/json',
        ],
        'cloudIpv6List2' => [
            'application/json',
        ],
        'cloudIpv6Retrieve' => [
            'application/json',
        ],
        'cloudIpv6Retrieve2' => [
            'application/json',
        ],
        'cloudPrivateNetworksAddServerCreate' => [
            'application/json',
        ],
        'cloudPrivateNetworksAddServerCreate2' => [
            'application/json',
        ],
        'cloudPrivateNetworksCreate' => [
            'application/json',
        ],
        'cloudPrivateNetworksCreate2' => [
            'application/json',
        ],
        'cloudPrivateNetworksDestroy' => [
            'application/json',
        ],
        'cloudPrivateNetworksDestroy2' => [
            'application/json',
        ],
        'cloudPrivateNetworksList' => [
            'application/json',
        ],
        'cloudPrivateNetworksList2' => [
            'application/json',
        ],
        'cloudPrivateNetworksPartialUpdate' => [
            'application/json',
        ],
        'cloudPrivateNetworksPartialUpdate2' => [
            'application/json',
        ],
        'cloudPrivateNetworksRemoveServerCreate' => [
            'application/json',
        ],
        'cloudPrivateNetworksRemoveServerCreate2' => [
            'application/json',
        ],
        'cloudPrivateNetworksRetrieve' => [
            'application/json',
        ],
        'cloudPrivateNetworksRetrieve2' => [
            'application/json',
        ],
        'cloudPrivateNetworksUpdate' => [
            'application/json',
        ],
        'cloudPrivateNetworksUpdate2' => [
            'application/json',
        ],
        'cloudServerPackagesList' => [
            'application/json',
        ],
        'cloudServerPackagesList2' => [
            'application/json',
        ],
        'cloudServerPackagesRetrieve' => [
            'application/json',
        ],
        'cloudServerPackagesRetrieve2' => [
            'application/json',
        ],
        'cloudServersAttachIpv4Create' => [
            'application/json',
        ],
        'cloudServersAttachIpv4Create2' => [
            'application/json',
        ],
        'cloudServersAttachIpv6Create' => [
            'application/json',
        ],
        'cloudServersAttachIpv6Create2' => [
            'application/json',
        ],
        'cloudServersConsoleCreate' => [
            'application/json',
        ],
        'cloudServersConsoleCreate2' => [
            'application/json',
        ],
        'cloudServersCreate' => [
            'application/json',
        ],
        'cloudServersCreate2' => [
            'application/json',
        ],
        'cloudServersDestroy' => [
            'application/json',
        ],
        'cloudServersDestroy2' => [
            'application/json',
        ],
        'cloudServersDestroyProtectionCreate' => [
            'application/json',
        ],
        'cloudServersDestroyProtectionCreate2' => [
            'application/json',
        ],
        'cloudServersDetachIpv4Create' => [
            'application/json',
        ],
        'cloudServersDetachIpv4Create2' => [
            'application/json',
        ],
        'cloudServersDetachIpv6Create' => [
            'application/json',
        ],
        'cloudServersDetachIpv6Create2' => [
            'application/json',
        ],
        'cloudServersList' => [
            'application/json',
        ],
        'cloudServersList2' => [
            'application/json',
        ],
        'cloudServersModifyPackageCreate' => [
            'application/json',
        ],
        'cloudServersModifyPackageCreate2' => [
            'application/json',
        ],
        'cloudServersPartialUpdate' => [
            'application/json',
        ],
        'cloudServersPartialUpdate2' => [
            'application/json',
        ],
        'cloudServersPowerManagementCreate' => [
            'application/json',
        ],
        'cloudServersPowerManagementCreate2' => [
            'application/json',
        ],
        'cloudServersPowerManagementRetrieve' => [
            'application/json',
        ],
        'cloudServersPowerManagementRetrieve2' => [
            'application/json',
        ],
        'cloudServersPublicInterfaceCreate' => [
            'application/json',
        ],
        'cloudServersPublicInterfaceCreate2' => [
            'application/json',
        ],
        'cloudServersPublicInterfaceDestroy' => [
            'application/json',
        ],
        'cloudServersPublicInterfaceDestroy2' => [
            'application/json',
        ],
        'cloudServersPublicInterfaceRetrieve' => [
            'application/json',
        ],
        'cloudServersPublicInterfaceRetrieve2' => [
            'application/json',
        ],
        'cloudServersRetrieve' => [
            'application/json',
        ],
        'cloudServersRetrieve2' => [
            'application/json',
        ],
        'cloudServersRetryProvisionCreate' => [
            'application/json',
        ],
        'cloudServersRetryProvisionCreate2' => [
            'application/json',
        ],
        'cloudServersSnapshotsCreate' => [
            'application/json',
        ],
        'cloudServersSnapshotsCreate2' => [
            'application/json',
        ],
        'cloudServersSnapshotsDestroy' => [
            'application/json',
        ],
        'cloudServersSnapshotsDestroy2' => [
            'application/json',
        ],
        'cloudServersSnapshotsList' => [
            'application/json',
        ],
        'cloudServersSnapshotsList2' => [
            'application/json',
        ],
        'cloudServersSnapshotsRollbackCreate' => [
            'application/json',
        ],
        'cloudServersSnapshotsRollbackCreate2' => [
            'application/json',
        ],
        'cloudServersUpdate' => [
            'application/json',
        ],
        'cloudServersUpdate2' => [
            'application/json',
        ],
        'cloudServersVolumesCreate' => [
            'application/json',
        ],
        'cloudServersVolumesCreate2' => [
            'application/json',
        ],
        'cloudServersVolumesDestroy' => [
            'application/json',
        ],
        'cloudServersVolumesDestroy2' => [
            'application/json',
        ],
        'cloudServersVolumesList' => [
            'application/json',
        ],
        'cloudServersVolumesList2' => [
            'application/json',
        ],
        'cloudServersVolumesPartialUpdate' => [
            'application/json',
        ],
        'cloudServersVolumesPartialUpdate2' => [
            'application/json',
        ],
        'cloudServersVolumesRetrieve' => [
            'application/json',
        ],
        'cloudServersVolumesRetrieve2' => [
            'application/json',
        ],
        'cloudServersVolumesUpdate' => [
            'application/json',
        ],
        'cloudServersVolumesUpdate2' => [
            'application/json',
        ],
        'cloudStorageProductsList' => [
            'application/json',
        ],
        'cloudStorageProductsList2' => [
            'application/json',
        ],
        'cloudStorageProductsRetrieve' => [
            'application/json',
        ],
        'cloudStorageProductsRetrieve2' => [
            'application/json',
        ],
        'cloudVolumesAttachCreate' => [
            'application/json',
        ],
        'cloudVolumesAttachCreate2' => [
            'application/json',
        ],
        'cloudVolumesDestroy' => [
            'application/json',
        ],
        'cloudVolumesDestroy2' => [
            'application/json',
        ],
        'cloudVolumesDetachCreate' => [
            'application/json',
        ],
        'cloudVolumesDetachCreate2' => [
            'application/json',
        ],
        'cloudVolumesList' => [
            'application/json',
        ],
        'cloudVolumesList2' => [
            'application/json',
        ],
        'cloudVolumesPartialUpdate' => [
            'application/json',
        ],
        'cloudVolumesPartialUpdate2' => [
            'application/json',
        ],
        'cloudVolumesRetrieve' => [
            'application/json',
        ],
        'cloudVolumesRetrieve2' => [
            'application/json',
        ],
        'cloudVolumesUpdate' => [
            'application/json',
        ],
        'cloudVolumesUpdate2' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation cloudFirewallRulesSetCreate
     *
     * @param  \PidginHost\\Sdk\Model\FirewallRulesSet $firewall_rules_set firewall_rules_set (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\FirewallRulesSet
     */
    public function cloudFirewallRulesSetCreate($firewall_rules_set, string $contentType = self::contentTypes['cloudFirewallRulesSetCreate'][0])
    {
        list($response) = $this->cloudFirewallRulesSetCreateWithHttpInfo($firewall_rules_set, $contentType);
        return $response;
    }

    /**
     * Operation cloudFirewallRulesSetCreateWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\FirewallRulesSet $firewall_rules_set (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\FirewallRulesSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudFirewallRulesSetCreateWithHttpInfo($firewall_rules_set, string $contentType = self::contentTypes['cloudFirewallRulesSetCreate'][0])
    {
        $request = $this->cloudFirewallRulesSetCreateRequest($firewall_rules_set, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\FirewallRulesSet' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\FirewallRulesSet' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\FirewallRulesSet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\FirewallRulesSet';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\FirewallRulesSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudFirewallRulesSetCreateAsync
     *
     * @param  \PidginHost\\Sdk\Model\FirewallRulesSet $firewall_rules_set (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetCreateAsync($firewall_rules_set, string $contentType = self::contentTypes['cloudFirewallRulesSetCreate'][0])
    {
        return $this->cloudFirewallRulesSetCreateAsyncWithHttpInfo($firewall_rules_set, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudFirewallRulesSetCreateAsyncWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\FirewallRulesSet $firewall_rules_set (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetCreateAsyncWithHttpInfo($firewall_rules_set, string $contentType = self::contentTypes['cloudFirewallRulesSetCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\FirewallRulesSet';
        $request = $this->cloudFirewallRulesSetCreateRequest($firewall_rules_set, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudFirewallRulesSetCreate'
     *
     * @param  \PidginHost\\Sdk\Model\FirewallRulesSet $firewall_rules_set (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudFirewallRulesSetCreateRequest($firewall_rules_set, string $contentType = self::contentTypes['cloudFirewallRulesSetCreate'][0])
    {

        // verify the required parameter 'firewall_rules_set' is set
        if ($firewall_rules_set === null || (is_array($firewall_rules_set) && count($firewall_rules_set) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $firewall_rules_set when calling cloudFirewallRulesSetCreate'
            );
        }


        $resourcePath = '/api/cloud/firewall-rules-set/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($firewall_rules_set)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($firewall_rules_set));
            } else {
                $httpBody = $firewall_rules_set;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudFirewallRulesSetCreate2
     *
     * @param  \PidginHost\\Sdk\Model\FirewallRulesSet $firewall_rules_set firewall_rules_set (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\FirewallRulesSet
     */
    public function cloudFirewallRulesSetCreate2($firewall_rules_set, string $contentType = self::contentTypes['cloudFirewallRulesSetCreate2'][0])
    {
        list($response) = $this->cloudFirewallRulesSetCreate2WithHttpInfo($firewall_rules_set, $contentType);
        return $response;
    }

    /**
     * Operation cloudFirewallRulesSetCreate2WithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\FirewallRulesSet $firewall_rules_set (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\FirewallRulesSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudFirewallRulesSetCreate2WithHttpInfo($firewall_rules_set, string $contentType = self::contentTypes['cloudFirewallRulesSetCreate2'][0])
    {
        $request = $this->cloudFirewallRulesSetCreate2Request($firewall_rules_set, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\FirewallRulesSet' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\FirewallRulesSet' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\FirewallRulesSet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\FirewallRulesSet';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\FirewallRulesSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudFirewallRulesSetCreate2Async
     *
     * @param  \PidginHost\\Sdk\Model\FirewallRulesSet $firewall_rules_set (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetCreate2Async($firewall_rules_set, string $contentType = self::contentTypes['cloudFirewallRulesSetCreate2'][0])
    {
        return $this->cloudFirewallRulesSetCreate2AsyncWithHttpInfo($firewall_rules_set, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudFirewallRulesSetCreate2AsyncWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\FirewallRulesSet $firewall_rules_set (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetCreate2AsyncWithHttpInfo($firewall_rules_set, string $contentType = self::contentTypes['cloudFirewallRulesSetCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\FirewallRulesSet';
        $request = $this->cloudFirewallRulesSetCreate2Request($firewall_rules_set, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudFirewallRulesSetCreate2'
     *
     * @param  \PidginHost\\Sdk\Model\FirewallRulesSet $firewall_rules_set (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudFirewallRulesSetCreate2Request($firewall_rules_set, string $contentType = self::contentTypes['cloudFirewallRulesSetCreate2'][0])
    {

        // verify the required parameter 'firewall_rules_set' is set
        if ($firewall_rules_set === null || (is_array($firewall_rules_set) && count($firewall_rules_set) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $firewall_rules_set when calling cloudFirewallRulesSetCreate2'
            );
        }


        $resourcePath = '/api/v1/cloud/firewall-rules-set/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($firewall_rules_set)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($firewall_rules_set));
            } else {
                $httpBody = $firewall_rules_set;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudFirewallRulesSetDestroy
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cloudFirewallRulesSetDestroy($id, string $contentType = self::contentTypes['cloudFirewallRulesSetDestroy'][0])
    {
        $this->cloudFirewallRulesSetDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation cloudFirewallRulesSetDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudFirewallRulesSetDestroyWithHttpInfo($id, string $contentType = self::contentTypes['cloudFirewallRulesSetDestroy'][0])
    {
        $request = $this->cloudFirewallRulesSetDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cloudFirewallRulesSetDestroyAsync
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetDestroyAsync($id, string $contentType = self::contentTypes['cloudFirewallRulesSetDestroy'][0])
    {
        return $this->cloudFirewallRulesSetDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudFirewallRulesSetDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudFirewallRulesSetDestroy'][0])
    {
        $returnType = '';
        $request = $this->cloudFirewallRulesSetDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudFirewallRulesSetDestroy'
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudFirewallRulesSetDestroyRequest($id, string $contentType = self::contentTypes['cloudFirewallRulesSetDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudFirewallRulesSetDestroy'
            );
        }


        $resourcePath = '/api/cloud/firewall-rules-set/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudFirewallRulesSetDestroy2
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cloudFirewallRulesSetDestroy2($id, string $contentType = self::contentTypes['cloudFirewallRulesSetDestroy2'][0])
    {
        $this->cloudFirewallRulesSetDestroy2WithHttpInfo($id, $contentType);
    }

    /**
     * Operation cloudFirewallRulesSetDestroy2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudFirewallRulesSetDestroy2WithHttpInfo($id, string $contentType = self::contentTypes['cloudFirewallRulesSetDestroy2'][0])
    {
        $request = $this->cloudFirewallRulesSetDestroy2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cloudFirewallRulesSetDestroy2Async
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetDestroy2Async($id, string $contentType = self::contentTypes['cloudFirewallRulesSetDestroy2'][0])
    {
        return $this->cloudFirewallRulesSetDestroy2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudFirewallRulesSetDestroy2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetDestroy2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudFirewallRulesSetDestroy2'][0])
    {
        $returnType = '';
        $request = $this->cloudFirewallRulesSetDestroy2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudFirewallRulesSetDestroy2'
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudFirewallRulesSetDestroy2Request($id, string $contentType = self::contentTypes['cloudFirewallRulesSetDestroy2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudFirewallRulesSetDestroy2'
            );
        }


        $resourcePath = '/api/v1/cloud/firewall-rules-set/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudFirewallRulesSetList
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\FirewallRulesSet[]
     */
    public function cloudFirewallRulesSetList(string $contentType = self::contentTypes['cloudFirewallRulesSetList'][0])
    {
        list($response) = $this->cloudFirewallRulesSetListWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation cloudFirewallRulesSetListWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\FirewallRulesSet[], HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudFirewallRulesSetListWithHttpInfo(string $contentType = self::contentTypes['cloudFirewallRulesSetList'][0])
    {
        $request = $this->cloudFirewallRulesSetListRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\FirewallRulesSet[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\FirewallRulesSet[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\FirewallRulesSet[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\FirewallRulesSet[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\FirewallRulesSet[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudFirewallRulesSetListAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetListAsync(string $contentType = self::contentTypes['cloudFirewallRulesSetList'][0])
    {
        return $this->cloudFirewallRulesSetListAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudFirewallRulesSetListAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetListAsyncWithHttpInfo(string $contentType = self::contentTypes['cloudFirewallRulesSetList'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\FirewallRulesSet[]';
        $request = $this->cloudFirewallRulesSetListRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudFirewallRulesSetList'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudFirewallRulesSetListRequest(string $contentType = self::contentTypes['cloudFirewallRulesSetList'][0])
    {


        $resourcePath = '/api/cloud/firewall-rules-set/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudFirewallRulesSetList2
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\FirewallRulesSet[]
     */
    public function cloudFirewallRulesSetList2(string $contentType = self::contentTypes['cloudFirewallRulesSetList2'][0])
    {
        list($response) = $this->cloudFirewallRulesSetList2WithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation cloudFirewallRulesSetList2WithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\FirewallRulesSet[], HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudFirewallRulesSetList2WithHttpInfo(string $contentType = self::contentTypes['cloudFirewallRulesSetList2'][0])
    {
        $request = $this->cloudFirewallRulesSetList2Request($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\FirewallRulesSet[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\FirewallRulesSet[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\FirewallRulesSet[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\FirewallRulesSet[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\FirewallRulesSet[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudFirewallRulesSetList2Async
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetList2Async(string $contentType = self::contentTypes['cloudFirewallRulesSetList2'][0])
    {
        return $this->cloudFirewallRulesSetList2AsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudFirewallRulesSetList2AsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetList2AsyncWithHttpInfo(string $contentType = self::contentTypes['cloudFirewallRulesSetList2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\FirewallRulesSet[]';
        $request = $this->cloudFirewallRulesSetList2Request($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudFirewallRulesSetList2'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudFirewallRulesSetList2Request(string $contentType = self::contentTypes['cloudFirewallRulesSetList2'][0])
    {


        $resourcePath = '/api/v1/cloud/firewall-rules-set/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudFirewallRulesSetPartialUpdate
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedFirewallRulesSet|null $patched_firewall_rules_set patched_firewall_rules_set (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\FirewallRulesSet
     */
    public function cloudFirewallRulesSetPartialUpdate($id, $patched_firewall_rules_set = null, string $contentType = self::contentTypes['cloudFirewallRulesSetPartialUpdate'][0])
    {
        list($response) = $this->cloudFirewallRulesSetPartialUpdateWithHttpInfo($id, $patched_firewall_rules_set, $contentType);
        return $response;
    }

    /**
     * Operation cloudFirewallRulesSetPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedFirewallRulesSet|null $patched_firewall_rules_set (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\FirewallRulesSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudFirewallRulesSetPartialUpdateWithHttpInfo($id, $patched_firewall_rules_set = null, string $contentType = self::contentTypes['cloudFirewallRulesSetPartialUpdate'][0])
    {
        $request = $this->cloudFirewallRulesSetPartialUpdateRequest($id, $patched_firewall_rules_set, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\FirewallRulesSet' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\FirewallRulesSet' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\FirewallRulesSet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\FirewallRulesSet';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\FirewallRulesSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudFirewallRulesSetPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedFirewallRulesSet|null $patched_firewall_rules_set (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetPartialUpdateAsync($id, $patched_firewall_rules_set = null, string $contentType = self::contentTypes['cloudFirewallRulesSetPartialUpdate'][0])
    {
        return $this->cloudFirewallRulesSetPartialUpdateAsyncWithHttpInfo($id, $patched_firewall_rules_set, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudFirewallRulesSetPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedFirewallRulesSet|null $patched_firewall_rules_set (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetPartialUpdateAsyncWithHttpInfo($id, $patched_firewall_rules_set = null, string $contentType = self::contentTypes['cloudFirewallRulesSetPartialUpdate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\FirewallRulesSet';
        $request = $this->cloudFirewallRulesSetPartialUpdateRequest($id, $patched_firewall_rules_set, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudFirewallRulesSetPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedFirewallRulesSet|null $patched_firewall_rules_set (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudFirewallRulesSetPartialUpdateRequest($id, $patched_firewall_rules_set = null, string $contentType = self::contentTypes['cloudFirewallRulesSetPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudFirewallRulesSetPartialUpdate'
            );
        }



        $resourcePath = '/api/cloud/firewall-rules-set/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_firewall_rules_set)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_firewall_rules_set));
            } else {
                $httpBody = $patched_firewall_rules_set;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudFirewallRulesSetPartialUpdate2
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedFirewallRulesSet|null $patched_firewall_rules_set patched_firewall_rules_set (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\FirewallRulesSet
     */
    public function cloudFirewallRulesSetPartialUpdate2($id, $patched_firewall_rules_set = null, string $contentType = self::contentTypes['cloudFirewallRulesSetPartialUpdate2'][0])
    {
        list($response) = $this->cloudFirewallRulesSetPartialUpdate2WithHttpInfo($id, $patched_firewall_rules_set, $contentType);
        return $response;
    }

    /**
     * Operation cloudFirewallRulesSetPartialUpdate2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedFirewallRulesSet|null $patched_firewall_rules_set (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\FirewallRulesSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudFirewallRulesSetPartialUpdate2WithHttpInfo($id, $patched_firewall_rules_set = null, string $contentType = self::contentTypes['cloudFirewallRulesSetPartialUpdate2'][0])
    {
        $request = $this->cloudFirewallRulesSetPartialUpdate2Request($id, $patched_firewall_rules_set, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\FirewallRulesSet' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\FirewallRulesSet' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\FirewallRulesSet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\FirewallRulesSet';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\FirewallRulesSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudFirewallRulesSetPartialUpdate2Async
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedFirewallRulesSet|null $patched_firewall_rules_set (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetPartialUpdate2Async($id, $patched_firewall_rules_set = null, string $contentType = self::contentTypes['cloudFirewallRulesSetPartialUpdate2'][0])
    {
        return $this->cloudFirewallRulesSetPartialUpdate2AsyncWithHttpInfo($id, $patched_firewall_rules_set, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudFirewallRulesSetPartialUpdate2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedFirewallRulesSet|null $patched_firewall_rules_set (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetPartialUpdate2AsyncWithHttpInfo($id, $patched_firewall_rules_set = null, string $contentType = self::contentTypes['cloudFirewallRulesSetPartialUpdate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\FirewallRulesSet';
        $request = $this->cloudFirewallRulesSetPartialUpdate2Request($id, $patched_firewall_rules_set, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudFirewallRulesSetPartialUpdate2'
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedFirewallRulesSet|null $patched_firewall_rules_set (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudFirewallRulesSetPartialUpdate2Request($id, $patched_firewall_rules_set = null, string $contentType = self::contentTypes['cloudFirewallRulesSetPartialUpdate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudFirewallRulesSetPartialUpdate2'
            );
        }



        $resourcePath = '/api/v1/cloud/firewall-rules-set/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_firewall_rules_set)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_firewall_rules_set));
            } else {
                $httpBody = $patched_firewall_rules_set;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudFirewallRulesSetRetrieve
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\FirewallRulesSet
     */
    public function cloudFirewallRulesSetRetrieve($id, string $contentType = self::contentTypes['cloudFirewallRulesSetRetrieve'][0])
    {
        list($response) = $this->cloudFirewallRulesSetRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation cloudFirewallRulesSetRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\FirewallRulesSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudFirewallRulesSetRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['cloudFirewallRulesSetRetrieve'][0])
    {
        $request = $this->cloudFirewallRulesSetRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\FirewallRulesSet' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\FirewallRulesSet' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\FirewallRulesSet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\FirewallRulesSet';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\FirewallRulesSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudFirewallRulesSetRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRetrieveAsync($id, string $contentType = self::contentTypes['cloudFirewallRulesSetRetrieve'][0])
    {
        return $this->cloudFirewallRulesSetRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudFirewallRulesSetRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudFirewallRulesSetRetrieve'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\FirewallRulesSet';
        $request = $this->cloudFirewallRulesSetRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudFirewallRulesSetRetrieve'
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudFirewallRulesSetRetrieveRequest($id, string $contentType = self::contentTypes['cloudFirewallRulesSetRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudFirewallRulesSetRetrieve'
            );
        }


        $resourcePath = '/api/cloud/firewall-rules-set/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudFirewallRulesSetRetrieve2
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\FirewallRulesSet
     */
    public function cloudFirewallRulesSetRetrieve2($id, string $contentType = self::contentTypes['cloudFirewallRulesSetRetrieve2'][0])
    {
        list($response) = $this->cloudFirewallRulesSetRetrieve2WithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation cloudFirewallRulesSetRetrieve2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\FirewallRulesSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudFirewallRulesSetRetrieve2WithHttpInfo($id, string $contentType = self::contentTypes['cloudFirewallRulesSetRetrieve2'][0])
    {
        $request = $this->cloudFirewallRulesSetRetrieve2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\FirewallRulesSet' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\FirewallRulesSet' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\FirewallRulesSet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\FirewallRulesSet';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\FirewallRulesSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudFirewallRulesSetRetrieve2Async
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRetrieve2Async($id, string $contentType = self::contentTypes['cloudFirewallRulesSetRetrieve2'][0])
    {
        return $this->cloudFirewallRulesSetRetrieve2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudFirewallRulesSetRetrieve2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRetrieve2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudFirewallRulesSetRetrieve2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\FirewallRulesSet';
        $request = $this->cloudFirewallRulesSetRetrieve2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudFirewallRulesSetRetrieve2'
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudFirewallRulesSetRetrieve2Request($id, string $contentType = self::contentTypes['cloudFirewallRulesSetRetrieve2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudFirewallRulesSetRetrieve2'
            );
        }


        $resourcePath = '/api/v1/cloud/firewall-rules-set/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudFirewallRulesSetRulesCreate
     *
     * @param  string $rules_set_id rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRule $firewall_rule firewall_rule (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\FirewallRule
     */
    public function cloudFirewallRulesSetRulesCreate($rules_set_id, $firewall_rule, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesCreate'][0])
    {
        list($response) = $this->cloudFirewallRulesSetRulesCreateWithHttpInfo($rules_set_id, $firewall_rule, $contentType);
        return $response;
    }

    /**
     * Operation cloudFirewallRulesSetRulesCreateWithHttpInfo
     *
     * @param  string $rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRule $firewall_rule (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\FirewallRule, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudFirewallRulesSetRulesCreateWithHttpInfo($rules_set_id, $firewall_rule, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesCreate'][0])
    {
        $request = $this->cloudFirewallRulesSetRulesCreateRequest($rules_set_id, $firewall_rule, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\FirewallRule' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\FirewallRule' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\FirewallRule', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\FirewallRule';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\FirewallRule',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudFirewallRulesSetRulesCreateAsync
     *
     * @param  string $rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRule $firewall_rule (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRulesCreateAsync($rules_set_id, $firewall_rule, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesCreate'][0])
    {
        return $this->cloudFirewallRulesSetRulesCreateAsyncWithHttpInfo($rules_set_id, $firewall_rule, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudFirewallRulesSetRulesCreateAsyncWithHttpInfo
     *
     * @param  string $rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRule $firewall_rule (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRulesCreateAsyncWithHttpInfo($rules_set_id, $firewall_rule, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\FirewallRule';
        $request = $this->cloudFirewallRulesSetRulesCreateRequest($rules_set_id, $firewall_rule, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudFirewallRulesSetRulesCreate'
     *
     * @param  string $rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRule $firewall_rule (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudFirewallRulesSetRulesCreateRequest($rules_set_id, $firewall_rule, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesCreate'][0])
    {

        // verify the required parameter 'rules_set_id' is set
        if ($rules_set_id === null || (is_array($rules_set_id) && count($rules_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rules_set_id when calling cloudFirewallRulesSetRulesCreate'
            );
        }
        if (!preg_match("/^\\d{1,10}$/", $rules_set_id)) {
            throw new \InvalidArgumentException("invalid value for \"rules_set_id\" when calling CloudApi.cloudFirewallRulesSetRulesCreate, must conform to the pattern /^\\d{1,10}$/.");
        }
        
        // verify the required parameter 'firewall_rule' is set
        if ($firewall_rule === null || (is_array($firewall_rule) && count($firewall_rule) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $firewall_rule when calling cloudFirewallRulesSetRulesCreate'
            );
        }


        $resourcePath = '/api/cloud/firewall-rules-set/{rules_set_id}/rules/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($rules_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rules_set_id' . '}',
                ObjectSerializer::toPathValue($rules_set_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($firewall_rule)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($firewall_rule));
            } else {
                $httpBody = $firewall_rule;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudFirewallRulesSetRulesCreate2
     *
     * @param  string $rules_set_id rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRule $firewall_rule firewall_rule (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\FirewallRule
     */
    public function cloudFirewallRulesSetRulesCreate2($rules_set_id, $firewall_rule, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesCreate2'][0])
    {
        list($response) = $this->cloudFirewallRulesSetRulesCreate2WithHttpInfo($rules_set_id, $firewall_rule, $contentType);
        return $response;
    }

    /**
     * Operation cloudFirewallRulesSetRulesCreate2WithHttpInfo
     *
     * @param  string $rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRule $firewall_rule (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\FirewallRule, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudFirewallRulesSetRulesCreate2WithHttpInfo($rules_set_id, $firewall_rule, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesCreate2'][0])
    {
        $request = $this->cloudFirewallRulesSetRulesCreate2Request($rules_set_id, $firewall_rule, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\FirewallRule' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\FirewallRule' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\FirewallRule', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\FirewallRule';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\FirewallRule',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudFirewallRulesSetRulesCreate2Async
     *
     * @param  string $rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRule $firewall_rule (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRulesCreate2Async($rules_set_id, $firewall_rule, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesCreate2'][0])
    {
        return $this->cloudFirewallRulesSetRulesCreate2AsyncWithHttpInfo($rules_set_id, $firewall_rule, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudFirewallRulesSetRulesCreate2AsyncWithHttpInfo
     *
     * @param  string $rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRule $firewall_rule (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRulesCreate2AsyncWithHttpInfo($rules_set_id, $firewall_rule, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\FirewallRule';
        $request = $this->cloudFirewallRulesSetRulesCreate2Request($rules_set_id, $firewall_rule, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudFirewallRulesSetRulesCreate2'
     *
     * @param  string $rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRule $firewall_rule (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudFirewallRulesSetRulesCreate2Request($rules_set_id, $firewall_rule, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesCreate2'][0])
    {

        // verify the required parameter 'rules_set_id' is set
        if ($rules_set_id === null || (is_array($rules_set_id) && count($rules_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rules_set_id when calling cloudFirewallRulesSetRulesCreate2'
            );
        }
        if (!preg_match("/^\\d{1,10}$/", $rules_set_id)) {
            throw new \InvalidArgumentException("invalid value for \"rules_set_id\" when calling CloudApi.cloudFirewallRulesSetRulesCreate2, must conform to the pattern /^\\d{1,10}$/.");
        }
        
        // verify the required parameter 'firewall_rule' is set
        if ($firewall_rule === null || (is_array($firewall_rule) && count($firewall_rule) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $firewall_rule when calling cloudFirewallRulesSetRulesCreate2'
            );
        }


        $resourcePath = '/api/v1/cloud/firewall-rules-set/{rules_set_id}/rules/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($rules_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rules_set_id' . '}',
                ObjectSerializer::toPathValue($rules_set_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($firewall_rule)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($firewall_rule));
            } else {
                $httpBody = $firewall_rule;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudFirewallRulesSetRulesDestroy
     *
     * @param  string $rule_id rule_id (required)
     * @param  string $rules_set_id rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cloudFirewallRulesSetRulesDestroy($rule_id, $rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesDestroy'][0])
    {
        $this->cloudFirewallRulesSetRulesDestroyWithHttpInfo($rule_id, $rules_set_id, $contentType);
    }

    /**
     * Operation cloudFirewallRulesSetRulesDestroyWithHttpInfo
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudFirewallRulesSetRulesDestroyWithHttpInfo($rule_id, $rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesDestroy'][0])
    {
        $request = $this->cloudFirewallRulesSetRulesDestroyRequest($rule_id, $rules_set_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cloudFirewallRulesSetRulesDestroyAsync
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRulesDestroyAsync($rule_id, $rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesDestroy'][0])
    {
        return $this->cloudFirewallRulesSetRulesDestroyAsyncWithHttpInfo($rule_id, $rules_set_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudFirewallRulesSetRulesDestroyAsyncWithHttpInfo
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRulesDestroyAsyncWithHttpInfo($rule_id, $rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesDestroy'][0])
    {
        $returnType = '';
        $request = $this->cloudFirewallRulesSetRulesDestroyRequest($rule_id, $rules_set_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudFirewallRulesSetRulesDestroy'
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudFirewallRulesSetRulesDestroyRequest($rule_id, $rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesDestroy'][0])
    {

        // verify the required parameter 'rule_id' is set
        if ($rule_id === null || (is_array($rule_id) && count($rule_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rule_id when calling cloudFirewallRulesSetRulesDestroy'
            );
        }

        // verify the required parameter 'rules_set_id' is set
        if ($rules_set_id === null || (is_array($rules_set_id) && count($rules_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rules_set_id when calling cloudFirewallRulesSetRulesDestroy'
            );
        }
        if (!preg_match("/^\\d{1,10}$/", $rules_set_id)) {
            throw new \InvalidArgumentException("invalid value for \"rules_set_id\" when calling CloudApi.cloudFirewallRulesSetRulesDestroy, must conform to the pattern /^\\d{1,10}$/.");
        }
        

        $resourcePath = '/api/cloud/firewall-rules-set/{rules_set_id}/rules/{rule_id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($rule_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rule_id' . '}',
                ObjectSerializer::toPathValue($rule_id),
                $resourcePath
            );
        }
        // path params
        if ($rules_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rules_set_id' . '}',
                ObjectSerializer::toPathValue($rules_set_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudFirewallRulesSetRulesDestroy2
     *
     * @param  string $rule_id rule_id (required)
     * @param  string $rules_set_id rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cloudFirewallRulesSetRulesDestroy2($rule_id, $rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesDestroy2'][0])
    {
        $this->cloudFirewallRulesSetRulesDestroy2WithHttpInfo($rule_id, $rules_set_id, $contentType);
    }

    /**
     * Operation cloudFirewallRulesSetRulesDestroy2WithHttpInfo
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudFirewallRulesSetRulesDestroy2WithHttpInfo($rule_id, $rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesDestroy2'][0])
    {
        $request = $this->cloudFirewallRulesSetRulesDestroy2Request($rule_id, $rules_set_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cloudFirewallRulesSetRulesDestroy2Async
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRulesDestroy2Async($rule_id, $rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesDestroy2'][0])
    {
        return $this->cloudFirewallRulesSetRulesDestroy2AsyncWithHttpInfo($rule_id, $rules_set_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudFirewallRulesSetRulesDestroy2AsyncWithHttpInfo
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRulesDestroy2AsyncWithHttpInfo($rule_id, $rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesDestroy2'][0])
    {
        $returnType = '';
        $request = $this->cloudFirewallRulesSetRulesDestroy2Request($rule_id, $rules_set_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudFirewallRulesSetRulesDestroy2'
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudFirewallRulesSetRulesDestroy2Request($rule_id, $rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesDestroy2'][0])
    {

        // verify the required parameter 'rule_id' is set
        if ($rule_id === null || (is_array($rule_id) && count($rule_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rule_id when calling cloudFirewallRulesSetRulesDestroy2'
            );
        }

        // verify the required parameter 'rules_set_id' is set
        if ($rules_set_id === null || (is_array($rules_set_id) && count($rules_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rules_set_id when calling cloudFirewallRulesSetRulesDestroy2'
            );
        }
        if (!preg_match("/^\\d{1,10}$/", $rules_set_id)) {
            throw new \InvalidArgumentException("invalid value for \"rules_set_id\" when calling CloudApi.cloudFirewallRulesSetRulesDestroy2, must conform to the pattern /^\\d{1,10}$/.");
        }
        

        $resourcePath = '/api/v1/cloud/firewall-rules-set/{rules_set_id}/rules/{rule_id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($rule_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rule_id' . '}',
                ObjectSerializer::toPathValue($rule_id),
                $resourcePath
            );
        }
        // path params
        if ($rules_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rules_set_id' . '}',
                ObjectSerializer::toPathValue($rules_set_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudFirewallRulesSetRulesList
     *
     * @param  string $rules_set_id rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\FirewallRule[]
     */
    public function cloudFirewallRulesSetRulesList($rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesList'][0])
    {
        list($response) = $this->cloudFirewallRulesSetRulesListWithHttpInfo($rules_set_id, $contentType);
        return $response;
    }

    /**
     * Operation cloudFirewallRulesSetRulesListWithHttpInfo
     *
     * @param  string $rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\FirewallRule[], HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudFirewallRulesSetRulesListWithHttpInfo($rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesList'][0])
    {
        $request = $this->cloudFirewallRulesSetRulesListRequest($rules_set_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\FirewallRule[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\FirewallRule[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\FirewallRule[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\FirewallRule[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\FirewallRule[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudFirewallRulesSetRulesListAsync
     *
     * @param  string $rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRulesListAsync($rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesList'][0])
    {
        return $this->cloudFirewallRulesSetRulesListAsyncWithHttpInfo($rules_set_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudFirewallRulesSetRulesListAsyncWithHttpInfo
     *
     * @param  string $rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRulesListAsyncWithHttpInfo($rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesList'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\FirewallRule[]';
        $request = $this->cloudFirewallRulesSetRulesListRequest($rules_set_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudFirewallRulesSetRulesList'
     *
     * @param  string $rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudFirewallRulesSetRulesListRequest($rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesList'][0])
    {

        // verify the required parameter 'rules_set_id' is set
        if ($rules_set_id === null || (is_array($rules_set_id) && count($rules_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rules_set_id when calling cloudFirewallRulesSetRulesList'
            );
        }
        if (!preg_match("/^\\d{1,10}$/", $rules_set_id)) {
            throw new \InvalidArgumentException("invalid value for \"rules_set_id\" when calling CloudApi.cloudFirewallRulesSetRulesList, must conform to the pattern /^\\d{1,10}$/.");
        }
        

        $resourcePath = '/api/cloud/firewall-rules-set/{rules_set_id}/rules/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($rules_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rules_set_id' . '}',
                ObjectSerializer::toPathValue($rules_set_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudFirewallRulesSetRulesList2
     *
     * @param  string $rules_set_id rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\FirewallRule[]
     */
    public function cloudFirewallRulesSetRulesList2($rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesList2'][0])
    {
        list($response) = $this->cloudFirewallRulesSetRulesList2WithHttpInfo($rules_set_id, $contentType);
        return $response;
    }

    /**
     * Operation cloudFirewallRulesSetRulesList2WithHttpInfo
     *
     * @param  string $rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\FirewallRule[], HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudFirewallRulesSetRulesList2WithHttpInfo($rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesList2'][0])
    {
        $request = $this->cloudFirewallRulesSetRulesList2Request($rules_set_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\FirewallRule[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\FirewallRule[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\FirewallRule[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\FirewallRule[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\FirewallRule[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudFirewallRulesSetRulesList2Async
     *
     * @param  string $rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRulesList2Async($rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesList2'][0])
    {
        return $this->cloudFirewallRulesSetRulesList2AsyncWithHttpInfo($rules_set_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudFirewallRulesSetRulesList2AsyncWithHttpInfo
     *
     * @param  string $rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRulesList2AsyncWithHttpInfo($rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesList2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\FirewallRule[]';
        $request = $this->cloudFirewallRulesSetRulesList2Request($rules_set_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudFirewallRulesSetRulesList2'
     *
     * @param  string $rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudFirewallRulesSetRulesList2Request($rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesList2'][0])
    {

        // verify the required parameter 'rules_set_id' is set
        if ($rules_set_id === null || (is_array($rules_set_id) && count($rules_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rules_set_id when calling cloudFirewallRulesSetRulesList2'
            );
        }
        if (!preg_match("/^\\d{1,10}$/", $rules_set_id)) {
            throw new \InvalidArgumentException("invalid value for \"rules_set_id\" when calling CloudApi.cloudFirewallRulesSetRulesList2, must conform to the pattern /^\\d{1,10}$/.");
        }
        

        $resourcePath = '/api/v1/cloud/firewall-rules-set/{rules_set_id}/rules/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($rules_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rules_set_id' . '}',
                ObjectSerializer::toPathValue($rules_set_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudFirewallRulesSetRulesPartialUpdate
     *
     * @param  string $rule_id rule_id (required)
     * @param  string $rules_set_id rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedFirewallRule|null $patched_firewall_rule patched_firewall_rule (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\FirewallRule
     */
    public function cloudFirewallRulesSetRulesPartialUpdate($rule_id, $rules_set_id, $patched_firewall_rule = null, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesPartialUpdate'][0])
    {
        list($response) = $this->cloudFirewallRulesSetRulesPartialUpdateWithHttpInfo($rule_id, $rules_set_id, $patched_firewall_rule, $contentType);
        return $response;
    }

    /**
     * Operation cloudFirewallRulesSetRulesPartialUpdateWithHttpInfo
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedFirewallRule|null $patched_firewall_rule (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\FirewallRule, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudFirewallRulesSetRulesPartialUpdateWithHttpInfo($rule_id, $rules_set_id, $patched_firewall_rule = null, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesPartialUpdate'][0])
    {
        $request = $this->cloudFirewallRulesSetRulesPartialUpdateRequest($rule_id, $rules_set_id, $patched_firewall_rule, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\FirewallRule' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\FirewallRule' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\FirewallRule', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\FirewallRule';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\FirewallRule',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudFirewallRulesSetRulesPartialUpdateAsync
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedFirewallRule|null $patched_firewall_rule (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRulesPartialUpdateAsync($rule_id, $rules_set_id, $patched_firewall_rule = null, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesPartialUpdate'][0])
    {
        return $this->cloudFirewallRulesSetRulesPartialUpdateAsyncWithHttpInfo($rule_id, $rules_set_id, $patched_firewall_rule, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudFirewallRulesSetRulesPartialUpdateAsyncWithHttpInfo
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedFirewallRule|null $patched_firewall_rule (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRulesPartialUpdateAsyncWithHttpInfo($rule_id, $rules_set_id, $patched_firewall_rule = null, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesPartialUpdate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\FirewallRule';
        $request = $this->cloudFirewallRulesSetRulesPartialUpdateRequest($rule_id, $rules_set_id, $patched_firewall_rule, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudFirewallRulesSetRulesPartialUpdate'
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedFirewallRule|null $patched_firewall_rule (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudFirewallRulesSetRulesPartialUpdateRequest($rule_id, $rules_set_id, $patched_firewall_rule = null, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesPartialUpdate'][0])
    {

        // verify the required parameter 'rule_id' is set
        if ($rule_id === null || (is_array($rule_id) && count($rule_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rule_id when calling cloudFirewallRulesSetRulesPartialUpdate'
            );
        }

        // verify the required parameter 'rules_set_id' is set
        if ($rules_set_id === null || (is_array($rules_set_id) && count($rules_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rules_set_id when calling cloudFirewallRulesSetRulesPartialUpdate'
            );
        }
        if (!preg_match("/^\\d{1,10}$/", $rules_set_id)) {
            throw new \InvalidArgumentException("invalid value for \"rules_set_id\" when calling CloudApi.cloudFirewallRulesSetRulesPartialUpdate, must conform to the pattern /^\\d{1,10}$/.");
        }
        


        $resourcePath = '/api/cloud/firewall-rules-set/{rules_set_id}/rules/{rule_id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($rule_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rule_id' . '}',
                ObjectSerializer::toPathValue($rule_id),
                $resourcePath
            );
        }
        // path params
        if ($rules_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rules_set_id' . '}',
                ObjectSerializer::toPathValue($rules_set_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_firewall_rule)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_firewall_rule));
            } else {
                $httpBody = $patched_firewall_rule;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudFirewallRulesSetRulesPartialUpdate2
     *
     * @param  string $rule_id rule_id (required)
     * @param  string $rules_set_id rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedFirewallRule|null $patched_firewall_rule patched_firewall_rule (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\FirewallRule
     */
    public function cloudFirewallRulesSetRulesPartialUpdate2($rule_id, $rules_set_id, $patched_firewall_rule = null, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesPartialUpdate2'][0])
    {
        list($response) = $this->cloudFirewallRulesSetRulesPartialUpdate2WithHttpInfo($rule_id, $rules_set_id, $patched_firewall_rule, $contentType);
        return $response;
    }

    /**
     * Operation cloudFirewallRulesSetRulesPartialUpdate2WithHttpInfo
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedFirewallRule|null $patched_firewall_rule (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\FirewallRule, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudFirewallRulesSetRulesPartialUpdate2WithHttpInfo($rule_id, $rules_set_id, $patched_firewall_rule = null, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesPartialUpdate2'][0])
    {
        $request = $this->cloudFirewallRulesSetRulesPartialUpdate2Request($rule_id, $rules_set_id, $patched_firewall_rule, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\FirewallRule' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\FirewallRule' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\FirewallRule', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\FirewallRule';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\FirewallRule',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudFirewallRulesSetRulesPartialUpdate2Async
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedFirewallRule|null $patched_firewall_rule (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRulesPartialUpdate2Async($rule_id, $rules_set_id, $patched_firewall_rule = null, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesPartialUpdate2'][0])
    {
        return $this->cloudFirewallRulesSetRulesPartialUpdate2AsyncWithHttpInfo($rule_id, $rules_set_id, $patched_firewall_rule, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudFirewallRulesSetRulesPartialUpdate2AsyncWithHttpInfo
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedFirewallRule|null $patched_firewall_rule (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRulesPartialUpdate2AsyncWithHttpInfo($rule_id, $rules_set_id, $patched_firewall_rule = null, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesPartialUpdate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\FirewallRule';
        $request = $this->cloudFirewallRulesSetRulesPartialUpdate2Request($rule_id, $rules_set_id, $patched_firewall_rule, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudFirewallRulesSetRulesPartialUpdate2'
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedFirewallRule|null $patched_firewall_rule (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudFirewallRulesSetRulesPartialUpdate2Request($rule_id, $rules_set_id, $patched_firewall_rule = null, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesPartialUpdate2'][0])
    {

        // verify the required parameter 'rule_id' is set
        if ($rule_id === null || (is_array($rule_id) && count($rule_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rule_id when calling cloudFirewallRulesSetRulesPartialUpdate2'
            );
        }

        // verify the required parameter 'rules_set_id' is set
        if ($rules_set_id === null || (is_array($rules_set_id) && count($rules_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rules_set_id when calling cloudFirewallRulesSetRulesPartialUpdate2'
            );
        }
        if (!preg_match("/^\\d{1,10}$/", $rules_set_id)) {
            throw new \InvalidArgumentException("invalid value for \"rules_set_id\" when calling CloudApi.cloudFirewallRulesSetRulesPartialUpdate2, must conform to the pattern /^\\d{1,10}$/.");
        }
        


        $resourcePath = '/api/v1/cloud/firewall-rules-set/{rules_set_id}/rules/{rule_id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($rule_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rule_id' . '}',
                ObjectSerializer::toPathValue($rule_id),
                $resourcePath
            );
        }
        // path params
        if ($rules_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rules_set_id' . '}',
                ObjectSerializer::toPathValue($rules_set_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_firewall_rule)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_firewall_rule));
            } else {
                $httpBody = $patched_firewall_rule;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudFirewallRulesSetRulesRetrieve
     *
     * @param  string $rule_id rule_id (required)
     * @param  string $rules_set_id rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\FirewallRule
     */
    public function cloudFirewallRulesSetRulesRetrieve($rule_id, $rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesRetrieve'][0])
    {
        list($response) = $this->cloudFirewallRulesSetRulesRetrieveWithHttpInfo($rule_id, $rules_set_id, $contentType);
        return $response;
    }

    /**
     * Operation cloudFirewallRulesSetRulesRetrieveWithHttpInfo
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\FirewallRule, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudFirewallRulesSetRulesRetrieveWithHttpInfo($rule_id, $rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesRetrieve'][0])
    {
        $request = $this->cloudFirewallRulesSetRulesRetrieveRequest($rule_id, $rules_set_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\FirewallRule' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\FirewallRule' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\FirewallRule', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\FirewallRule';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\FirewallRule',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudFirewallRulesSetRulesRetrieveAsync
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRulesRetrieveAsync($rule_id, $rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesRetrieve'][0])
    {
        return $this->cloudFirewallRulesSetRulesRetrieveAsyncWithHttpInfo($rule_id, $rules_set_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudFirewallRulesSetRulesRetrieveAsyncWithHttpInfo
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRulesRetrieveAsyncWithHttpInfo($rule_id, $rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesRetrieve'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\FirewallRule';
        $request = $this->cloudFirewallRulesSetRulesRetrieveRequest($rule_id, $rules_set_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudFirewallRulesSetRulesRetrieve'
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudFirewallRulesSetRulesRetrieveRequest($rule_id, $rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesRetrieve'][0])
    {

        // verify the required parameter 'rule_id' is set
        if ($rule_id === null || (is_array($rule_id) && count($rule_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rule_id when calling cloudFirewallRulesSetRulesRetrieve'
            );
        }

        // verify the required parameter 'rules_set_id' is set
        if ($rules_set_id === null || (is_array($rules_set_id) && count($rules_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rules_set_id when calling cloudFirewallRulesSetRulesRetrieve'
            );
        }
        if (!preg_match("/^\\d{1,10}$/", $rules_set_id)) {
            throw new \InvalidArgumentException("invalid value for \"rules_set_id\" when calling CloudApi.cloudFirewallRulesSetRulesRetrieve, must conform to the pattern /^\\d{1,10}$/.");
        }
        

        $resourcePath = '/api/cloud/firewall-rules-set/{rules_set_id}/rules/{rule_id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($rule_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rule_id' . '}',
                ObjectSerializer::toPathValue($rule_id),
                $resourcePath
            );
        }
        // path params
        if ($rules_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rules_set_id' . '}',
                ObjectSerializer::toPathValue($rules_set_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudFirewallRulesSetRulesRetrieve2
     *
     * @param  string $rule_id rule_id (required)
     * @param  string $rules_set_id rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\FirewallRule
     */
    public function cloudFirewallRulesSetRulesRetrieve2($rule_id, $rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesRetrieve2'][0])
    {
        list($response) = $this->cloudFirewallRulesSetRulesRetrieve2WithHttpInfo($rule_id, $rules_set_id, $contentType);
        return $response;
    }

    /**
     * Operation cloudFirewallRulesSetRulesRetrieve2WithHttpInfo
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\FirewallRule, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudFirewallRulesSetRulesRetrieve2WithHttpInfo($rule_id, $rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesRetrieve2'][0])
    {
        $request = $this->cloudFirewallRulesSetRulesRetrieve2Request($rule_id, $rules_set_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\FirewallRule' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\FirewallRule' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\FirewallRule', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\FirewallRule';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\FirewallRule',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudFirewallRulesSetRulesRetrieve2Async
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRulesRetrieve2Async($rule_id, $rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesRetrieve2'][0])
    {
        return $this->cloudFirewallRulesSetRulesRetrieve2AsyncWithHttpInfo($rule_id, $rules_set_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudFirewallRulesSetRulesRetrieve2AsyncWithHttpInfo
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRulesRetrieve2AsyncWithHttpInfo($rule_id, $rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesRetrieve2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\FirewallRule';
        $request = $this->cloudFirewallRulesSetRulesRetrieve2Request($rule_id, $rules_set_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudFirewallRulesSetRulesRetrieve2'
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudFirewallRulesSetRulesRetrieve2Request($rule_id, $rules_set_id, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesRetrieve2'][0])
    {

        // verify the required parameter 'rule_id' is set
        if ($rule_id === null || (is_array($rule_id) && count($rule_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rule_id when calling cloudFirewallRulesSetRulesRetrieve2'
            );
        }

        // verify the required parameter 'rules_set_id' is set
        if ($rules_set_id === null || (is_array($rules_set_id) && count($rules_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rules_set_id when calling cloudFirewallRulesSetRulesRetrieve2'
            );
        }
        if (!preg_match("/^\\d{1,10}$/", $rules_set_id)) {
            throw new \InvalidArgumentException("invalid value for \"rules_set_id\" when calling CloudApi.cloudFirewallRulesSetRulesRetrieve2, must conform to the pattern /^\\d{1,10}$/.");
        }
        

        $resourcePath = '/api/v1/cloud/firewall-rules-set/{rules_set_id}/rules/{rule_id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($rule_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rule_id' . '}',
                ObjectSerializer::toPathValue($rule_id),
                $resourcePath
            );
        }
        // path params
        if ($rules_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rules_set_id' . '}',
                ObjectSerializer::toPathValue($rules_set_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudFirewallRulesSetRulesUpdate
     *
     * @param  string $rule_id rule_id (required)
     * @param  string $rules_set_id rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRule $firewall_rule firewall_rule (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\FirewallRule
     */
    public function cloudFirewallRulesSetRulesUpdate($rule_id, $rules_set_id, $firewall_rule, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesUpdate'][0])
    {
        list($response) = $this->cloudFirewallRulesSetRulesUpdateWithHttpInfo($rule_id, $rules_set_id, $firewall_rule, $contentType);
        return $response;
    }

    /**
     * Operation cloudFirewallRulesSetRulesUpdateWithHttpInfo
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRule $firewall_rule (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\FirewallRule, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudFirewallRulesSetRulesUpdateWithHttpInfo($rule_id, $rules_set_id, $firewall_rule, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesUpdate'][0])
    {
        $request = $this->cloudFirewallRulesSetRulesUpdateRequest($rule_id, $rules_set_id, $firewall_rule, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\FirewallRule' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\FirewallRule' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\FirewallRule', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\FirewallRule';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\FirewallRule',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudFirewallRulesSetRulesUpdateAsync
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRule $firewall_rule (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRulesUpdateAsync($rule_id, $rules_set_id, $firewall_rule, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesUpdate'][0])
    {
        return $this->cloudFirewallRulesSetRulesUpdateAsyncWithHttpInfo($rule_id, $rules_set_id, $firewall_rule, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudFirewallRulesSetRulesUpdateAsyncWithHttpInfo
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRule $firewall_rule (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRulesUpdateAsyncWithHttpInfo($rule_id, $rules_set_id, $firewall_rule, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesUpdate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\FirewallRule';
        $request = $this->cloudFirewallRulesSetRulesUpdateRequest($rule_id, $rules_set_id, $firewall_rule, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudFirewallRulesSetRulesUpdate'
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRule $firewall_rule (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudFirewallRulesSetRulesUpdateRequest($rule_id, $rules_set_id, $firewall_rule, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesUpdate'][0])
    {

        // verify the required parameter 'rule_id' is set
        if ($rule_id === null || (is_array($rule_id) && count($rule_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rule_id when calling cloudFirewallRulesSetRulesUpdate'
            );
        }

        // verify the required parameter 'rules_set_id' is set
        if ($rules_set_id === null || (is_array($rules_set_id) && count($rules_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rules_set_id when calling cloudFirewallRulesSetRulesUpdate'
            );
        }
        if (!preg_match("/^\\d{1,10}$/", $rules_set_id)) {
            throw new \InvalidArgumentException("invalid value for \"rules_set_id\" when calling CloudApi.cloudFirewallRulesSetRulesUpdate, must conform to the pattern /^\\d{1,10}$/.");
        }
        
        // verify the required parameter 'firewall_rule' is set
        if ($firewall_rule === null || (is_array($firewall_rule) && count($firewall_rule) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $firewall_rule when calling cloudFirewallRulesSetRulesUpdate'
            );
        }


        $resourcePath = '/api/cloud/firewall-rules-set/{rules_set_id}/rules/{rule_id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($rule_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rule_id' . '}',
                ObjectSerializer::toPathValue($rule_id),
                $resourcePath
            );
        }
        // path params
        if ($rules_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rules_set_id' . '}',
                ObjectSerializer::toPathValue($rules_set_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($firewall_rule)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($firewall_rule));
            } else {
                $httpBody = $firewall_rule;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudFirewallRulesSetRulesUpdate2
     *
     * @param  string $rule_id rule_id (required)
     * @param  string $rules_set_id rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRule $firewall_rule firewall_rule (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\FirewallRule
     */
    public function cloudFirewallRulesSetRulesUpdate2($rule_id, $rules_set_id, $firewall_rule, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesUpdate2'][0])
    {
        list($response) = $this->cloudFirewallRulesSetRulesUpdate2WithHttpInfo($rule_id, $rules_set_id, $firewall_rule, $contentType);
        return $response;
    }

    /**
     * Operation cloudFirewallRulesSetRulesUpdate2WithHttpInfo
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRule $firewall_rule (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\FirewallRule, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudFirewallRulesSetRulesUpdate2WithHttpInfo($rule_id, $rules_set_id, $firewall_rule, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesUpdate2'][0])
    {
        $request = $this->cloudFirewallRulesSetRulesUpdate2Request($rule_id, $rules_set_id, $firewall_rule, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\FirewallRule' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\FirewallRule' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\FirewallRule', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\FirewallRule';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\FirewallRule',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudFirewallRulesSetRulesUpdate2Async
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRule $firewall_rule (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRulesUpdate2Async($rule_id, $rules_set_id, $firewall_rule, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesUpdate2'][0])
    {
        return $this->cloudFirewallRulesSetRulesUpdate2AsyncWithHttpInfo($rule_id, $rules_set_id, $firewall_rule, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudFirewallRulesSetRulesUpdate2AsyncWithHttpInfo
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRule $firewall_rule (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetRulesUpdate2AsyncWithHttpInfo($rule_id, $rules_set_id, $firewall_rule, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesUpdate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\FirewallRule';
        $request = $this->cloudFirewallRulesSetRulesUpdate2Request($rule_id, $rules_set_id, $firewall_rule, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudFirewallRulesSetRulesUpdate2'
     *
     * @param  string $rule_id (required)
     * @param  string $rules_set_id (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRule $firewall_rule (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetRulesUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudFirewallRulesSetRulesUpdate2Request($rule_id, $rules_set_id, $firewall_rule, string $contentType = self::contentTypes['cloudFirewallRulesSetRulesUpdate2'][0])
    {

        // verify the required parameter 'rule_id' is set
        if ($rule_id === null || (is_array($rule_id) && count($rule_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rule_id when calling cloudFirewallRulesSetRulesUpdate2'
            );
        }

        // verify the required parameter 'rules_set_id' is set
        if ($rules_set_id === null || (is_array($rules_set_id) && count($rules_set_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rules_set_id when calling cloudFirewallRulesSetRulesUpdate2'
            );
        }
        if (!preg_match("/^\\d{1,10}$/", $rules_set_id)) {
            throw new \InvalidArgumentException("invalid value for \"rules_set_id\" when calling CloudApi.cloudFirewallRulesSetRulesUpdate2, must conform to the pattern /^\\d{1,10}$/.");
        }
        
        // verify the required parameter 'firewall_rule' is set
        if ($firewall_rule === null || (is_array($firewall_rule) && count($firewall_rule) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $firewall_rule when calling cloudFirewallRulesSetRulesUpdate2'
            );
        }


        $resourcePath = '/api/v1/cloud/firewall-rules-set/{rules_set_id}/rules/{rule_id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($rule_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rule_id' . '}',
                ObjectSerializer::toPathValue($rule_id),
                $resourcePath
            );
        }
        // path params
        if ($rules_set_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rules_set_id' . '}',
                ObjectSerializer::toPathValue($rules_set_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($firewall_rule)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($firewall_rule));
            } else {
                $httpBody = $firewall_rule;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudFirewallRulesSetUpdate
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRulesSet $firewall_rules_set firewall_rules_set (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\FirewallRulesSet
     */
    public function cloudFirewallRulesSetUpdate($id, $firewall_rules_set, string $contentType = self::contentTypes['cloudFirewallRulesSetUpdate'][0])
    {
        list($response) = $this->cloudFirewallRulesSetUpdateWithHttpInfo($id, $firewall_rules_set, $contentType);
        return $response;
    }

    /**
     * Operation cloudFirewallRulesSetUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRulesSet $firewall_rules_set (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\FirewallRulesSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudFirewallRulesSetUpdateWithHttpInfo($id, $firewall_rules_set, string $contentType = self::contentTypes['cloudFirewallRulesSetUpdate'][0])
    {
        $request = $this->cloudFirewallRulesSetUpdateRequest($id, $firewall_rules_set, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\FirewallRulesSet' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\FirewallRulesSet' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\FirewallRulesSet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\FirewallRulesSet';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\FirewallRulesSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudFirewallRulesSetUpdateAsync
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRulesSet $firewall_rules_set (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetUpdateAsync($id, $firewall_rules_set, string $contentType = self::contentTypes['cloudFirewallRulesSetUpdate'][0])
    {
        return $this->cloudFirewallRulesSetUpdateAsyncWithHttpInfo($id, $firewall_rules_set, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudFirewallRulesSetUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRulesSet $firewall_rules_set (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetUpdateAsyncWithHttpInfo($id, $firewall_rules_set, string $contentType = self::contentTypes['cloudFirewallRulesSetUpdate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\FirewallRulesSet';
        $request = $this->cloudFirewallRulesSetUpdateRequest($id, $firewall_rules_set, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudFirewallRulesSetUpdate'
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRulesSet $firewall_rules_set (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudFirewallRulesSetUpdateRequest($id, $firewall_rules_set, string $contentType = self::contentTypes['cloudFirewallRulesSetUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudFirewallRulesSetUpdate'
            );
        }

        // verify the required parameter 'firewall_rules_set' is set
        if ($firewall_rules_set === null || (is_array($firewall_rules_set) && count($firewall_rules_set) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $firewall_rules_set when calling cloudFirewallRulesSetUpdate'
            );
        }


        $resourcePath = '/api/cloud/firewall-rules-set/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($firewall_rules_set)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($firewall_rules_set));
            } else {
                $httpBody = $firewall_rules_set;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudFirewallRulesSetUpdate2
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRulesSet $firewall_rules_set firewall_rules_set (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\FirewallRulesSet
     */
    public function cloudFirewallRulesSetUpdate2($id, $firewall_rules_set, string $contentType = self::contentTypes['cloudFirewallRulesSetUpdate2'][0])
    {
        list($response) = $this->cloudFirewallRulesSetUpdate2WithHttpInfo($id, $firewall_rules_set, $contentType);
        return $response;
    }

    /**
     * Operation cloudFirewallRulesSetUpdate2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRulesSet $firewall_rules_set (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\FirewallRulesSet, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudFirewallRulesSetUpdate2WithHttpInfo($id, $firewall_rules_set, string $contentType = self::contentTypes['cloudFirewallRulesSetUpdate2'][0])
    {
        $request = $this->cloudFirewallRulesSetUpdate2Request($id, $firewall_rules_set, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\FirewallRulesSet' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\FirewallRulesSet' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\FirewallRulesSet', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\FirewallRulesSet';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\FirewallRulesSet',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudFirewallRulesSetUpdate2Async
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRulesSet $firewall_rules_set (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetUpdate2Async($id, $firewall_rules_set, string $contentType = self::contentTypes['cloudFirewallRulesSetUpdate2'][0])
    {
        return $this->cloudFirewallRulesSetUpdate2AsyncWithHttpInfo($id, $firewall_rules_set, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudFirewallRulesSetUpdate2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRulesSet $firewall_rules_set (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudFirewallRulesSetUpdate2AsyncWithHttpInfo($id, $firewall_rules_set, string $contentType = self::contentTypes['cloudFirewallRulesSetUpdate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\FirewallRulesSet';
        $request = $this->cloudFirewallRulesSetUpdate2Request($id, $firewall_rules_set, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudFirewallRulesSetUpdate2'
     *
     * @param  int $id A unique integer value identifying this firewall rules set. (required)
     * @param  \PidginHost\\Sdk\Model\FirewallRulesSet $firewall_rules_set (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudFirewallRulesSetUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudFirewallRulesSetUpdate2Request($id, $firewall_rules_set, string $contentType = self::contentTypes['cloudFirewallRulesSetUpdate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudFirewallRulesSetUpdate2'
            );
        }

        // verify the required parameter 'firewall_rules_set' is set
        if ($firewall_rules_set === null || (is_array($firewall_rules_set) && count($firewall_rules_set) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $firewall_rules_set when calling cloudFirewallRulesSetUpdate2'
            );
        }


        $resourcePath = '/api/v1/cloud/firewall-rules-set/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($firewall_rules_set)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($firewall_rules_set));
            } else {
                $httpBody = $firewall_rules_set;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudImagesList
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudImagesList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedOSImageList
     */
    public function cloudImagesList($page = null, string $contentType = self::contentTypes['cloudImagesList'][0])
    {
        list($response) = $this->cloudImagesListWithHttpInfo($page, $contentType);
        return $response;
    }

    /**
     * Operation cloudImagesListWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudImagesList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedOSImageList, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudImagesListWithHttpInfo($page = null, string $contentType = self::contentTypes['cloudImagesList'][0])
    {
        $request = $this->cloudImagesListRequest($page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedOSImageList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedOSImageList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedOSImageList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedOSImageList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedOSImageList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudImagesListAsync
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudImagesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudImagesListAsync($page = null, string $contentType = self::contentTypes['cloudImagesList'][0])
    {
        return $this->cloudImagesListAsyncWithHttpInfo($page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudImagesListAsyncWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudImagesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudImagesListAsyncWithHttpInfo($page = null, string $contentType = self::contentTypes['cloudImagesList'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedOSImageList';
        $request = $this->cloudImagesListRequest($page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudImagesList'
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudImagesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudImagesListRequest($page = null, string $contentType = self::contentTypes['cloudImagesList'][0])
    {



        $resourcePath = '/api/cloud/images/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudImagesList2
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudImagesList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedOSImageList
     */
    public function cloudImagesList2($page = null, string $contentType = self::contentTypes['cloudImagesList2'][0])
    {
        list($response) = $this->cloudImagesList2WithHttpInfo($page, $contentType);
        return $response;
    }

    /**
     * Operation cloudImagesList2WithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudImagesList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedOSImageList, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudImagesList2WithHttpInfo($page = null, string $contentType = self::contentTypes['cloudImagesList2'][0])
    {
        $request = $this->cloudImagesList2Request($page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedOSImageList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedOSImageList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedOSImageList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedOSImageList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedOSImageList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudImagesList2Async
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudImagesList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudImagesList2Async($page = null, string $contentType = self::contentTypes['cloudImagesList2'][0])
    {
        return $this->cloudImagesList2AsyncWithHttpInfo($page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudImagesList2AsyncWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudImagesList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudImagesList2AsyncWithHttpInfo($page = null, string $contentType = self::contentTypes['cloudImagesList2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedOSImageList';
        $request = $this->cloudImagesList2Request($page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudImagesList2'
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudImagesList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudImagesList2Request($page = null, string $contentType = self::contentTypes['cloudImagesList2'][0])
    {



        $resourcePath = '/api/v1/cloud/images/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudImagesRetrieve
     *
     * @param  int $id A unique integer value identifying this operating system. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudImagesRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\OSImage
     */
    public function cloudImagesRetrieve($id, string $contentType = self::contentTypes['cloudImagesRetrieve'][0])
    {
        list($response) = $this->cloudImagesRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation cloudImagesRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this operating system. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudImagesRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\OSImage, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudImagesRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['cloudImagesRetrieve'][0])
    {
        $request = $this->cloudImagesRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\OSImage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\OSImage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\OSImage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\OSImage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\OSImage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudImagesRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this operating system. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudImagesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudImagesRetrieveAsync($id, string $contentType = self::contentTypes['cloudImagesRetrieve'][0])
    {
        return $this->cloudImagesRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudImagesRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this operating system. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudImagesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudImagesRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudImagesRetrieve'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\OSImage';
        $request = $this->cloudImagesRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudImagesRetrieve'
     *
     * @param  int $id A unique integer value identifying this operating system. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudImagesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudImagesRetrieveRequest($id, string $contentType = self::contentTypes['cloudImagesRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudImagesRetrieve'
            );
        }


        $resourcePath = '/api/cloud/images/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudImagesRetrieve2
     *
     * @param  int $id A unique integer value identifying this operating system. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudImagesRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\OSImage
     */
    public function cloudImagesRetrieve2($id, string $contentType = self::contentTypes['cloudImagesRetrieve2'][0])
    {
        list($response) = $this->cloudImagesRetrieve2WithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation cloudImagesRetrieve2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this operating system. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudImagesRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\OSImage, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudImagesRetrieve2WithHttpInfo($id, string $contentType = self::contentTypes['cloudImagesRetrieve2'][0])
    {
        $request = $this->cloudImagesRetrieve2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\OSImage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\OSImage' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\OSImage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\OSImage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\OSImage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudImagesRetrieve2Async
     *
     * @param  int $id A unique integer value identifying this operating system. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudImagesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudImagesRetrieve2Async($id, string $contentType = self::contentTypes['cloudImagesRetrieve2'][0])
    {
        return $this->cloudImagesRetrieve2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudImagesRetrieve2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this operating system. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudImagesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudImagesRetrieve2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudImagesRetrieve2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\OSImage';
        $request = $this->cloudImagesRetrieve2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudImagesRetrieve2'
     *
     * @param  int $id A unique integer value identifying this operating system. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudImagesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudImagesRetrieve2Request($id, string $contentType = self::contentTypes['cloudImagesRetrieve2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudImagesRetrieve2'
            );
        }


        $resourcePath = '/api/v1/cloud/images/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudIpv4Create
     *
     * @param  \PidginHost\\Sdk\Model\PublicIPv4|null $public_ipv4 public_ipv4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Create'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PublicIPv4
     */
    public function cloudIpv4Create($public_ipv4 = null, string $contentType = self::contentTypes['cloudIpv4Create'][0])
    {
        list($response) = $this->cloudIpv4CreateWithHttpInfo($public_ipv4, $contentType);
        return $response;
    }

    /**
     * Operation cloudIpv4CreateWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\PublicIPv4|null $public_ipv4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Create'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PublicIPv4, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudIpv4CreateWithHttpInfo($public_ipv4 = null, string $contentType = self::contentTypes['cloudIpv4Create'][0])
    {
        $request = $this->cloudIpv4CreateRequest($public_ipv4, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\PublicIPv4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PublicIPv4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PublicIPv4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PublicIPv4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PublicIPv4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudIpv4CreateAsync
     *
     * @param  \PidginHost\\Sdk\Model\PublicIPv4|null $public_ipv4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Create'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv4CreateAsync($public_ipv4 = null, string $contentType = self::contentTypes['cloudIpv4Create'][0])
    {
        return $this->cloudIpv4CreateAsyncWithHttpInfo($public_ipv4, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudIpv4CreateAsyncWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\PublicIPv4|null $public_ipv4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Create'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv4CreateAsyncWithHttpInfo($public_ipv4 = null, string $contentType = self::contentTypes['cloudIpv4Create'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PublicIPv4';
        $request = $this->cloudIpv4CreateRequest($public_ipv4, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudIpv4Create'
     *
     * @param  \PidginHost\\Sdk\Model\PublicIPv4|null $public_ipv4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Create'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudIpv4CreateRequest($public_ipv4 = null, string $contentType = self::contentTypes['cloudIpv4Create'][0])
    {



        $resourcePath = '/api/cloud/ipv4/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($public_ipv4)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($public_ipv4));
            } else {
                $httpBody = $public_ipv4;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudIpv4Create2
     *
     * @param  \PidginHost\\Sdk\Model\PublicIPv4|null $public_ipv4 public_ipv4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Create2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PublicIPv4
     */
    public function cloudIpv4Create2($public_ipv4 = null, string $contentType = self::contentTypes['cloudIpv4Create2'][0])
    {
        list($response) = $this->cloudIpv4Create2WithHttpInfo($public_ipv4, $contentType);
        return $response;
    }

    /**
     * Operation cloudIpv4Create2WithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\PublicIPv4|null $public_ipv4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Create2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PublicIPv4, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudIpv4Create2WithHttpInfo($public_ipv4 = null, string $contentType = self::contentTypes['cloudIpv4Create2'][0])
    {
        $request = $this->cloudIpv4Create2Request($public_ipv4, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\PublicIPv4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PublicIPv4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PublicIPv4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PublicIPv4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PublicIPv4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudIpv4Create2Async
     *
     * @param  \PidginHost\\Sdk\Model\PublicIPv4|null $public_ipv4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Create2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv4Create2Async($public_ipv4 = null, string $contentType = self::contentTypes['cloudIpv4Create2'][0])
    {
        return $this->cloudIpv4Create2AsyncWithHttpInfo($public_ipv4, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudIpv4Create2AsyncWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\PublicIPv4|null $public_ipv4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Create2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv4Create2AsyncWithHttpInfo($public_ipv4 = null, string $contentType = self::contentTypes['cloudIpv4Create2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PublicIPv4';
        $request = $this->cloudIpv4Create2Request($public_ipv4, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudIpv4Create2'
     *
     * @param  \PidginHost\\Sdk\Model\PublicIPv4|null $public_ipv4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Create2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudIpv4Create2Request($public_ipv4 = null, string $contentType = self::contentTypes['cloudIpv4Create2'][0])
    {



        $resourcePath = '/api/v1/cloud/ipv4/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($public_ipv4)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($public_ipv4));
            } else {
                $httpBody = $public_ipv4;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudIpv4Destroy
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Destroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cloudIpv4Destroy($id, string $contentType = self::contentTypes['cloudIpv4Destroy'][0])
    {
        $this->cloudIpv4DestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation cloudIpv4DestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Destroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudIpv4DestroyWithHttpInfo($id, string $contentType = self::contentTypes['cloudIpv4Destroy'][0])
    {
        $request = $this->cloudIpv4DestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cloudIpv4DestroyAsync
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Destroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv4DestroyAsync($id, string $contentType = self::contentTypes['cloudIpv4Destroy'][0])
    {
        return $this->cloudIpv4DestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudIpv4DestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Destroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv4DestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudIpv4Destroy'][0])
    {
        $returnType = '';
        $request = $this->cloudIpv4DestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudIpv4Destroy'
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Destroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudIpv4DestroyRequest($id, string $contentType = self::contentTypes['cloudIpv4Destroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudIpv4Destroy'
            );
        }


        $resourcePath = '/api/cloud/ipv4/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudIpv4Destroy2
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Destroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cloudIpv4Destroy2($id, string $contentType = self::contentTypes['cloudIpv4Destroy2'][0])
    {
        $this->cloudIpv4Destroy2WithHttpInfo($id, $contentType);
    }

    /**
     * Operation cloudIpv4Destroy2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Destroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudIpv4Destroy2WithHttpInfo($id, string $contentType = self::contentTypes['cloudIpv4Destroy2'][0])
    {
        $request = $this->cloudIpv4Destroy2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cloudIpv4Destroy2Async
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Destroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv4Destroy2Async($id, string $contentType = self::contentTypes['cloudIpv4Destroy2'][0])
    {
        return $this->cloudIpv4Destroy2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudIpv4Destroy2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Destroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv4Destroy2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudIpv4Destroy2'][0])
    {
        $returnType = '';
        $request = $this->cloudIpv4Destroy2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudIpv4Destroy2'
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Destroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudIpv4Destroy2Request($id, string $contentType = self::contentTypes['cloudIpv4Destroy2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudIpv4Destroy2'
            );
        }


        $resourcePath = '/api/v1/cloud/ipv4/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudIpv4DetachCreate
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  \PidginHost\\Sdk\Model\PublicIPv4|null $public_ipv4 public_ipv4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4DetachCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\DetachIPv4Response
     */
    public function cloudIpv4DetachCreate($id, $public_ipv4 = null, string $contentType = self::contentTypes['cloudIpv4DetachCreate'][0])
    {
        list($response) = $this->cloudIpv4DetachCreateWithHttpInfo($id, $public_ipv4, $contentType);
        return $response;
    }

    /**
     * Operation cloudIpv4DetachCreateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  \PidginHost\\Sdk\Model\PublicIPv4|null $public_ipv4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4DetachCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\DetachIPv4Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudIpv4DetachCreateWithHttpInfo($id, $public_ipv4 = null, string $contentType = self::contentTypes['cloudIpv4DetachCreate'][0])
    {
        $request = $this->cloudIpv4DetachCreateRequest($id, $public_ipv4, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\DetachIPv4Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\DetachIPv4Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\DetachIPv4Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\DetachIPv4Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\DetachIPv4Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudIpv4DetachCreateAsync
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  \PidginHost\\Sdk\Model\PublicIPv4|null $public_ipv4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4DetachCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv4DetachCreateAsync($id, $public_ipv4 = null, string $contentType = self::contentTypes['cloudIpv4DetachCreate'][0])
    {
        return $this->cloudIpv4DetachCreateAsyncWithHttpInfo($id, $public_ipv4, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudIpv4DetachCreateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  \PidginHost\\Sdk\Model\PublicIPv4|null $public_ipv4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4DetachCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv4DetachCreateAsyncWithHttpInfo($id, $public_ipv4 = null, string $contentType = self::contentTypes['cloudIpv4DetachCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\DetachIPv4Response';
        $request = $this->cloudIpv4DetachCreateRequest($id, $public_ipv4, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudIpv4DetachCreate'
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  \PidginHost\\Sdk\Model\PublicIPv4|null $public_ipv4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4DetachCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudIpv4DetachCreateRequest($id, $public_ipv4 = null, string $contentType = self::contentTypes['cloudIpv4DetachCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudIpv4DetachCreate'
            );
        }



        $resourcePath = '/api/cloud/ipv4/{id}/detach/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($public_ipv4)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($public_ipv4));
            } else {
                $httpBody = $public_ipv4;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudIpv4DetachCreate2
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  \PidginHost\\Sdk\Model\PublicIPv4|null $public_ipv4 public_ipv4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4DetachCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\DetachIPv4Response
     */
    public function cloudIpv4DetachCreate2($id, $public_ipv4 = null, string $contentType = self::contentTypes['cloudIpv4DetachCreate2'][0])
    {
        list($response) = $this->cloudIpv4DetachCreate2WithHttpInfo($id, $public_ipv4, $contentType);
        return $response;
    }

    /**
     * Operation cloudIpv4DetachCreate2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  \PidginHost\\Sdk\Model\PublicIPv4|null $public_ipv4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4DetachCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\DetachIPv4Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudIpv4DetachCreate2WithHttpInfo($id, $public_ipv4 = null, string $contentType = self::contentTypes['cloudIpv4DetachCreate2'][0])
    {
        $request = $this->cloudIpv4DetachCreate2Request($id, $public_ipv4, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\DetachIPv4Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\DetachIPv4Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\DetachIPv4Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\DetachIPv4Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\DetachIPv4Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudIpv4DetachCreate2Async
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  \PidginHost\\Sdk\Model\PublicIPv4|null $public_ipv4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4DetachCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv4DetachCreate2Async($id, $public_ipv4 = null, string $contentType = self::contentTypes['cloudIpv4DetachCreate2'][0])
    {
        return $this->cloudIpv4DetachCreate2AsyncWithHttpInfo($id, $public_ipv4, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudIpv4DetachCreate2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  \PidginHost\\Sdk\Model\PublicIPv4|null $public_ipv4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4DetachCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv4DetachCreate2AsyncWithHttpInfo($id, $public_ipv4 = null, string $contentType = self::contentTypes['cloudIpv4DetachCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\DetachIPv4Response';
        $request = $this->cloudIpv4DetachCreate2Request($id, $public_ipv4, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudIpv4DetachCreate2'
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  \PidginHost\\Sdk\Model\PublicIPv4|null $public_ipv4 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4DetachCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudIpv4DetachCreate2Request($id, $public_ipv4 = null, string $contentType = self::contentTypes['cloudIpv4DetachCreate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudIpv4DetachCreate2'
            );
        }



        $resourcePath = '/api/v1/cloud/ipv4/{id}/detach/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($public_ipv4)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($public_ipv4));
            } else {
                $httpBody = $public_ipv4;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudIpv4List
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4List'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedPublicIPv4List
     */
    public function cloudIpv4List($page = null, string $contentType = self::contentTypes['cloudIpv4List'][0])
    {
        list($response) = $this->cloudIpv4ListWithHttpInfo($page, $contentType);
        return $response;
    }

    /**
     * Operation cloudIpv4ListWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4List'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedPublicIPv4List, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudIpv4ListWithHttpInfo($page = null, string $contentType = self::contentTypes['cloudIpv4List'][0])
    {
        $request = $this->cloudIpv4ListRequest($page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedPublicIPv4List' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedPublicIPv4List' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedPublicIPv4List', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedPublicIPv4List';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedPublicIPv4List',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudIpv4ListAsync
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4List'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv4ListAsync($page = null, string $contentType = self::contentTypes['cloudIpv4List'][0])
    {
        return $this->cloudIpv4ListAsyncWithHttpInfo($page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudIpv4ListAsyncWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4List'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv4ListAsyncWithHttpInfo($page = null, string $contentType = self::contentTypes['cloudIpv4List'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedPublicIPv4List';
        $request = $this->cloudIpv4ListRequest($page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudIpv4List'
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4List'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudIpv4ListRequest($page = null, string $contentType = self::contentTypes['cloudIpv4List'][0])
    {



        $resourcePath = '/api/cloud/ipv4/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudIpv4List2
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4List2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedPublicIPv4List
     */
    public function cloudIpv4List2($page = null, string $contentType = self::contentTypes['cloudIpv4List2'][0])
    {
        list($response) = $this->cloudIpv4List2WithHttpInfo($page, $contentType);
        return $response;
    }

    /**
     * Operation cloudIpv4List2WithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4List2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedPublicIPv4List, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudIpv4List2WithHttpInfo($page = null, string $contentType = self::contentTypes['cloudIpv4List2'][0])
    {
        $request = $this->cloudIpv4List2Request($page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedPublicIPv4List' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedPublicIPv4List' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedPublicIPv4List', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedPublicIPv4List';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedPublicIPv4List',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudIpv4List2Async
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4List2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv4List2Async($page = null, string $contentType = self::contentTypes['cloudIpv4List2'][0])
    {
        return $this->cloudIpv4List2AsyncWithHttpInfo($page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudIpv4List2AsyncWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4List2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv4List2AsyncWithHttpInfo($page = null, string $contentType = self::contentTypes['cloudIpv4List2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedPublicIPv4List';
        $request = $this->cloudIpv4List2Request($page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudIpv4List2'
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4List2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudIpv4List2Request($page = null, string $contentType = self::contentTypes['cloudIpv4List2'][0])
    {



        $resourcePath = '/api/v1/cloud/ipv4/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudIpv4Retrieve
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Retrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PublicIPv4
     */
    public function cloudIpv4Retrieve($id, string $contentType = self::contentTypes['cloudIpv4Retrieve'][0])
    {
        list($response) = $this->cloudIpv4RetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation cloudIpv4RetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Retrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PublicIPv4, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudIpv4RetrieveWithHttpInfo($id, string $contentType = self::contentTypes['cloudIpv4Retrieve'][0])
    {
        $request = $this->cloudIpv4RetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PublicIPv4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PublicIPv4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PublicIPv4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PublicIPv4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PublicIPv4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudIpv4RetrieveAsync
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Retrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv4RetrieveAsync($id, string $contentType = self::contentTypes['cloudIpv4Retrieve'][0])
    {
        return $this->cloudIpv4RetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudIpv4RetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Retrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv4RetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudIpv4Retrieve'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PublicIPv4';
        $request = $this->cloudIpv4RetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudIpv4Retrieve'
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Retrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudIpv4RetrieveRequest($id, string $contentType = self::contentTypes['cloudIpv4Retrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudIpv4Retrieve'
            );
        }


        $resourcePath = '/api/cloud/ipv4/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudIpv4Retrieve2
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Retrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PublicIPv4
     */
    public function cloudIpv4Retrieve2($id, string $contentType = self::contentTypes['cloudIpv4Retrieve2'][0])
    {
        list($response) = $this->cloudIpv4Retrieve2WithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation cloudIpv4Retrieve2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Retrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PublicIPv4, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudIpv4Retrieve2WithHttpInfo($id, string $contentType = self::contentTypes['cloudIpv4Retrieve2'][0])
    {
        $request = $this->cloudIpv4Retrieve2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PublicIPv4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PublicIPv4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PublicIPv4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PublicIPv4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PublicIPv4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudIpv4Retrieve2Async
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Retrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv4Retrieve2Async($id, string $contentType = self::contentTypes['cloudIpv4Retrieve2'][0])
    {
        return $this->cloudIpv4Retrieve2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudIpv4Retrieve2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Retrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv4Retrieve2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudIpv4Retrieve2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PublicIPv4';
        $request = $this->cloudIpv4Retrieve2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudIpv4Retrieve2'
     *
     * @param  int $id A unique integer value identifying this Public IPv4. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv4Retrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudIpv4Retrieve2Request($id, string $contentType = self::contentTypes['cloudIpv4Retrieve2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudIpv4Retrieve2'
            );
        }


        $resourcePath = '/api/v1/cloud/ipv4/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudIpv6Create
     *
     * @param  \PidginHost\\Sdk\Model\PublicIPv6|null $public_ipv6 public_ipv6 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Create'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PublicIPv6
     */
    public function cloudIpv6Create($public_ipv6 = null, string $contentType = self::contentTypes['cloudIpv6Create'][0])
    {
        list($response) = $this->cloudIpv6CreateWithHttpInfo($public_ipv6, $contentType);
        return $response;
    }

    /**
     * Operation cloudIpv6CreateWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\PublicIPv6|null $public_ipv6 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Create'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PublicIPv6, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudIpv6CreateWithHttpInfo($public_ipv6 = null, string $contentType = self::contentTypes['cloudIpv6Create'][0])
    {
        $request = $this->cloudIpv6CreateRequest($public_ipv6, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\PublicIPv6' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PublicIPv6' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PublicIPv6', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PublicIPv6';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PublicIPv6',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudIpv6CreateAsync
     *
     * @param  \PidginHost\\Sdk\Model\PublicIPv6|null $public_ipv6 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Create'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv6CreateAsync($public_ipv6 = null, string $contentType = self::contentTypes['cloudIpv6Create'][0])
    {
        return $this->cloudIpv6CreateAsyncWithHttpInfo($public_ipv6, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudIpv6CreateAsyncWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\PublicIPv6|null $public_ipv6 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Create'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv6CreateAsyncWithHttpInfo($public_ipv6 = null, string $contentType = self::contentTypes['cloudIpv6Create'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PublicIPv6';
        $request = $this->cloudIpv6CreateRequest($public_ipv6, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudIpv6Create'
     *
     * @param  \PidginHost\\Sdk\Model\PublicIPv6|null $public_ipv6 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Create'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudIpv6CreateRequest($public_ipv6 = null, string $contentType = self::contentTypes['cloudIpv6Create'][0])
    {



        $resourcePath = '/api/cloud/ipv6/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($public_ipv6)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($public_ipv6));
            } else {
                $httpBody = $public_ipv6;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudIpv6Create2
     *
     * @param  \PidginHost\\Sdk\Model\PublicIPv6|null $public_ipv6 public_ipv6 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Create2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PublicIPv6
     */
    public function cloudIpv6Create2($public_ipv6 = null, string $contentType = self::contentTypes['cloudIpv6Create2'][0])
    {
        list($response) = $this->cloudIpv6Create2WithHttpInfo($public_ipv6, $contentType);
        return $response;
    }

    /**
     * Operation cloudIpv6Create2WithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\PublicIPv6|null $public_ipv6 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Create2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PublicIPv6, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudIpv6Create2WithHttpInfo($public_ipv6 = null, string $contentType = self::contentTypes['cloudIpv6Create2'][0])
    {
        $request = $this->cloudIpv6Create2Request($public_ipv6, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\PublicIPv6' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PublicIPv6' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PublicIPv6', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PublicIPv6';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PublicIPv6',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudIpv6Create2Async
     *
     * @param  \PidginHost\\Sdk\Model\PublicIPv6|null $public_ipv6 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Create2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv6Create2Async($public_ipv6 = null, string $contentType = self::contentTypes['cloudIpv6Create2'][0])
    {
        return $this->cloudIpv6Create2AsyncWithHttpInfo($public_ipv6, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudIpv6Create2AsyncWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\PublicIPv6|null $public_ipv6 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Create2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv6Create2AsyncWithHttpInfo($public_ipv6 = null, string $contentType = self::contentTypes['cloudIpv6Create2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PublicIPv6';
        $request = $this->cloudIpv6Create2Request($public_ipv6, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudIpv6Create2'
     *
     * @param  \PidginHost\\Sdk\Model\PublicIPv6|null $public_ipv6 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Create2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudIpv6Create2Request($public_ipv6 = null, string $contentType = self::contentTypes['cloudIpv6Create2'][0])
    {



        $resourcePath = '/api/v1/cloud/ipv6/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($public_ipv6)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($public_ipv6));
            } else {
                $httpBody = $public_ipv6;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudIpv6Destroy
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Destroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cloudIpv6Destroy($id, string $contentType = self::contentTypes['cloudIpv6Destroy'][0])
    {
        $this->cloudIpv6DestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation cloudIpv6DestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Destroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudIpv6DestroyWithHttpInfo($id, string $contentType = self::contentTypes['cloudIpv6Destroy'][0])
    {
        $request = $this->cloudIpv6DestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cloudIpv6DestroyAsync
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Destroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv6DestroyAsync($id, string $contentType = self::contentTypes['cloudIpv6Destroy'][0])
    {
        return $this->cloudIpv6DestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudIpv6DestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Destroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv6DestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudIpv6Destroy'][0])
    {
        $returnType = '';
        $request = $this->cloudIpv6DestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudIpv6Destroy'
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Destroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudIpv6DestroyRequest($id, string $contentType = self::contentTypes['cloudIpv6Destroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudIpv6Destroy'
            );
        }


        $resourcePath = '/api/cloud/ipv6/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudIpv6Destroy2
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Destroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cloudIpv6Destroy2($id, string $contentType = self::contentTypes['cloudIpv6Destroy2'][0])
    {
        $this->cloudIpv6Destroy2WithHttpInfo($id, $contentType);
    }

    /**
     * Operation cloudIpv6Destroy2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Destroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudIpv6Destroy2WithHttpInfo($id, string $contentType = self::contentTypes['cloudIpv6Destroy2'][0])
    {
        $request = $this->cloudIpv6Destroy2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cloudIpv6Destroy2Async
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Destroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv6Destroy2Async($id, string $contentType = self::contentTypes['cloudIpv6Destroy2'][0])
    {
        return $this->cloudIpv6Destroy2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudIpv6Destroy2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Destroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv6Destroy2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudIpv6Destroy2'][0])
    {
        $returnType = '';
        $request = $this->cloudIpv6Destroy2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudIpv6Destroy2'
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Destroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudIpv6Destroy2Request($id, string $contentType = self::contentTypes['cloudIpv6Destroy2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudIpv6Destroy2'
            );
        }


        $resourcePath = '/api/v1/cloud/ipv6/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudIpv6DetachCreate
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  \PidginHost\\Sdk\Model\PublicIPv6|null $public_ipv6 public_ipv6 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6DetachCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\DetachIPv6Response
     */
    public function cloudIpv6DetachCreate($id, $public_ipv6 = null, string $contentType = self::contentTypes['cloudIpv6DetachCreate'][0])
    {
        list($response) = $this->cloudIpv6DetachCreateWithHttpInfo($id, $public_ipv6, $contentType);
        return $response;
    }

    /**
     * Operation cloudIpv6DetachCreateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  \PidginHost\\Sdk\Model\PublicIPv6|null $public_ipv6 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6DetachCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\DetachIPv6Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudIpv6DetachCreateWithHttpInfo($id, $public_ipv6 = null, string $contentType = self::contentTypes['cloudIpv6DetachCreate'][0])
    {
        $request = $this->cloudIpv6DetachCreateRequest($id, $public_ipv6, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\DetachIPv6Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\DetachIPv6Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\DetachIPv6Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\DetachIPv6Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\DetachIPv6Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudIpv6DetachCreateAsync
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  \PidginHost\\Sdk\Model\PublicIPv6|null $public_ipv6 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6DetachCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv6DetachCreateAsync($id, $public_ipv6 = null, string $contentType = self::contentTypes['cloudIpv6DetachCreate'][0])
    {
        return $this->cloudIpv6DetachCreateAsyncWithHttpInfo($id, $public_ipv6, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudIpv6DetachCreateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  \PidginHost\\Sdk\Model\PublicIPv6|null $public_ipv6 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6DetachCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv6DetachCreateAsyncWithHttpInfo($id, $public_ipv6 = null, string $contentType = self::contentTypes['cloudIpv6DetachCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\DetachIPv6Response';
        $request = $this->cloudIpv6DetachCreateRequest($id, $public_ipv6, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudIpv6DetachCreate'
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  \PidginHost\\Sdk\Model\PublicIPv6|null $public_ipv6 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6DetachCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudIpv6DetachCreateRequest($id, $public_ipv6 = null, string $contentType = self::contentTypes['cloudIpv6DetachCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudIpv6DetachCreate'
            );
        }



        $resourcePath = '/api/cloud/ipv6/{id}/detach/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($public_ipv6)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($public_ipv6));
            } else {
                $httpBody = $public_ipv6;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudIpv6DetachCreate2
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  \PidginHost\\Sdk\Model\PublicIPv6|null $public_ipv6 public_ipv6 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6DetachCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\DetachIPv6Response
     */
    public function cloudIpv6DetachCreate2($id, $public_ipv6 = null, string $contentType = self::contentTypes['cloudIpv6DetachCreate2'][0])
    {
        list($response) = $this->cloudIpv6DetachCreate2WithHttpInfo($id, $public_ipv6, $contentType);
        return $response;
    }

    /**
     * Operation cloudIpv6DetachCreate2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  \PidginHost\\Sdk\Model\PublicIPv6|null $public_ipv6 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6DetachCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\DetachIPv6Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudIpv6DetachCreate2WithHttpInfo($id, $public_ipv6 = null, string $contentType = self::contentTypes['cloudIpv6DetachCreate2'][0])
    {
        $request = $this->cloudIpv6DetachCreate2Request($id, $public_ipv6, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\DetachIPv6Response' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\DetachIPv6Response' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\DetachIPv6Response', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\DetachIPv6Response';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\DetachIPv6Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudIpv6DetachCreate2Async
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  \PidginHost\\Sdk\Model\PublicIPv6|null $public_ipv6 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6DetachCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv6DetachCreate2Async($id, $public_ipv6 = null, string $contentType = self::contentTypes['cloudIpv6DetachCreate2'][0])
    {
        return $this->cloudIpv6DetachCreate2AsyncWithHttpInfo($id, $public_ipv6, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudIpv6DetachCreate2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  \PidginHost\\Sdk\Model\PublicIPv6|null $public_ipv6 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6DetachCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv6DetachCreate2AsyncWithHttpInfo($id, $public_ipv6 = null, string $contentType = self::contentTypes['cloudIpv6DetachCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\DetachIPv6Response';
        $request = $this->cloudIpv6DetachCreate2Request($id, $public_ipv6, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudIpv6DetachCreate2'
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  \PidginHost\\Sdk\Model\PublicIPv6|null $public_ipv6 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6DetachCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudIpv6DetachCreate2Request($id, $public_ipv6 = null, string $contentType = self::contentTypes['cloudIpv6DetachCreate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudIpv6DetachCreate2'
            );
        }



        $resourcePath = '/api/v1/cloud/ipv6/{id}/detach/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($public_ipv6)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($public_ipv6));
            } else {
                $httpBody = $public_ipv6;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudIpv6List
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6List'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedPublicIPv6List
     */
    public function cloudIpv6List($page = null, string $contentType = self::contentTypes['cloudIpv6List'][0])
    {
        list($response) = $this->cloudIpv6ListWithHttpInfo($page, $contentType);
        return $response;
    }

    /**
     * Operation cloudIpv6ListWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6List'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedPublicIPv6List, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudIpv6ListWithHttpInfo($page = null, string $contentType = self::contentTypes['cloudIpv6List'][0])
    {
        $request = $this->cloudIpv6ListRequest($page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedPublicIPv6List' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedPublicIPv6List' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedPublicIPv6List', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedPublicIPv6List';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedPublicIPv6List',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudIpv6ListAsync
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6List'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv6ListAsync($page = null, string $contentType = self::contentTypes['cloudIpv6List'][0])
    {
        return $this->cloudIpv6ListAsyncWithHttpInfo($page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudIpv6ListAsyncWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6List'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv6ListAsyncWithHttpInfo($page = null, string $contentType = self::contentTypes['cloudIpv6List'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedPublicIPv6List';
        $request = $this->cloudIpv6ListRequest($page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudIpv6List'
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6List'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudIpv6ListRequest($page = null, string $contentType = self::contentTypes['cloudIpv6List'][0])
    {



        $resourcePath = '/api/cloud/ipv6/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudIpv6List2
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6List2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedPublicIPv6List
     */
    public function cloudIpv6List2($page = null, string $contentType = self::contentTypes['cloudIpv6List2'][0])
    {
        list($response) = $this->cloudIpv6List2WithHttpInfo($page, $contentType);
        return $response;
    }

    /**
     * Operation cloudIpv6List2WithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6List2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedPublicIPv6List, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudIpv6List2WithHttpInfo($page = null, string $contentType = self::contentTypes['cloudIpv6List2'][0])
    {
        $request = $this->cloudIpv6List2Request($page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedPublicIPv6List' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedPublicIPv6List' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedPublicIPv6List', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedPublicIPv6List';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedPublicIPv6List',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudIpv6List2Async
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6List2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv6List2Async($page = null, string $contentType = self::contentTypes['cloudIpv6List2'][0])
    {
        return $this->cloudIpv6List2AsyncWithHttpInfo($page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudIpv6List2AsyncWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6List2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv6List2AsyncWithHttpInfo($page = null, string $contentType = self::contentTypes['cloudIpv6List2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedPublicIPv6List';
        $request = $this->cloudIpv6List2Request($page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudIpv6List2'
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6List2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudIpv6List2Request($page = null, string $contentType = self::contentTypes['cloudIpv6List2'][0])
    {



        $resourcePath = '/api/v1/cloud/ipv6/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudIpv6Retrieve
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Retrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PublicIPv6
     */
    public function cloudIpv6Retrieve($id, string $contentType = self::contentTypes['cloudIpv6Retrieve'][0])
    {
        list($response) = $this->cloudIpv6RetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation cloudIpv6RetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Retrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PublicIPv6, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudIpv6RetrieveWithHttpInfo($id, string $contentType = self::contentTypes['cloudIpv6Retrieve'][0])
    {
        $request = $this->cloudIpv6RetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PublicIPv6' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PublicIPv6' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PublicIPv6', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PublicIPv6';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PublicIPv6',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudIpv6RetrieveAsync
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Retrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv6RetrieveAsync($id, string $contentType = self::contentTypes['cloudIpv6Retrieve'][0])
    {
        return $this->cloudIpv6RetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudIpv6RetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Retrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv6RetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudIpv6Retrieve'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PublicIPv6';
        $request = $this->cloudIpv6RetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudIpv6Retrieve'
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Retrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudIpv6RetrieveRequest($id, string $contentType = self::contentTypes['cloudIpv6Retrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudIpv6Retrieve'
            );
        }


        $resourcePath = '/api/cloud/ipv6/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudIpv6Retrieve2
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Retrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PublicIPv6
     */
    public function cloudIpv6Retrieve2($id, string $contentType = self::contentTypes['cloudIpv6Retrieve2'][0])
    {
        list($response) = $this->cloudIpv6Retrieve2WithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation cloudIpv6Retrieve2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Retrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PublicIPv6, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudIpv6Retrieve2WithHttpInfo($id, string $contentType = self::contentTypes['cloudIpv6Retrieve2'][0])
    {
        $request = $this->cloudIpv6Retrieve2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PublicIPv6' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PublicIPv6' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PublicIPv6', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PublicIPv6';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PublicIPv6',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudIpv6Retrieve2Async
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Retrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv6Retrieve2Async($id, string $contentType = self::contentTypes['cloudIpv6Retrieve2'][0])
    {
        return $this->cloudIpv6Retrieve2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudIpv6Retrieve2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Retrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudIpv6Retrieve2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudIpv6Retrieve2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PublicIPv6';
        $request = $this->cloudIpv6Retrieve2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudIpv6Retrieve2'
     *
     * @param  int $id A unique integer value identifying this Public IPv6. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudIpv6Retrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudIpv6Retrieve2Request($id, string $contentType = self::contentTypes['cloudIpv6Retrieve2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudIpv6Retrieve2'
            );
        }


        $resourcePath = '/api/v1/cloud/ipv6/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudPrivateNetworksAddServerCreate
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetworkAddHost $private_network_add_host private_network_add_host (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksAddServerCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\AddServerResponse
     */
    public function cloudPrivateNetworksAddServerCreate($id, $private_network_add_host, string $contentType = self::contentTypes['cloudPrivateNetworksAddServerCreate'][0])
    {
        list($response) = $this->cloudPrivateNetworksAddServerCreateWithHttpInfo($id, $private_network_add_host, $contentType);
        return $response;
    }

    /**
     * Operation cloudPrivateNetworksAddServerCreateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetworkAddHost $private_network_add_host (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksAddServerCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\AddServerResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudPrivateNetworksAddServerCreateWithHttpInfo($id, $private_network_add_host, string $contentType = self::contentTypes['cloudPrivateNetworksAddServerCreate'][0])
    {
        $request = $this->cloudPrivateNetworksAddServerCreateRequest($id, $private_network_add_host, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\AddServerResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\AddServerResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\AddServerResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\AddServerResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\AddServerResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudPrivateNetworksAddServerCreateAsync
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetworkAddHost $private_network_add_host (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksAddServerCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksAddServerCreateAsync($id, $private_network_add_host, string $contentType = self::contentTypes['cloudPrivateNetworksAddServerCreate'][0])
    {
        return $this->cloudPrivateNetworksAddServerCreateAsyncWithHttpInfo($id, $private_network_add_host, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudPrivateNetworksAddServerCreateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetworkAddHost $private_network_add_host (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksAddServerCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksAddServerCreateAsyncWithHttpInfo($id, $private_network_add_host, string $contentType = self::contentTypes['cloudPrivateNetworksAddServerCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\AddServerResponse';
        $request = $this->cloudPrivateNetworksAddServerCreateRequest($id, $private_network_add_host, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudPrivateNetworksAddServerCreate'
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetworkAddHost $private_network_add_host (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksAddServerCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudPrivateNetworksAddServerCreateRequest($id, $private_network_add_host, string $contentType = self::contentTypes['cloudPrivateNetworksAddServerCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudPrivateNetworksAddServerCreate'
            );
        }

        // verify the required parameter 'private_network_add_host' is set
        if ($private_network_add_host === null || (is_array($private_network_add_host) && count($private_network_add_host) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $private_network_add_host when calling cloudPrivateNetworksAddServerCreate'
            );
        }


        $resourcePath = '/api/cloud/private-networks/{id}/add-server/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($private_network_add_host)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($private_network_add_host));
            } else {
                $httpBody = $private_network_add_host;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudPrivateNetworksAddServerCreate2
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetworkAddHost $private_network_add_host private_network_add_host (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksAddServerCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\AddServerResponse
     */
    public function cloudPrivateNetworksAddServerCreate2($id, $private_network_add_host, string $contentType = self::contentTypes['cloudPrivateNetworksAddServerCreate2'][0])
    {
        list($response) = $this->cloudPrivateNetworksAddServerCreate2WithHttpInfo($id, $private_network_add_host, $contentType);
        return $response;
    }

    /**
     * Operation cloudPrivateNetworksAddServerCreate2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetworkAddHost $private_network_add_host (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksAddServerCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\AddServerResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudPrivateNetworksAddServerCreate2WithHttpInfo($id, $private_network_add_host, string $contentType = self::contentTypes['cloudPrivateNetworksAddServerCreate2'][0])
    {
        $request = $this->cloudPrivateNetworksAddServerCreate2Request($id, $private_network_add_host, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\AddServerResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\AddServerResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\AddServerResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\AddServerResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\AddServerResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudPrivateNetworksAddServerCreate2Async
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetworkAddHost $private_network_add_host (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksAddServerCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksAddServerCreate2Async($id, $private_network_add_host, string $contentType = self::contentTypes['cloudPrivateNetworksAddServerCreate2'][0])
    {
        return $this->cloudPrivateNetworksAddServerCreate2AsyncWithHttpInfo($id, $private_network_add_host, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudPrivateNetworksAddServerCreate2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetworkAddHost $private_network_add_host (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksAddServerCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksAddServerCreate2AsyncWithHttpInfo($id, $private_network_add_host, string $contentType = self::contentTypes['cloudPrivateNetworksAddServerCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\AddServerResponse';
        $request = $this->cloudPrivateNetworksAddServerCreate2Request($id, $private_network_add_host, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudPrivateNetworksAddServerCreate2'
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetworkAddHost $private_network_add_host (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksAddServerCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudPrivateNetworksAddServerCreate2Request($id, $private_network_add_host, string $contentType = self::contentTypes['cloudPrivateNetworksAddServerCreate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudPrivateNetworksAddServerCreate2'
            );
        }

        // verify the required parameter 'private_network_add_host' is set
        if ($private_network_add_host === null || (is_array($private_network_add_host) && count($private_network_add_host) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $private_network_add_host when calling cloudPrivateNetworksAddServerCreate2'
            );
        }


        $resourcePath = '/api/v1/cloud/private-networks/{id}/add-server/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($private_network_add_host)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($private_network_add_host));
            } else {
                $httpBody = $private_network_add_host;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudPrivateNetworksCreate
     *
     * @param  \PidginHost\\Sdk\Model\PrivateNetwork $private_network private_network (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PrivateNetwork
     */
    public function cloudPrivateNetworksCreate($private_network, string $contentType = self::contentTypes['cloudPrivateNetworksCreate'][0])
    {
        list($response) = $this->cloudPrivateNetworksCreateWithHttpInfo($private_network, $contentType);
        return $response;
    }

    /**
     * Operation cloudPrivateNetworksCreateWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\PrivateNetwork $private_network (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PrivateNetwork, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudPrivateNetworksCreateWithHttpInfo($private_network, string $contentType = self::contentTypes['cloudPrivateNetworksCreate'][0])
    {
        $request = $this->cloudPrivateNetworksCreateRequest($private_network, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\PrivateNetwork' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PrivateNetwork' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PrivateNetwork', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PrivateNetwork';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PrivateNetwork',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudPrivateNetworksCreateAsync
     *
     * @param  \PidginHost\\Sdk\Model\PrivateNetwork $private_network (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksCreateAsync($private_network, string $contentType = self::contentTypes['cloudPrivateNetworksCreate'][0])
    {
        return $this->cloudPrivateNetworksCreateAsyncWithHttpInfo($private_network, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudPrivateNetworksCreateAsyncWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\PrivateNetwork $private_network (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksCreateAsyncWithHttpInfo($private_network, string $contentType = self::contentTypes['cloudPrivateNetworksCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PrivateNetwork';
        $request = $this->cloudPrivateNetworksCreateRequest($private_network, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudPrivateNetworksCreate'
     *
     * @param  \PidginHost\\Sdk\Model\PrivateNetwork $private_network (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudPrivateNetworksCreateRequest($private_network, string $contentType = self::contentTypes['cloudPrivateNetworksCreate'][0])
    {

        // verify the required parameter 'private_network' is set
        if ($private_network === null || (is_array($private_network) && count($private_network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $private_network when calling cloudPrivateNetworksCreate'
            );
        }


        $resourcePath = '/api/cloud/private-networks/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($private_network)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($private_network));
            } else {
                $httpBody = $private_network;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudPrivateNetworksCreate2
     *
     * @param  \PidginHost\\Sdk\Model\PrivateNetwork $private_network private_network (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PrivateNetwork
     */
    public function cloudPrivateNetworksCreate2($private_network, string $contentType = self::contentTypes['cloudPrivateNetworksCreate2'][0])
    {
        list($response) = $this->cloudPrivateNetworksCreate2WithHttpInfo($private_network, $contentType);
        return $response;
    }

    /**
     * Operation cloudPrivateNetworksCreate2WithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\PrivateNetwork $private_network (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PrivateNetwork, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudPrivateNetworksCreate2WithHttpInfo($private_network, string $contentType = self::contentTypes['cloudPrivateNetworksCreate2'][0])
    {
        $request = $this->cloudPrivateNetworksCreate2Request($private_network, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\PrivateNetwork' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PrivateNetwork' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PrivateNetwork', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PrivateNetwork';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PrivateNetwork',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudPrivateNetworksCreate2Async
     *
     * @param  \PidginHost\\Sdk\Model\PrivateNetwork $private_network (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksCreate2Async($private_network, string $contentType = self::contentTypes['cloudPrivateNetworksCreate2'][0])
    {
        return $this->cloudPrivateNetworksCreate2AsyncWithHttpInfo($private_network, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudPrivateNetworksCreate2AsyncWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\PrivateNetwork $private_network (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksCreate2AsyncWithHttpInfo($private_network, string $contentType = self::contentTypes['cloudPrivateNetworksCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PrivateNetwork';
        $request = $this->cloudPrivateNetworksCreate2Request($private_network, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudPrivateNetworksCreate2'
     *
     * @param  \PidginHost\\Sdk\Model\PrivateNetwork $private_network (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudPrivateNetworksCreate2Request($private_network, string $contentType = self::contentTypes['cloudPrivateNetworksCreate2'][0])
    {

        // verify the required parameter 'private_network' is set
        if ($private_network === null || (is_array($private_network) && count($private_network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $private_network when calling cloudPrivateNetworksCreate2'
            );
        }


        $resourcePath = '/api/v1/cloud/private-networks/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($private_network)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($private_network));
            } else {
                $httpBody = $private_network;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudPrivateNetworksDestroy
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cloudPrivateNetworksDestroy($id, string $contentType = self::contentTypes['cloudPrivateNetworksDestroy'][0])
    {
        $this->cloudPrivateNetworksDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation cloudPrivateNetworksDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudPrivateNetworksDestroyWithHttpInfo($id, string $contentType = self::contentTypes['cloudPrivateNetworksDestroy'][0])
    {
        $request = $this->cloudPrivateNetworksDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cloudPrivateNetworksDestroyAsync
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksDestroyAsync($id, string $contentType = self::contentTypes['cloudPrivateNetworksDestroy'][0])
    {
        return $this->cloudPrivateNetworksDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudPrivateNetworksDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudPrivateNetworksDestroy'][0])
    {
        $returnType = '';
        $request = $this->cloudPrivateNetworksDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudPrivateNetworksDestroy'
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudPrivateNetworksDestroyRequest($id, string $contentType = self::contentTypes['cloudPrivateNetworksDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudPrivateNetworksDestroy'
            );
        }


        $resourcePath = '/api/cloud/private-networks/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudPrivateNetworksDestroy2
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cloudPrivateNetworksDestroy2($id, string $contentType = self::contentTypes['cloudPrivateNetworksDestroy2'][0])
    {
        $this->cloudPrivateNetworksDestroy2WithHttpInfo($id, $contentType);
    }

    /**
     * Operation cloudPrivateNetworksDestroy2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudPrivateNetworksDestroy2WithHttpInfo($id, string $contentType = self::contentTypes['cloudPrivateNetworksDestroy2'][0])
    {
        $request = $this->cloudPrivateNetworksDestroy2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cloudPrivateNetworksDestroy2Async
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksDestroy2Async($id, string $contentType = self::contentTypes['cloudPrivateNetworksDestroy2'][0])
    {
        return $this->cloudPrivateNetworksDestroy2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudPrivateNetworksDestroy2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksDestroy2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudPrivateNetworksDestroy2'][0])
    {
        $returnType = '';
        $request = $this->cloudPrivateNetworksDestroy2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudPrivateNetworksDestroy2'
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudPrivateNetworksDestroy2Request($id, string $contentType = self::contentTypes['cloudPrivateNetworksDestroy2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudPrivateNetworksDestroy2'
            );
        }


        $resourcePath = '/api/v1/cloud/private-networks/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudPrivateNetworksList
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedPrivateNetworkList
     */
    public function cloudPrivateNetworksList($page = null, string $contentType = self::contentTypes['cloudPrivateNetworksList'][0])
    {
        list($response) = $this->cloudPrivateNetworksListWithHttpInfo($page, $contentType);
        return $response;
    }

    /**
     * Operation cloudPrivateNetworksListWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedPrivateNetworkList, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudPrivateNetworksListWithHttpInfo($page = null, string $contentType = self::contentTypes['cloudPrivateNetworksList'][0])
    {
        $request = $this->cloudPrivateNetworksListRequest($page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedPrivateNetworkList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedPrivateNetworkList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedPrivateNetworkList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedPrivateNetworkList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedPrivateNetworkList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudPrivateNetworksListAsync
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksListAsync($page = null, string $contentType = self::contentTypes['cloudPrivateNetworksList'][0])
    {
        return $this->cloudPrivateNetworksListAsyncWithHttpInfo($page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudPrivateNetworksListAsyncWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksListAsyncWithHttpInfo($page = null, string $contentType = self::contentTypes['cloudPrivateNetworksList'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedPrivateNetworkList';
        $request = $this->cloudPrivateNetworksListRequest($page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudPrivateNetworksList'
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudPrivateNetworksListRequest($page = null, string $contentType = self::contentTypes['cloudPrivateNetworksList'][0])
    {



        $resourcePath = '/api/cloud/private-networks/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudPrivateNetworksList2
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedPrivateNetworkList
     */
    public function cloudPrivateNetworksList2($page = null, string $contentType = self::contentTypes['cloudPrivateNetworksList2'][0])
    {
        list($response) = $this->cloudPrivateNetworksList2WithHttpInfo($page, $contentType);
        return $response;
    }

    /**
     * Operation cloudPrivateNetworksList2WithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedPrivateNetworkList, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudPrivateNetworksList2WithHttpInfo($page = null, string $contentType = self::contentTypes['cloudPrivateNetworksList2'][0])
    {
        $request = $this->cloudPrivateNetworksList2Request($page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedPrivateNetworkList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedPrivateNetworkList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedPrivateNetworkList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedPrivateNetworkList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedPrivateNetworkList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudPrivateNetworksList2Async
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksList2Async($page = null, string $contentType = self::contentTypes['cloudPrivateNetworksList2'][0])
    {
        return $this->cloudPrivateNetworksList2AsyncWithHttpInfo($page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudPrivateNetworksList2AsyncWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksList2AsyncWithHttpInfo($page = null, string $contentType = self::contentTypes['cloudPrivateNetworksList2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedPrivateNetworkList';
        $request = $this->cloudPrivateNetworksList2Request($page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudPrivateNetworksList2'
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudPrivateNetworksList2Request($page = null, string $contentType = self::contentTypes['cloudPrivateNetworksList2'][0])
    {



        $resourcePath = '/api/v1/cloud/private-networks/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudPrivateNetworksPartialUpdate
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedPrivateNetwork|null $patched_private_network patched_private_network (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PrivateNetwork
     */
    public function cloudPrivateNetworksPartialUpdate($id, $patched_private_network = null, string $contentType = self::contentTypes['cloudPrivateNetworksPartialUpdate'][0])
    {
        list($response) = $this->cloudPrivateNetworksPartialUpdateWithHttpInfo($id, $patched_private_network, $contentType);
        return $response;
    }

    /**
     * Operation cloudPrivateNetworksPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedPrivateNetwork|null $patched_private_network (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PrivateNetwork, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudPrivateNetworksPartialUpdateWithHttpInfo($id, $patched_private_network = null, string $contentType = self::contentTypes['cloudPrivateNetworksPartialUpdate'][0])
    {
        $request = $this->cloudPrivateNetworksPartialUpdateRequest($id, $patched_private_network, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PrivateNetwork' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PrivateNetwork' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PrivateNetwork', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PrivateNetwork';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PrivateNetwork',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudPrivateNetworksPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedPrivateNetwork|null $patched_private_network (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksPartialUpdateAsync($id, $patched_private_network = null, string $contentType = self::contentTypes['cloudPrivateNetworksPartialUpdate'][0])
    {
        return $this->cloudPrivateNetworksPartialUpdateAsyncWithHttpInfo($id, $patched_private_network, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudPrivateNetworksPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedPrivateNetwork|null $patched_private_network (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksPartialUpdateAsyncWithHttpInfo($id, $patched_private_network = null, string $contentType = self::contentTypes['cloudPrivateNetworksPartialUpdate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PrivateNetwork';
        $request = $this->cloudPrivateNetworksPartialUpdateRequest($id, $patched_private_network, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudPrivateNetworksPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedPrivateNetwork|null $patched_private_network (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudPrivateNetworksPartialUpdateRequest($id, $patched_private_network = null, string $contentType = self::contentTypes['cloudPrivateNetworksPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudPrivateNetworksPartialUpdate'
            );
        }



        $resourcePath = '/api/cloud/private-networks/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_private_network)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_private_network));
            } else {
                $httpBody = $patched_private_network;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudPrivateNetworksPartialUpdate2
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedPrivateNetwork|null $patched_private_network patched_private_network (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PrivateNetwork
     */
    public function cloudPrivateNetworksPartialUpdate2($id, $patched_private_network = null, string $contentType = self::contentTypes['cloudPrivateNetworksPartialUpdate2'][0])
    {
        list($response) = $this->cloudPrivateNetworksPartialUpdate2WithHttpInfo($id, $patched_private_network, $contentType);
        return $response;
    }

    /**
     * Operation cloudPrivateNetworksPartialUpdate2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedPrivateNetwork|null $patched_private_network (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PrivateNetwork, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudPrivateNetworksPartialUpdate2WithHttpInfo($id, $patched_private_network = null, string $contentType = self::contentTypes['cloudPrivateNetworksPartialUpdate2'][0])
    {
        $request = $this->cloudPrivateNetworksPartialUpdate2Request($id, $patched_private_network, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PrivateNetwork' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PrivateNetwork' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PrivateNetwork', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PrivateNetwork';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PrivateNetwork',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudPrivateNetworksPartialUpdate2Async
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedPrivateNetwork|null $patched_private_network (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksPartialUpdate2Async($id, $patched_private_network = null, string $contentType = self::contentTypes['cloudPrivateNetworksPartialUpdate2'][0])
    {
        return $this->cloudPrivateNetworksPartialUpdate2AsyncWithHttpInfo($id, $patched_private_network, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudPrivateNetworksPartialUpdate2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedPrivateNetwork|null $patched_private_network (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksPartialUpdate2AsyncWithHttpInfo($id, $patched_private_network = null, string $contentType = self::contentTypes['cloudPrivateNetworksPartialUpdate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PrivateNetwork';
        $request = $this->cloudPrivateNetworksPartialUpdate2Request($id, $patched_private_network, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudPrivateNetworksPartialUpdate2'
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedPrivateNetwork|null $patched_private_network (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudPrivateNetworksPartialUpdate2Request($id, $patched_private_network = null, string $contentType = self::contentTypes['cloudPrivateNetworksPartialUpdate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudPrivateNetworksPartialUpdate2'
            );
        }



        $resourcePath = '/api/v1/cloud/private-networks/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_private_network)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_private_network));
            } else {
                $httpBody = $patched_private_network;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudPrivateNetworksRemoveServerCreate
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetworkRemoveHost $private_network_remove_host private_network_remove_host (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksRemoveServerCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\RemoveServerResponse
     */
    public function cloudPrivateNetworksRemoveServerCreate($id, $private_network_remove_host, string $contentType = self::contentTypes['cloudPrivateNetworksRemoveServerCreate'][0])
    {
        list($response) = $this->cloudPrivateNetworksRemoveServerCreateWithHttpInfo($id, $private_network_remove_host, $contentType);
        return $response;
    }

    /**
     * Operation cloudPrivateNetworksRemoveServerCreateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetworkRemoveHost $private_network_remove_host (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksRemoveServerCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\RemoveServerResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudPrivateNetworksRemoveServerCreateWithHttpInfo($id, $private_network_remove_host, string $contentType = self::contentTypes['cloudPrivateNetworksRemoveServerCreate'][0])
    {
        $request = $this->cloudPrivateNetworksRemoveServerCreateRequest($id, $private_network_remove_host, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\RemoveServerResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\RemoveServerResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\RemoveServerResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\RemoveServerResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\RemoveServerResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudPrivateNetworksRemoveServerCreateAsync
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetworkRemoveHost $private_network_remove_host (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksRemoveServerCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksRemoveServerCreateAsync($id, $private_network_remove_host, string $contentType = self::contentTypes['cloudPrivateNetworksRemoveServerCreate'][0])
    {
        return $this->cloudPrivateNetworksRemoveServerCreateAsyncWithHttpInfo($id, $private_network_remove_host, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudPrivateNetworksRemoveServerCreateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetworkRemoveHost $private_network_remove_host (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksRemoveServerCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksRemoveServerCreateAsyncWithHttpInfo($id, $private_network_remove_host, string $contentType = self::contentTypes['cloudPrivateNetworksRemoveServerCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\RemoveServerResponse';
        $request = $this->cloudPrivateNetworksRemoveServerCreateRequest($id, $private_network_remove_host, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudPrivateNetworksRemoveServerCreate'
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetworkRemoveHost $private_network_remove_host (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksRemoveServerCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudPrivateNetworksRemoveServerCreateRequest($id, $private_network_remove_host, string $contentType = self::contentTypes['cloudPrivateNetworksRemoveServerCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudPrivateNetworksRemoveServerCreate'
            );
        }

        // verify the required parameter 'private_network_remove_host' is set
        if ($private_network_remove_host === null || (is_array($private_network_remove_host) && count($private_network_remove_host) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $private_network_remove_host when calling cloudPrivateNetworksRemoveServerCreate'
            );
        }


        $resourcePath = '/api/cloud/private-networks/{id}/remove-server/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($private_network_remove_host)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($private_network_remove_host));
            } else {
                $httpBody = $private_network_remove_host;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudPrivateNetworksRemoveServerCreate2
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetworkRemoveHost $private_network_remove_host private_network_remove_host (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksRemoveServerCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\RemoveServerResponse
     */
    public function cloudPrivateNetworksRemoveServerCreate2($id, $private_network_remove_host, string $contentType = self::contentTypes['cloudPrivateNetworksRemoveServerCreate2'][0])
    {
        list($response) = $this->cloudPrivateNetworksRemoveServerCreate2WithHttpInfo($id, $private_network_remove_host, $contentType);
        return $response;
    }

    /**
     * Operation cloudPrivateNetworksRemoveServerCreate2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetworkRemoveHost $private_network_remove_host (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksRemoveServerCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\RemoveServerResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudPrivateNetworksRemoveServerCreate2WithHttpInfo($id, $private_network_remove_host, string $contentType = self::contentTypes['cloudPrivateNetworksRemoveServerCreate2'][0])
    {
        $request = $this->cloudPrivateNetworksRemoveServerCreate2Request($id, $private_network_remove_host, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\RemoveServerResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\RemoveServerResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\RemoveServerResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\RemoveServerResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\RemoveServerResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudPrivateNetworksRemoveServerCreate2Async
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetworkRemoveHost $private_network_remove_host (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksRemoveServerCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksRemoveServerCreate2Async($id, $private_network_remove_host, string $contentType = self::contentTypes['cloudPrivateNetworksRemoveServerCreate2'][0])
    {
        return $this->cloudPrivateNetworksRemoveServerCreate2AsyncWithHttpInfo($id, $private_network_remove_host, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudPrivateNetworksRemoveServerCreate2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetworkRemoveHost $private_network_remove_host (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksRemoveServerCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksRemoveServerCreate2AsyncWithHttpInfo($id, $private_network_remove_host, string $contentType = self::contentTypes['cloudPrivateNetworksRemoveServerCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\RemoveServerResponse';
        $request = $this->cloudPrivateNetworksRemoveServerCreate2Request($id, $private_network_remove_host, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudPrivateNetworksRemoveServerCreate2'
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetworkRemoveHost $private_network_remove_host (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksRemoveServerCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudPrivateNetworksRemoveServerCreate2Request($id, $private_network_remove_host, string $contentType = self::contentTypes['cloudPrivateNetworksRemoveServerCreate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudPrivateNetworksRemoveServerCreate2'
            );
        }

        // verify the required parameter 'private_network_remove_host' is set
        if ($private_network_remove_host === null || (is_array($private_network_remove_host) && count($private_network_remove_host) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $private_network_remove_host when calling cloudPrivateNetworksRemoveServerCreate2'
            );
        }


        $resourcePath = '/api/v1/cloud/private-networks/{id}/remove-server/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($private_network_remove_host)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($private_network_remove_host));
            } else {
                $httpBody = $private_network_remove_host;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudPrivateNetworksRetrieve
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PrivateNetwork
     */
    public function cloudPrivateNetworksRetrieve($id, string $contentType = self::contentTypes['cloudPrivateNetworksRetrieve'][0])
    {
        list($response) = $this->cloudPrivateNetworksRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation cloudPrivateNetworksRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PrivateNetwork, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudPrivateNetworksRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['cloudPrivateNetworksRetrieve'][0])
    {
        $request = $this->cloudPrivateNetworksRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PrivateNetwork' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PrivateNetwork' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PrivateNetwork', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PrivateNetwork';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PrivateNetwork',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudPrivateNetworksRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksRetrieveAsync($id, string $contentType = self::contentTypes['cloudPrivateNetworksRetrieve'][0])
    {
        return $this->cloudPrivateNetworksRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudPrivateNetworksRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudPrivateNetworksRetrieve'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PrivateNetwork';
        $request = $this->cloudPrivateNetworksRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudPrivateNetworksRetrieve'
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudPrivateNetworksRetrieveRequest($id, string $contentType = self::contentTypes['cloudPrivateNetworksRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudPrivateNetworksRetrieve'
            );
        }


        $resourcePath = '/api/cloud/private-networks/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudPrivateNetworksRetrieve2
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PrivateNetwork
     */
    public function cloudPrivateNetworksRetrieve2($id, string $contentType = self::contentTypes['cloudPrivateNetworksRetrieve2'][0])
    {
        list($response) = $this->cloudPrivateNetworksRetrieve2WithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation cloudPrivateNetworksRetrieve2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PrivateNetwork, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudPrivateNetworksRetrieve2WithHttpInfo($id, string $contentType = self::contentTypes['cloudPrivateNetworksRetrieve2'][0])
    {
        $request = $this->cloudPrivateNetworksRetrieve2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PrivateNetwork' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PrivateNetwork' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PrivateNetwork', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PrivateNetwork';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PrivateNetwork',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudPrivateNetworksRetrieve2Async
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksRetrieve2Async($id, string $contentType = self::contentTypes['cloudPrivateNetworksRetrieve2'][0])
    {
        return $this->cloudPrivateNetworksRetrieve2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudPrivateNetworksRetrieve2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksRetrieve2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudPrivateNetworksRetrieve2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PrivateNetwork';
        $request = $this->cloudPrivateNetworksRetrieve2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudPrivateNetworksRetrieve2'
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudPrivateNetworksRetrieve2Request($id, string $contentType = self::contentTypes['cloudPrivateNetworksRetrieve2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudPrivateNetworksRetrieve2'
            );
        }


        $resourcePath = '/api/v1/cloud/private-networks/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudPrivateNetworksUpdate
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetwork $private_network private_network (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PrivateNetwork
     */
    public function cloudPrivateNetworksUpdate($id, $private_network, string $contentType = self::contentTypes['cloudPrivateNetworksUpdate'][0])
    {
        list($response) = $this->cloudPrivateNetworksUpdateWithHttpInfo($id, $private_network, $contentType);
        return $response;
    }

    /**
     * Operation cloudPrivateNetworksUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetwork $private_network (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PrivateNetwork, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudPrivateNetworksUpdateWithHttpInfo($id, $private_network, string $contentType = self::contentTypes['cloudPrivateNetworksUpdate'][0])
    {
        $request = $this->cloudPrivateNetworksUpdateRequest($id, $private_network, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PrivateNetwork' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PrivateNetwork' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PrivateNetwork', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PrivateNetwork';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PrivateNetwork',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudPrivateNetworksUpdateAsync
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetwork $private_network (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksUpdateAsync($id, $private_network, string $contentType = self::contentTypes['cloudPrivateNetworksUpdate'][0])
    {
        return $this->cloudPrivateNetworksUpdateAsyncWithHttpInfo($id, $private_network, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudPrivateNetworksUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetwork $private_network (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksUpdateAsyncWithHttpInfo($id, $private_network, string $contentType = self::contentTypes['cloudPrivateNetworksUpdate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PrivateNetwork';
        $request = $this->cloudPrivateNetworksUpdateRequest($id, $private_network, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudPrivateNetworksUpdate'
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetwork $private_network (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudPrivateNetworksUpdateRequest($id, $private_network, string $contentType = self::contentTypes['cloudPrivateNetworksUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudPrivateNetworksUpdate'
            );
        }

        // verify the required parameter 'private_network' is set
        if ($private_network === null || (is_array($private_network) && count($private_network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $private_network when calling cloudPrivateNetworksUpdate'
            );
        }


        $resourcePath = '/api/cloud/private-networks/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($private_network)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($private_network));
            } else {
                $httpBody = $private_network;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudPrivateNetworksUpdate2
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetwork $private_network private_network (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PrivateNetwork
     */
    public function cloudPrivateNetworksUpdate2($id, $private_network, string $contentType = self::contentTypes['cloudPrivateNetworksUpdate2'][0])
    {
        list($response) = $this->cloudPrivateNetworksUpdate2WithHttpInfo($id, $private_network, $contentType);
        return $response;
    }

    /**
     * Operation cloudPrivateNetworksUpdate2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetwork $private_network (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PrivateNetwork, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudPrivateNetworksUpdate2WithHttpInfo($id, $private_network, string $contentType = self::contentTypes['cloudPrivateNetworksUpdate2'][0])
    {
        $request = $this->cloudPrivateNetworksUpdate2Request($id, $private_network, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PrivateNetwork' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PrivateNetwork' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PrivateNetwork', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PrivateNetwork';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PrivateNetwork',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudPrivateNetworksUpdate2Async
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetwork $private_network (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksUpdate2Async($id, $private_network, string $contentType = self::contentTypes['cloudPrivateNetworksUpdate2'][0])
    {
        return $this->cloudPrivateNetworksUpdate2AsyncWithHttpInfo($id, $private_network, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudPrivateNetworksUpdate2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetwork $private_network (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudPrivateNetworksUpdate2AsyncWithHttpInfo($id, $private_network, string $contentType = self::contentTypes['cloudPrivateNetworksUpdate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PrivateNetwork';
        $request = $this->cloudPrivateNetworksUpdate2Request($id, $private_network, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudPrivateNetworksUpdate2'
     *
     * @param  int $id A unique integer value identifying this private network. (required)
     * @param  \PidginHost\\Sdk\Model\PrivateNetwork $private_network (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudPrivateNetworksUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudPrivateNetworksUpdate2Request($id, $private_network, string $contentType = self::contentTypes['cloudPrivateNetworksUpdate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudPrivateNetworksUpdate2'
            );
        }

        // verify the required parameter 'private_network' is set
        if ($private_network === null || (is_array($private_network) && count($private_network) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $private_network when calling cloudPrivateNetworksUpdate2'
            );
        }


        $resourcePath = '/api/v1/cloud/private-networks/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($private_network)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($private_network));
            } else {
                $httpBody = $private_network;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServerPackagesList
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServerPackagesList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedServerProductList
     */
    public function cloudServerPackagesList($page = null, string $contentType = self::contentTypes['cloudServerPackagesList'][0])
    {
        list($response) = $this->cloudServerPackagesListWithHttpInfo($page, $contentType);
        return $response;
    }

    /**
     * Operation cloudServerPackagesListWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServerPackagesList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedServerProductList, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServerPackagesListWithHttpInfo($page = null, string $contentType = self::contentTypes['cloudServerPackagesList'][0])
    {
        $request = $this->cloudServerPackagesListRequest($page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedServerProductList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedServerProductList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedServerProductList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedServerProductList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedServerProductList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServerPackagesListAsync
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServerPackagesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServerPackagesListAsync($page = null, string $contentType = self::contentTypes['cloudServerPackagesList'][0])
    {
        return $this->cloudServerPackagesListAsyncWithHttpInfo($page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServerPackagesListAsyncWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServerPackagesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServerPackagesListAsyncWithHttpInfo($page = null, string $contentType = self::contentTypes['cloudServerPackagesList'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedServerProductList';
        $request = $this->cloudServerPackagesListRequest($page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServerPackagesList'
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServerPackagesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServerPackagesListRequest($page = null, string $contentType = self::contentTypes['cloudServerPackagesList'][0])
    {



        $resourcePath = '/api/cloud/server-packages/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServerPackagesList2
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServerPackagesList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedServerProductList
     */
    public function cloudServerPackagesList2($page = null, string $contentType = self::contentTypes['cloudServerPackagesList2'][0])
    {
        list($response) = $this->cloudServerPackagesList2WithHttpInfo($page, $contentType);
        return $response;
    }

    /**
     * Operation cloudServerPackagesList2WithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServerPackagesList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedServerProductList, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServerPackagesList2WithHttpInfo($page = null, string $contentType = self::contentTypes['cloudServerPackagesList2'][0])
    {
        $request = $this->cloudServerPackagesList2Request($page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedServerProductList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedServerProductList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedServerProductList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedServerProductList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedServerProductList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServerPackagesList2Async
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServerPackagesList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServerPackagesList2Async($page = null, string $contentType = self::contentTypes['cloudServerPackagesList2'][0])
    {
        return $this->cloudServerPackagesList2AsyncWithHttpInfo($page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServerPackagesList2AsyncWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServerPackagesList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServerPackagesList2AsyncWithHttpInfo($page = null, string $contentType = self::contentTypes['cloudServerPackagesList2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedServerProductList';
        $request = $this->cloudServerPackagesList2Request($page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServerPackagesList2'
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServerPackagesList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServerPackagesList2Request($page = null, string $contentType = self::contentTypes['cloudServerPackagesList2'][0])
    {



        $resourcePath = '/api/v1/cloud/server-packages/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServerPackagesRetrieve
     *
     * @param  int $id A unique integer value identifying this metered product. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServerPackagesRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ServerProduct
     */
    public function cloudServerPackagesRetrieve($id, string $contentType = self::contentTypes['cloudServerPackagesRetrieve'][0])
    {
        list($response) = $this->cloudServerPackagesRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation cloudServerPackagesRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this metered product. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServerPackagesRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ServerProduct, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServerPackagesRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['cloudServerPackagesRetrieve'][0])
    {
        $request = $this->cloudServerPackagesRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\ServerProduct' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ServerProduct' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ServerProduct', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ServerProduct';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ServerProduct',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServerPackagesRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this metered product. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServerPackagesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServerPackagesRetrieveAsync($id, string $contentType = self::contentTypes['cloudServerPackagesRetrieve'][0])
    {
        return $this->cloudServerPackagesRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServerPackagesRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this metered product. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServerPackagesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServerPackagesRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudServerPackagesRetrieve'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ServerProduct';
        $request = $this->cloudServerPackagesRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServerPackagesRetrieve'
     *
     * @param  int $id A unique integer value identifying this metered product. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServerPackagesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServerPackagesRetrieveRequest($id, string $contentType = self::contentTypes['cloudServerPackagesRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServerPackagesRetrieve'
            );
        }


        $resourcePath = '/api/cloud/server-packages/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServerPackagesRetrieve2
     *
     * @param  int $id A unique integer value identifying this metered product. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServerPackagesRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ServerProduct
     */
    public function cloudServerPackagesRetrieve2($id, string $contentType = self::contentTypes['cloudServerPackagesRetrieve2'][0])
    {
        list($response) = $this->cloudServerPackagesRetrieve2WithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation cloudServerPackagesRetrieve2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this metered product. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServerPackagesRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ServerProduct, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServerPackagesRetrieve2WithHttpInfo($id, string $contentType = self::contentTypes['cloudServerPackagesRetrieve2'][0])
    {
        $request = $this->cloudServerPackagesRetrieve2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\ServerProduct' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ServerProduct' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ServerProduct', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ServerProduct';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ServerProduct',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServerPackagesRetrieve2Async
     *
     * @param  int $id A unique integer value identifying this metered product. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServerPackagesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServerPackagesRetrieve2Async($id, string $contentType = self::contentTypes['cloudServerPackagesRetrieve2'][0])
    {
        return $this->cloudServerPackagesRetrieve2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServerPackagesRetrieve2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this metered product. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServerPackagesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServerPackagesRetrieve2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudServerPackagesRetrieve2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ServerProduct';
        $request = $this->cloudServerPackagesRetrieve2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServerPackagesRetrieve2'
     *
     * @param  int $id A unique integer value identifying this metered product. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServerPackagesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServerPackagesRetrieve2Request($id, string $contentType = self::contentTypes['cloudServerPackagesRetrieve2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServerPackagesRetrieve2'
            );
        }


        $resourcePath = '/api/v1/cloud/server-packages/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersAttachIpv4Create
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\AttachIPv4 $attach_ipv4 attach_ipv4 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersAttachIpv4Create'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\AttachIPv4
     */
    public function cloudServersAttachIpv4Create($id, $attach_ipv4, string $contentType = self::contentTypes['cloudServersAttachIpv4Create'][0])
    {
        list($response) = $this->cloudServersAttachIpv4CreateWithHttpInfo($id, $attach_ipv4, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersAttachIpv4CreateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\AttachIPv4 $attach_ipv4 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersAttachIpv4Create'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\AttachIPv4, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersAttachIpv4CreateWithHttpInfo($id, $attach_ipv4, string $contentType = self::contentTypes['cloudServersAttachIpv4Create'][0])
    {
        $request = $this->cloudServersAttachIpv4CreateRequest($id, $attach_ipv4, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\AttachIPv4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\AttachIPv4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\AttachIPv4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\AttachIPv4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\AttachIPv4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersAttachIpv4CreateAsync
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\AttachIPv4 $attach_ipv4 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersAttachIpv4Create'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersAttachIpv4CreateAsync($id, $attach_ipv4, string $contentType = self::contentTypes['cloudServersAttachIpv4Create'][0])
    {
        return $this->cloudServersAttachIpv4CreateAsyncWithHttpInfo($id, $attach_ipv4, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersAttachIpv4CreateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\AttachIPv4 $attach_ipv4 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersAttachIpv4Create'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersAttachIpv4CreateAsyncWithHttpInfo($id, $attach_ipv4, string $contentType = self::contentTypes['cloudServersAttachIpv4Create'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\AttachIPv4';
        $request = $this->cloudServersAttachIpv4CreateRequest($id, $attach_ipv4, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersAttachIpv4Create'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\AttachIPv4 $attach_ipv4 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersAttachIpv4Create'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersAttachIpv4CreateRequest($id, $attach_ipv4, string $contentType = self::contentTypes['cloudServersAttachIpv4Create'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersAttachIpv4Create'
            );
        }

        // verify the required parameter 'attach_ipv4' is set
        if ($attach_ipv4 === null || (is_array($attach_ipv4) && count($attach_ipv4) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attach_ipv4 when calling cloudServersAttachIpv4Create'
            );
        }


        $resourcePath = '/api/cloud/servers/{id}/attach-ipv4/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($attach_ipv4)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($attach_ipv4));
            } else {
                $httpBody = $attach_ipv4;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersAttachIpv4Create2
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\AttachIPv4 $attach_ipv4 attach_ipv4 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersAttachIpv4Create2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\AttachIPv4
     */
    public function cloudServersAttachIpv4Create2($id, $attach_ipv4, string $contentType = self::contentTypes['cloudServersAttachIpv4Create2'][0])
    {
        list($response) = $this->cloudServersAttachIpv4Create2WithHttpInfo($id, $attach_ipv4, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersAttachIpv4Create2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\AttachIPv4 $attach_ipv4 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersAttachIpv4Create2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\AttachIPv4, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersAttachIpv4Create2WithHttpInfo($id, $attach_ipv4, string $contentType = self::contentTypes['cloudServersAttachIpv4Create2'][0])
    {
        $request = $this->cloudServersAttachIpv4Create2Request($id, $attach_ipv4, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\AttachIPv4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\AttachIPv4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\AttachIPv4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\AttachIPv4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\AttachIPv4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersAttachIpv4Create2Async
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\AttachIPv4 $attach_ipv4 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersAttachIpv4Create2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersAttachIpv4Create2Async($id, $attach_ipv4, string $contentType = self::contentTypes['cloudServersAttachIpv4Create2'][0])
    {
        return $this->cloudServersAttachIpv4Create2AsyncWithHttpInfo($id, $attach_ipv4, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersAttachIpv4Create2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\AttachIPv4 $attach_ipv4 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersAttachIpv4Create2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersAttachIpv4Create2AsyncWithHttpInfo($id, $attach_ipv4, string $contentType = self::contentTypes['cloudServersAttachIpv4Create2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\AttachIPv4';
        $request = $this->cloudServersAttachIpv4Create2Request($id, $attach_ipv4, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersAttachIpv4Create2'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\AttachIPv4 $attach_ipv4 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersAttachIpv4Create2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersAttachIpv4Create2Request($id, $attach_ipv4, string $contentType = self::contentTypes['cloudServersAttachIpv4Create2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersAttachIpv4Create2'
            );
        }

        // verify the required parameter 'attach_ipv4' is set
        if ($attach_ipv4 === null || (is_array($attach_ipv4) && count($attach_ipv4) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attach_ipv4 when calling cloudServersAttachIpv4Create2'
            );
        }


        $resourcePath = '/api/v1/cloud/servers/{id}/attach-ipv4/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($attach_ipv4)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($attach_ipv4));
            } else {
                $httpBody = $attach_ipv4;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersAttachIpv6Create
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\AttachIPv6 $attach_ipv6 attach_ipv6 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersAttachIpv6Create'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\AttachIPv6
     */
    public function cloudServersAttachIpv6Create($id, $attach_ipv6, string $contentType = self::contentTypes['cloudServersAttachIpv6Create'][0])
    {
        list($response) = $this->cloudServersAttachIpv6CreateWithHttpInfo($id, $attach_ipv6, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersAttachIpv6CreateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\AttachIPv6 $attach_ipv6 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersAttachIpv6Create'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\AttachIPv6, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersAttachIpv6CreateWithHttpInfo($id, $attach_ipv6, string $contentType = self::contentTypes['cloudServersAttachIpv6Create'][0])
    {
        $request = $this->cloudServersAttachIpv6CreateRequest($id, $attach_ipv6, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\AttachIPv6' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\AttachIPv6' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\AttachIPv6', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\AttachIPv6';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\AttachIPv6',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersAttachIpv6CreateAsync
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\AttachIPv6 $attach_ipv6 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersAttachIpv6Create'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersAttachIpv6CreateAsync($id, $attach_ipv6, string $contentType = self::contentTypes['cloudServersAttachIpv6Create'][0])
    {
        return $this->cloudServersAttachIpv6CreateAsyncWithHttpInfo($id, $attach_ipv6, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersAttachIpv6CreateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\AttachIPv6 $attach_ipv6 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersAttachIpv6Create'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersAttachIpv6CreateAsyncWithHttpInfo($id, $attach_ipv6, string $contentType = self::contentTypes['cloudServersAttachIpv6Create'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\AttachIPv6';
        $request = $this->cloudServersAttachIpv6CreateRequest($id, $attach_ipv6, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersAttachIpv6Create'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\AttachIPv6 $attach_ipv6 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersAttachIpv6Create'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersAttachIpv6CreateRequest($id, $attach_ipv6, string $contentType = self::contentTypes['cloudServersAttachIpv6Create'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersAttachIpv6Create'
            );
        }

        // verify the required parameter 'attach_ipv6' is set
        if ($attach_ipv6 === null || (is_array($attach_ipv6) && count($attach_ipv6) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attach_ipv6 when calling cloudServersAttachIpv6Create'
            );
        }


        $resourcePath = '/api/cloud/servers/{id}/attach-ipv6/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($attach_ipv6)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($attach_ipv6));
            } else {
                $httpBody = $attach_ipv6;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersAttachIpv6Create2
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\AttachIPv6 $attach_ipv6 attach_ipv6 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersAttachIpv6Create2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\AttachIPv6
     */
    public function cloudServersAttachIpv6Create2($id, $attach_ipv6, string $contentType = self::contentTypes['cloudServersAttachIpv6Create2'][0])
    {
        list($response) = $this->cloudServersAttachIpv6Create2WithHttpInfo($id, $attach_ipv6, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersAttachIpv6Create2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\AttachIPv6 $attach_ipv6 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersAttachIpv6Create2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\AttachIPv6, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersAttachIpv6Create2WithHttpInfo($id, $attach_ipv6, string $contentType = self::contentTypes['cloudServersAttachIpv6Create2'][0])
    {
        $request = $this->cloudServersAttachIpv6Create2Request($id, $attach_ipv6, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\AttachIPv6' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\AttachIPv6' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\AttachIPv6', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\AttachIPv6';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\AttachIPv6',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersAttachIpv6Create2Async
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\AttachIPv6 $attach_ipv6 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersAttachIpv6Create2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersAttachIpv6Create2Async($id, $attach_ipv6, string $contentType = self::contentTypes['cloudServersAttachIpv6Create2'][0])
    {
        return $this->cloudServersAttachIpv6Create2AsyncWithHttpInfo($id, $attach_ipv6, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersAttachIpv6Create2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\AttachIPv6 $attach_ipv6 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersAttachIpv6Create2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersAttachIpv6Create2AsyncWithHttpInfo($id, $attach_ipv6, string $contentType = self::contentTypes['cloudServersAttachIpv6Create2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\AttachIPv6';
        $request = $this->cloudServersAttachIpv6Create2Request($id, $attach_ipv6, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersAttachIpv6Create2'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\AttachIPv6 $attach_ipv6 (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersAttachIpv6Create2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersAttachIpv6Create2Request($id, $attach_ipv6, string $contentType = self::contentTypes['cloudServersAttachIpv6Create2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersAttachIpv6Create2'
            );
        }

        // verify the required parameter 'attach_ipv6' is set
        if ($attach_ipv6 === null || (is_array($attach_ipv6) && count($attach_ipv6) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attach_ipv6 when calling cloudServersAttachIpv6Create2'
            );
        }


        $resourcePath = '/api/v1/cloud/servers/{id}/attach-ipv6/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($attach_ipv6)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($attach_ipv6));
            } else {
                $httpBody = $attach_ipv6;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersConsoleCreate
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersConsoleCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ConsoleToken
     */
    public function cloudServersConsoleCreate($id, $server = null, string $contentType = self::contentTypes['cloudServersConsoleCreate'][0])
    {
        list($response) = $this->cloudServersConsoleCreateWithHttpInfo($id, $server, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersConsoleCreateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersConsoleCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ConsoleToken, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersConsoleCreateWithHttpInfo($id, $server = null, string $contentType = self::contentTypes['cloudServersConsoleCreate'][0])
    {
        $request = $this->cloudServersConsoleCreateRequest($id, $server, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\ConsoleToken' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ConsoleToken' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ConsoleToken', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ConsoleToken';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ConsoleToken',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersConsoleCreateAsync
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersConsoleCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersConsoleCreateAsync($id, $server = null, string $contentType = self::contentTypes['cloudServersConsoleCreate'][0])
    {
        return $this->cloudServersConsoleCreateAsyncWithHttpInfo($id, $server, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersConsoleCreateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersConsoleCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersConsoleCreateAsyncWithHttpInfo($id, $server = null, string $contentType = self::contentTypes['cloudServersConsoleCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ConsoleToken';
        $request = $this->cloudServersConsoleCreateRequest($id, $server, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersConsoleCreate'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersConsoleCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersConsoleCreateRequest($id, $server = null, string $contentType = self::contentTypes['cloudServersConsoleCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersConsoleCreate'
            );
        }



        $resourcePath = '/api/cloud/servers/{id}/console/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($server)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($server));
            } else {
                $httpBody = $server;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersConsoleCreate2
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersConsoleCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ConsoleToken
     */
    public function cloudServersConsoleCreate2($id, $server = null, string $contentType = self::contentTypes['cloudServersConsoleCreate2'][0])
    {
        list($response) = $this->cloudServersConsoleCreate2WithHttpInfo($id, $server, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersConsoleCreate2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersConsoleCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ConsoleToken, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersConsoleCreate2WithHttpInfo($id, $server = null, string $contentType = self::contentTypes['cloudServersConsoleCreate2'][0])
    {
        $request = $this->cloudServersConsoleCreate2Request($id, $server, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\ConsoleToken' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ConsoleToken' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ConsoleToken', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ConsoleToken';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ConsoleToken',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersConsoleCreate2Async
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersConsoleCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersConsoleCreate2Async($id, $server = null, string $contentType = self::contentTypes['cloudServersConsoleCreate2'][0])
    {
        return $this->cloudServersConsoleCreate2AsyncWithHttpInfo($id, $server, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersConsoleCreate2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersConsoleCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersConsoleCreate2AsyncWithHttpInfo($id, $server = null, string $contentType = self::contentTypes['cloudServersConsoleCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ConsoleToken';
        $request = $this->cloudServersConsoleCreate2Request($id, $server, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersConsoleCreate2'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersConsoleCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersConsoleCreate2Request($id, $server = null, string $contentType = self::contentTypes['cloudServersConsoleCreate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersConsoleCreate2'
            );
        }



        $resourcePath = '/api/v1/cloud/servers/{id}/console/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($server)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($server));
            } else {
                $httpBody = $server;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersCreate
     *
     * @param  \PidginHost\\Sdk\Model\ServerAdd $server_add server_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ServerAddResponse
     */
    public function cloudServersCreate($server_add, string $contentType = self::contentTypes['cloudServersCreate'][0])
    {
        list($response) = $this->cloudServersCreateWithHttpInfo($server_add, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersCreateWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\ServerAdd $server_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ServerAddResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersCreateWithHttpInfo($server_add, string $contentType = self::contentTypes['cloudServersCreate'][0])
    {
        $request = $this->cloudServersCreateRequest($server_add, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\ServerAddResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ServerAddResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ServerAddResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ServerAddResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ServerAddResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersCreateAsync
     *
     * @param  \PidginHost\\Sdk\Model\ServerAdd $server_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersCreateAsync($server_add, string $contentType = self::contentTypes['cloudServersCreate'][0])
    {
        return $this->cloudServersCreateAsyncWithHttpInfo($server_add, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersCreateAsyncWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\ServerAdd $server_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersCreateAsyncWithHttpInfo($server_add, string $contentType = self::contentTypes['cloudServersCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ServerAddResponse';
        $request = $this->cloudServersCreateRequest($server_add, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersCreate'
     *
     * @param  \PidginHost\\Sdk\Model\ServerAdd $server_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersCreateRequest($server_add, string $contentType = self::contentTypes['cloudServersCreate'][0])
    {

        // verify the required parameter 'server_add' is set
        if ($server_add === null || (is_array($server_add) && count($server_add) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_add when calling cloudServersCreate'
            );
        }


        $resourcePath = '/api/cloud/servers/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($server_add)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($server_add));
            } else {
                $httpBody = $server_add;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersCreate2
     *
     * @param  \PidginHost\\Sdk\Model\ServerAdd $server_add server_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ServerAddResponse
     */
    public function cloudServersCreate2($server_add, string $contentType = self::contentTypes['cloudServersCreate2'][0])
    {
        list($response) = $this->cloudServersCreate2WithHttpInfo($server_add, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersCreate2WithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\ServerAdd $server_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ServerAddResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersCreate2WithHttpInfo($server_add, string $contentType = self::contentTypes['cloudServersCreate2'][0])
    {
        $request = $this->cloudServersCreate2Request($server_add, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\ServerAddResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ServerAddResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ServerAddResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ServerAddResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ServerAddResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersCreate2Async
     *
     * @param  \PidginHost\\Sdk\Model\ServerAdd $server_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersCreate2Async($server_add, string $contentType = self::contentTypes['cloudServersCreate2'][0])
    {
        return $this->cloudServersCreate2AsyncWithHttpInfo($server_add, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersCreate2AsyncWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\ServerAdd $server_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersCreate2AsyncWithHttpInfo($server_add, string $contentType = self::contentTypes['cloudServersCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ServerAddResponse';
        $request = $this->cloudServersCreate2Request($server_add, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersCreate2'
     *
     * @param  \PidginHost\\Sdk\Model\ServerAdd $server_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersCreate2Request($server_add, string $contentType = self::contentTypes['cloudServersCreate2'][0])
    {

        // verify the required parameter 'server_add' is set
        if ($server_add === null || (is_array($server_add) && count($server_add) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_add when calling cloudServersCreate2'
            );
        }


        $resourcePath = '/api/v1/cloud/servers/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($server_add)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($server_add));
            } else {
                $httpBody = $server_add;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersDestroy
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cloudServersDestroy($id, string $contentType = self::contentTypes['cloudServersDestroy'][0])
    {
        $this->cloudServersDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation cloudServersDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersDestroyWithHttpInfo($id, string $contentType = self::contentTypes['cloudServersDestroy'][0])
    {
        $request = $this->cloudServersDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersDestroyAsync
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersDestroyAsync($id, string $contentType = self::contentTypes['cloudServersDestroy'][0])
    {
        return $this->cloudServersDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudServersDestroy'][0])
    {
        $returnType = '';
        $request = $this->cloudServersDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersDestroy'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersDestroyRequest($id, string $contentType = self::contentTypes['cloudServersDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersDestroy'
            );
        }


        $resourcePath = '/api/cloud/servers/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersDestroy2
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cloudServersDestroy2($id, string $contentType = self::contentTypes['cloudServersDestroy2'][0])
    {
        $this->cloudServersDestroy2WithHttpInfo($id, $contentType);
    }

    /**
     * Operation cloudServersDestroy2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersDestroy2WithHttpInfo($id, string $contentType = self::contentTypes['cloudServersDestroy2'][0])
    {
        $request = $this->cloudServersDestroy2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersDestroy2Async
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersDestroy2Async($id, string $contentType = self::contentTypes['cloudServersDestroy2'][0])
    {
        return $this->cloudServersDestroy2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersDestroy2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersDestroy2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudServersDestroy2'][0])
    {
        $returnType = '';
        $request = $this->cloudServersDestroy2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersDestroy2'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersDestroy2Request($id, string $contentType = self::contentTypes['cloudServersDestroy2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersDestroy2'
            );
        }


        $resourcePath = '/api/v1/cloud/servers/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersDestroyProtectionCreate
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\DestroyProtection $destroy_protection destroy_protection (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDestroyProtectionCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\DestroyProtection
     */
    public function cloudServersDestroyProtectionCreate($id, $destroy_protection, string $contentType = self::contentTypes['cloudServersDestroyProtectionCreate'][0])
    {
        list($response) = $this->cloudServersDestroyProtectionCreateWithHttpInfo($id, $destroy_protection, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersDestroyProtectionCreateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\DestroyProtection $destroy_protection (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDestroyProtectionCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\DestroyProtection, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersDestroyProtectionCreateWithHttpInfo($id, $destroy_protection, string $contentType = self::contentTypes['cloudServersDestroyProtectionCreate'][0])
    {
        $request = $this->cloudServersDestroyProtectionCreateRequest($id, $destroy_protection, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\DestroyProtection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\DestroyProtection' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\DestroyProtection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\DestroyProtection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\DestroyProtection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersDestroyProtectionCreateAsync
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\DestroyProtection $destroy_protection (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDestroyProtectionCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersDestroyProtectionCreateAsync($id, $destroy_protection, string $contentType = self::contentTypes['cloudServersDestroyProtectionCreate'][0])
    {
        return $this->cloudServersDestroyProtectionCreateAsyncWithHttpInfo($id, $destroy_protection, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersDestroyProtectionCreateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\DestroyProtection $destroy_protection (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDestroyProtectionCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersDestroyProtectionCreateAsyncWithHttpInfo($id, $destroy_protection, string $contentType = self::contentTypes['cloudServersDestroyProtectionCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\DestroyProtection';
        $request = $this->cloudServersDestroyProtectionCreateRequest($id, $destroy_protection, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersDestroyProtectionCreate'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\DestroyProtection $destroy_protection (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDestroyProtectionCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersDestroyProtectionCreateRequest($id, $destroy_protection, string $contentType = self::contentTypes['cloudServersDestroyProtectionCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersDestroyProtectionCreate'
            );
        }

        // verify the required parameter 'destroy_protection' is set
        if ($destroy_protection === null || (is_array($destroy_protection) && count($destroy_protection) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destroy_protection when calling cloudServersDestroyProtectionCreate'
            );
        }


        $resourcePath = '/api/cloud/servers/{id}/destroy-protection/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($destroy_protection)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($destroy_protection));
            } else {
                $httpBody = $destroy_protection;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersDestroyProtectionCreate2
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\DestroyProtection $destroy_protection destroy_protection (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDestroyProtectionCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\DestroyProtection
     */
    public function cloudServersDestroyProtectionCreate2($id, $destroy_protection, string $contentType = self::contentTypes['cloudServersDestroyProtectionCreate2'][0])
    {
        list($response) = $this->cloudServersDestroyProtectionCreate2WithHttpInfo($id, $destroy_protection, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersDestroyProtectionCreate2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\DestroyProtection $destroy_protection (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDestroyProtectionCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\DestroyProtection, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersDestroyProtectionCreate2WithHttpInfo($id, $destroy_protection, string $contentType = self::contentTypes['cloudServersDestroyProtectionCreate2'][0])
    {
        $request = $this->cloudServersDestroyProtectionCreate2Request($id, $destroy_protection, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\DestroyProtection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\DestroyProtection' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\DestroyProtection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\DestroyProtection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\DestroyProtection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersDestroyProtectionCreate2Async
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\DestroyProtection $destroy_protection (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDestroyProtectionCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersDestroyProtectionCreate2Async($id, $destroy_protection, string $contentType = self::contentTypes['cloudServersDestroyProtectionCreate2'][0])
    {
        return $this->cloudServersDestroyProtectionCreate2AsyncWithHttpInfo($id, $destroy_protection, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersDestroyProtectionCreate2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\DestroyProtection $destroy_protection (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDestroyProtectionCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersDestroyProtectionCreate2AsyncWithHttpInfo($id, $destroy_protection, string $contentType = self::contentTypes['cloudServersDestroyProtectionCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\DestroyProtection';
        $request = $this->cloudServersDestroyProtectionCreate2Request($id, $destroy_protection, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersDestroyProtectionCreate2'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\DestroyProtection $destroy_protection (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDestroyProtectionCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersDestroyProtectionCreate2Request($id, $destroy_protection, string $contentType = self::contentTypes['cloudServersDestroyProtectionCreate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersDestroyProtectionCreate2'
            );
        }

        // verify the required parameter 'destroy_protection' is set
        if ($destroy_protection === null || (is_array($destroy_protection) && count($destroy_protection) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $destroy_protection when calling cloudServersDestroyProtectionCreate2'
            );
        }


        $resourcePath = '/api/v1/cloud/servers/{id}/destroy-protection/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($destroy_protection)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($destroy_protection));
            } else {
                $httpBody = $destroy_protection;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersDetachIpv4Create
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDetachIpv4Create'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\DetachIPv4
     */
    public function cloudServersDetachIpv4Create($id, $server = null, string $contentType = self::contentTypes['cloudServersDetachIpv4Create'][0])
    {
        list($response) = $this->cloudServersDetachIpv4CreateWithHttpInfo($id, $server, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersDetachIpv4CreateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDetachIpv4Create'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\DetachIPv4, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersDetachIpv4CreateWithHttpInfo($id, $server = null, string $contentType = self::contentTypes['cloudServersDetachIpv4Create'][0])
    {
        $request = $this->cloudServersDetachIpv4CreateRequest($id, $server, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\DetachIPv4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\DetachIPv4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\DetachIPv4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\DetachIPv4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\DetachIPv4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersDetachIpv4CreateAsync
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDetachIpv4Create'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersDetachIpv4CreateAsync($id, $server = null, string $contentType = self::contentTypes['cloudServersDetachIpv4Create'][0])
    {
        return $this->cloudServersDetachIpv4CreateAsyncWithHttpInfo($id, $server, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersDetachIpv4CreateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDetachIpv4Create'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersDetachIpv4CreateAsyncWithHttpInfo($id, $server = null, string $contentType = self::contentTypes['cloudServersDetachIpv4Create'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\DetachIPv4';
        $request = $this->cloudServersDetachIpv4CreateRequest($id, $server, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersDetachIpv4Create'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDetachIpv4Create'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersDetachIpv4CreateRequest($id, $server = null, string $contentType = self::contentTypes['cloudServersDetachIpv4Create'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersDetachIpv4Create'
            );
        }



        $resourcePath = '/api/cloud/servers/{id}/detach-ipv4/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($server)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($server));
            } else {
                $httpBody = $server;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersDetachIpv4Create2
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDetachIpv4Create2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\DetachIPv4
     */
    public function cloudServersDetachIpv4Create2($id, $server = null, string $contentType = self::contentTypes['cloudServersDetachIpv4Create2'][0])
    {
        list($response) = $this->cloudServersDetachIpv4Create2WithHttpInfo($id, $server, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersDetachIpv4Create2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDetachIpv4Create2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\DetachIPv4, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersDetachIpv4Create2WithHttpInfo($id, $server = null, string $contentType = self::contentTypes['cloudServersDetachIpv4Create2'][0])
    {
        $request = $this->cloudServersDetachIpv4Create2Request($id, $server, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\DetachIPv4' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\DetachIPv4' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\DetachIPv4', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\DetachIPv4';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\DetachIPv4',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersDetachIpv4Create2Async
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDetachIpv4Create2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersDetachIpv4Create2Async($id, $server = null, string $contentType = self::contentTypes['cloudServersDetachIpv4Create2'][0])
    {
        return $this->cloudServersDetachIpv4Create2AsyncWithHttpInfo($id, $server, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersDetachIpv4Create2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDetachIpv4Create2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersDetachIpv4Create2AsyncWithHttpInfo($id, $server = null, string $contentType = self::contentTypes['cloudServersDetachIpv4Create2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\DetachIPv4';
        $request = $this->cloudServersDetachIpv4Create2Request($id, $server, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersDetachIpv4Create2'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDetachIpv4Create2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersDetachIpv4Create2Request($id, $server = null, string $contentType = self::contentTypes['cloudServersDetachIpv4Create2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersDetachIpv4Create2'
            );
        }



        $resourcePath = '/api/v1/cloud/servers/{id}/detach-ipv4/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($server)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($server));
            } else {
                $httpBody = $server;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersDetachIpv6Create
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDetachIpv6Create'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\DetachIPv6
     */
    public function cloudServersDetachIpv6Create($id, $server = null, string $contentType = self::contentTypes['cloudServersDetachIpv6Create'][0])
    {
        list($response) = $this->cloudServersDetachIpv6CreateWithHttpInfo($id, $server, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersDetachIpv6CreateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDetachIpv6Create'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\DetachIPv6, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersDetachIpv6CreateWithHttpInfo($id, $server = null, string $contentType = self::contentTypes['cloudServersDetachIpv6Create'][0])
    {
        $request = $this->cloudServersDetachIpv6CreateRequest($id, $server, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\DetachIPv6' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\DetachIPv6' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\DetachIPv6', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\DetachIPv6';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\DetachIPv6',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersDetachIpv6CreateAsync
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDetachIpv6Create'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersDetachIpv6CreateAsync($id, $server = null, string $contentType = self::contentTypes['cloudServersDetachIpv6Create'][0])
    {
        return $this->cloudServersDetachIpv6CreateAsyncWithHttpInfo($id, $server, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersDetachIpv6CreateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDetachIpv6Create'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersDetachIpv6CreateAsyncWithHttpInfo($id, $server = null, string $contentType = self::contentTypes['cloudServersDetachIpv6Create'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\DetachIPv6';
        $request = $this->cloudServersDetachIpv6CreateRequest($id, $server, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersDetachIpv6Create'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDetachIpv6Create'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersDetachIpv6CreateRequest($id, $server = null, string $contentType = self::contentTypes['cloudServersDetachIpv6Create'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersDetachIpv6Create'
            );
        }



        $resourcePath = '/api/cloud/servers/{id}/detach-ipv6/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($server)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($server));
            } else {
                $httpBody = $server;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersDetachIpv6Create2
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDetachIpv6Create2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\DetachIPv6
     */
    public function cloudServersDetachIpv6Create2($id, $server = null, string $contentType = self::contentTypes['cloudServersDetachIpv6Create2'][0])
    {
        list($response) = $this->cloudServersDetachIpv6Create2WithHttpInfo($id, $server, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersDetachIpv6Create2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDetachIpv6Create2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\DetachIPv6, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersDetachIpv6Create2WithHttpInfo($id, $server = null, string $contentType = self::contentTypes['cloudServersDetachIpv6Create2'][0])
    {
        $request = $this->cloudServersDetachIpv6Create2Request($id, $server, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\DetachIPv6' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\DetachIPv6' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\DetachIPv6', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\DetachIPv6';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\DetachIPv6',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersDetachIpv6Create2Async
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDetachIpv6Create2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersDetachIpv6Create2Async($id, $server = null, string $contentType = self::contentTypes['cloudServersDetachIpv6Create2'][0])
    {
        return $this->cloudServersDetachIpv6Create2AsyncWithHttpInfo($id, $server, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersDetachIpv6Create2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDetachIpv6Create2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersDetachIpv6Create2AsyncWithHttpInfo($id, $server = null, string $contentType = self::contentTypes['cloudServersDetachIpv6Create2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\DetachIPv6';
        $request = $this->cloudServersDetachIpv6Create2Request($id, $server, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersDetachIpv6Create2'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersDetachIpv6Create2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersDetachIpv6Create2Request($id, $server = null, string $contentType = self::contentTypes['cloudServersDetachIpv6Create2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersDetachIpv6Create2'
            );
        }



        $resourcePath = '/api/v1/cloud/servers/{id}/detach-ipv6/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($server)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($server));
            } else {
                $httpBody = $server;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersList
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedServerList
     */
    public function cloudServersList($page = null, string $contentType = self::contentTypes['cloudServersList'][0])
    {
        list($response) = $this->cloudServersListWithHttpInfo($page, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersListWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedServerList, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersListWithHttpInfo($page = null, string $contentType = self::contentTypes['cloudServersList'][0])
    {
        $request = $this->cloudServersListRequest($page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedServerList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedServerList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedServerList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedServerList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedServerList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersListAsync
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersListAsync($page = null, string $contentType = self::contentTypes['cloudServersList'][0])
    {
        return $this->cloudServersListAsyncWithHttpInfo($page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersListAsyncWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersListAsyncWithHttpInfo($page = null, string $contentType = self::contentTypes['cloudServersList'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedServerList';
        $request = $this->cloudServersListRequest($page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersList'
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersListRequest($page = null, string $contentType = self::contentTypes['cloudServersList'][0])
    {



        $resourcePath = '/api/cloud/servers/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersList2
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedServerList
     */
    public function cloudServersList2($page = null, string $contentType = self::contentTypes['cloudServersList2'][0])
    {
        list($response) = $this->cloudServersList2WithHttpInfo($page, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersList2WithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedServerList, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersList2WithHttpInfo($page = null, string $contentType = self::contentTypes['cloudServersList2'][0])
    {
        $request = $this->cloudServersList2Request($page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedServerList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedServerList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedServerList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedServerList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedServerList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersList2Async
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersList2Async($page = null, string $contentType = self::contentTypes['cloudServersList2'][0])
    {
        return $this->cloudServersList2AsyncWithHttpInfo($page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersList2AsyncWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersList2AsyncWithHttpInfo($page = null, string $contentType = self::contentTypes['cloudServersList2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedServerList';
        $request = $this->cloudServersList2Request($page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersList2'
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersList2Request($page = null, string $contentType = self::contentTypes['cloudServersList2'][0])
    {



        $resourcePath = '/api/v1/cloud/servers/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersModifyPackageCreate
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\ServerProductUpgrade $server_product_upgrade server_product_upgrade (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersModifyPackageCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ServerUpgradeResponse
     */
    public function cloudServersModifyPackageCreate($id, $server_product_upgrade, string $contentType = self::contentTypes['cloudServersModifyPackageCreate'][0])
    {
        list($response) = $this->cloudServersModifyPackageCreateWithHttpInfo($id, $server_product_upgrade, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersModifyPackageCreateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\ServerProductUpgrade $server_product_upgrade (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersModifyPackageCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ServerUpgradeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersModifyPackageCreateWithHttpInfo($id, $server_product_upgrade, string $contentType = self::contentTypes['cloudServersModifyPackageCreate'][0])
    {
        $request = $this->cloudServersModifyPackageCreateRequest($id, $server_product_upgrade, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\ServerUpgradeResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ServerUpgradeResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ServerUpgradeResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ServerUpgradeResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ServerUpgradeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersModifyPackageCreateAsync
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\ServerProductUpgrade $server_product_upgrade (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersModifyPackageCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersModifyPackageCreateAsync($id, $server_product_upgrade, string $contentType = self::contentTypes['cloudServersModifyPackageCreate'][0])
    {
        return $this->cloudServersModifyPackageCreateAsyncWithHttpInfo($id, $server_product_upgrade, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersModifyPackageCreateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\ServerProductUpgrade $server_product_upgrade (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersModifyPackageCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersModifyPackageCreateAsyncWithHttpInfo($id, $server_product_upgrade, string $contentType = self::contentTypes['cloudServersModifyPackageCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ServerUpgradeResponse';
        $request = $this->cloudServersModifyPackageCreateRequest($id, $server_product_upgrade, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersModifyPackageCreate'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\ServerProductUpgrade $server_product_upgrade (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersModifyPackageCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersModifyPackageCreateRequest($id, $server_product_upgrade, string $contentType = self::contentTypes['cloudServersModifyPackageCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersModifyPackageCreate'
            );
        }

        // verify the required parameter 'server_product_upgrade' is set
        if ($server_product_upgrade === null || (is_array($server_product_upgrade) && count($server_product_upgrade) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_product_upgrade when calling cloudServersModifyPackageCreate'
            );
        }


        $resourcePath = '/api/cloud/servers/{id}/modify-package/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($server_product_upgrade)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($server_product_upgrade));
            } else {
                $httpBody = $server_product_upgrade;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersModifyPackageCreate2
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\ServerProductUpgrade $server_product_upgrade server_product_upgrade (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersModifyPackageCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ServerUpgradeResponse
     */
    public function cloudServersModifyPackageCreate2($id, $server_product_upgrade, string $contentType = self::contentTypes['cloudServersModifyPackageCreate2'][0])
    {
        list($response) = $this->cloudServersModifyPackageCreate2WithHttpInfo($id, $server_product_upgrade, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersModifyPackageCreate2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\ServerProductUpgrade $server_product_upgrade (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersModifyPackageCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ServerUpgradeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersModifyPackageCreate2WithHttpInfo($id, $server_product_upgrade, string $contentType = self::contentTypes['cloudServersModifyPackageCreate2'][0])
    {
        $request = $this->cloudServersModifyPackageCreate2Request($id, $server_product_upgrade, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\ServerUpgradeResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ServerUpgradeResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ServerUpgradeResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ServerUpgradeResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ServerUpgradeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersModifyPackageCreate2Async
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\ServerProductUpgrade $server_product_upgrade (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersModifyPackageCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersModifyPackageCreate2Async($id, $server_product_upgrade, string $contentType = self::contentTypes['cloudServersModifyPackageCreate2'][0])
    {
        return $this->cloudServersModifyPackageCreate2AsyncWithHttpInfo($id, $server_product_upgrade, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersModifyPackageCreate2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\ServerProductUpgrade $server_product_upgrade (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersModifyPackageCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersModifyPackageCreate2AsyncWithHttpInfo($id, $server_product_upgrade, string $contentType = self::contentTypes['cloudServersModifyPackageCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ServerUpgradeResponse';
        $request = $this->cloudServersModifyPackageCreate2Request($id, $server_product_upgrade, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersModifyPackageCreate2'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\ServerProductUpgrade $server_product_upgrade (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersModifyPackageCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersModifyPackageCreate2Request($id, $server_product_upgrade, string $contentType = self::contentTypes['cloudServersModifyPackageCreate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersModifyPackageCreate2'
            );
        }

        // verify the required parameter 'server_product_upgrade' is set
        if ($server_product_upgrade === null || (is_array($server_product_upgrade) && count($server_product_upgrade) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_product_upgrade when calling cloudServersModifyPackageCreate2'
            );
        }


        $resourcePath = '/api/v1/cloud/servers/{id}/modify-package/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($server_product_upgrade)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($server_product_upgrade));
            } else {
                $httpBody = $server_product_upgrade;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersPartialUpdate
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cloudServersPartialUpdate($id, string $contentType = self::contentTypes['cloudServersPartialUpdate'][0])
    {
        $this->cloudServersPartialUpdateWithHttpInfo($id, $contentType);
    }

    /**
     * Operation cloudServersPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersPartialUpdateWithHttpInfo($id, string $contentType = self::contentTypes['cloudServersPartialUpdate'][0])
    {
        $request = $this->cloudServersPartialUpdateRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersPartialUpdateAsync($id, string $contentType = self::contentTypes['cloudServersPartialUpdate'][0])
    {
        return $this->cloudServersPartialUpdateAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersPartialUpdateAsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudServersPartialUpdate'][0])
    {
        $returnType = '';
        $request = $this->cloudServersPartialUpdateRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersPartialUpdateRequest($id, string $contentType = self::contentTypes['cloudServersPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersPartialUpdate'
            );
        }


        $resourcePath = '/api/cloud/servers/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersPartialUpdate2
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cloudServersPartialUpdate2($id, string $contentType = self::contentTypes['cloudServersPartialUpdate2'][0])
    {
        $this->cloudServersPartialUpdate2WithHttpInfo($id, $contentType);
    }

    /**
     * Operation cloudServersPartialUpdate2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersPartialUpdate2WithHttpInfo($id, string $contentType = self::contentTypes['cloudServersPartialUpdate2'][0])
    {
        $request = $this->cloudServersPartialUpdate2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersPartialUpdate2Async
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersPartialUpdate2Async($id, string $contentType = self::contentTypes['cloudServersPartialUpdate2'][0])
    {
        return $this->cloudServersPartialUpdate2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersPartialUpdate2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersPartialUpdate2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudServersPartialUpdate2'][0])
    {
        $returnType = '';
        $request = $this->cloudServersPartialUpdate2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersPartialUpdate2'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersPartialUpdate2Request($id, string $contentType = self::contentTypes['cloudServersPartialUpdate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersPartialUpdate2'
            );
        }


        $resourcePath = '/api/v1/cloud/servers/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersPowerManagementCreate
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\PowerManagementRequest $power_management_request power_management_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPowerManagementCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PowerManagement
     */
    public function cloudServersPowerManagementCreate($id, $power_management_request, string $contentType = self::contentTypes['cloudServersPowerManagementCreate'][0])
    {
        list($response) = $this->cloudServersPowerManagementCreateWithHttpInfo($id, $power_management_request, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersPowerManagementCreateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\PowerManagementRequest $power_management_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPowerManagementCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PowerManagement, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersPowerManagementCreateWithHttpInfo($id, $power_management_request, string $contentType = self::contentTypes['cloudServersPowerManagementCreate'][0])
    {
        $request = $this->cloudServersPowerManagementCreateRequest($id, $power_management_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PowerManagement' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PowerManagement' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PowerManagement', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PowerManagement';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PowerManagement',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersPowerManagementCreateAsync
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\PowerManagementRequest $power_management_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPowerManagementCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersPowerManagementCreateAsync($id, $power_management_request, string $contentType = self::contentTypes['cloudServersPowerManagementCreate'][0])
    {
        return $this->cloudServersPowerManagementCreateAsyncWithHttpInfo($id, $power_management_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersPowerManagementCreateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\PowerManagementRequest $power_management_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPowerManagementCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersPowerManagementCreateAsyncWithHttpInfo($id, $power_management_request, string $contentType = self::contentTypes['cloudServersPowerManagementCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PowerManagement';
        $request = $this->cloudServersPowerManagementCreateRequest($id, $power_management_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersPowerManagementCreate'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\PowerManagementRequest $power_management_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPowerManagementCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersPowerManagementCreateRequest($id, $power_management_request, string $contentType = self::contentTypes['cloudServersPowerManagementCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersPowerManagementCreate'
            );
        }

        // verify the required parameter 'power_management_request' is set
        if ($power_management_request === null || (is_array($power_management_request) && count($power_management_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $power_management_request when calling cloudServersPowerManagementCreate'
            );
        }


        $resourcePath = '/api/cloud/servers/{id}/power-management/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($power_management_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($power_management_request));
            } else {
                $httpBody = $power_management_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersPowerManagementCreate2
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\PowerManagementRequest $power_management_request power_management_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPowerManagementCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PowerManagement
     */
    public function cloudServersPowerManagementCreate2($id, $power_management_request, string $contentType = self::contentTypes['cloudServersPowerManagementCreate2'][0])
    {
        list($response) = $this->cloudServersPowerManagementCreate2WithHttpInfo($id, $power_management_request, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersPowerManagementCreate2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\PowerManagementRequest $power_management_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPowerManagementCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PowerManagement, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersPowerManagementCreate2WithHttpInfo($id, $power_management_request, string $contentType = self::contentTypes['cloudServersPowerManagementCreate2'][0])
    {
        $request = $this->cloudServersPowerManagementCreate2Request($id, $power_management_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PowerManagement' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PowerManagement' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PowerManagement', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PowerManagement';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PowerManagement',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersPowerManagementCreate2Async
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\PowerManagementRequest $power_management_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPowerManagementCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersPowerManagementCreate2Async($id, $power_management_request, string $contentType = self::contentTypes['cloudServersPowerManagementCreate2'][0])
    {
        return $this->cloudServersPowerManagementCreate2AsyncWithHttpInfo($id, $power_management_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersPowerManagementCreate2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\PowerManagementRequest $power_management_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPowerManagementCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersPowerManagementCreate2AsyncWithHttpInfo($id, $power_management_request, string $contentType = self::contentTypes['cloudServersPowerManagementCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PowerManagement';
        $request = $this->cloudServersPowerManagementCreate2Request($id, $power_management_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersPowerManagementCreate2'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\PowerManagementRequest $power_management_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPowerManagementCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersPowerManagementCreate2Request($id, $power_management_request, string $contentType = self::contentTypes['cloudServersPowerManagementCreate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersPowerManagementCreate2'
            );
        }

        // verify the required parameter 'power_management_request' is set
        if ($power_management_request === null || (is_array($power_management_request) && count($power_management_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $power_management_request when calling cloudServersPowerManagementCreate2'
            );
        }


        $resourcePath = '/api/v1/cloud/servers/{id}/power-management/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($power_management_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($power_management_request));
            } else {
                $httpBody = $power_management_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersPowerManagementRetrieve
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPowerManagementRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PowerManagement
     */
    public function cloudServersPowerManagementRetrieve($id, string $contentType = self::contentTypes['cloudServersPowerManagementRetrieve'][0])
    {
        list($response) = $this->cloudServersPowerManagementRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersPowerManagementRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPowerManagementRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PowerManagement, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersPowerManagementRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['cloudServersPowerManagementRetrieve'][0])
    {
        $request = $this->cloudServersPowerManagementRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PowerManagement' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PowerManagement' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PowerManagement', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PowerManagement';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PowerManagement',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersPowerManagementRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPowerManagementRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersPowerManagementRetrieveAsync($id, string $contentType = self::contentTypes['cloudServersPowerManagementRetrieve'][0])
    {
        return $this->cloudServersPowerManagementRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersPowerManagementRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPowerManagementRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersPowerManagementRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudServersPowerManagementRetrieve'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PowerManagement';
        $request = $this->cloudServersPowerManagementRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersPowerManagementRetrieve'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPowerManagementRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersPowerManagementRetrieveRequest($id, string $contentType = self::contentTypes['cloudServersPowerManagementRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersPowerManagementRetrieve'
            );
        }


        $resourcePath = '/api/cloud/servers/{id}/power-management/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersPowerManagementRetrieve2
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPowerManagementRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PowerManagement
     */
    public function cloudServersPowerManagementRetrieve2($id, string $contentType = self::contentTypes['cloudServersPowerManagementRetrieve2'][0])
    {
        list($response) = $this->cloudServersPowerManagementRetrieve2WithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersPowerManagementRetrieve2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPowerManagementRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PowerManagement, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersPowerManagementRetrieve2WithHttpInfo($id, string $contentType = self::contentTypes['cloudServersPowerManagementRetrieve2'][0])
    {
        $request = $this->cloudServersPowerManagementRetrieve2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PowerManagement' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PowerManagement' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PowerManagement', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PowerManagement';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PowerManagement',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersPowerManagementRetrieve2Async
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPowerManagementRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersPowerManagementRetrieve2Async($id, string $contentType = self::contentTypes['cloudServersPowerManagementRetrieve2'][0])
    {
        return $this->cloudServersPowerManagementRetrieve2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersPowerManagementRetrieve2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPowerManagementRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersPowerManagementRetrieve2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudServersPowerManagementRetrieve2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PowerManagement';
        $request = $this->cloudServersPowerManagementRetrieve2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersPowerManagementRetrieve2'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPowerManagementRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersPowerManagementRetrieve2Request($id, string $contentType = self::contentTypes['cloudServersPowerManagementRetrieve2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersPowerManagementRetrieve2'
            );
        }


        $resourcePath = '/api/v1/cloud/servers/{id}/power-management/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersPublicInterfaceCreate
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\PublicInterface|null $public_interface public_interface (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PublicInterface
     */
    public function cloudServersPublicInterfaceCreate($id, $public_interface = null, string $contentType = self::contentTypes['cloudServersPublicInterfaceCreate'][0])
    {
        list($response) = $this->cloudServersPublicInterfaceCreateWithHttpInfo($id, $public_interface, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersPublicInterfaceCreateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\PublicInterface|null $public_interface (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PublicInterface, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersPublicInterfaceCreateWithHttpInfo($id, $public_interface = null, string $contentType = self::contentTypes['cloudServersPublicInterfaceCreate'][0])
    {
        $request = $this->cloudServersPublicInterfaceCreateRequest($id, $public_interface, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PublicInterface' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PublicInterface' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PublicInterface', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PublicInterface';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PublicInterface',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersPublicInterfaceCreateAsync
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\PublicInterface|null $public_interface (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersPublicInterfaceCreateAsync($id, $public_interface = null, string $contentType = self::contentTypes['cloudServersPublicInterfaceCreate'][0])
    {
        return $this->cloudServersPublicInterfaceCreateAsyncWithHttpInfo($id, $public_interface, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersPublicInterfaceCreateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\PublicInterface|null $public_interface (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersPublicInterfaceCreateAsyncWithHttpInfo($id, $public_interface = null, string $contentType = self::contentTypes['cloudServersPublicInterfaceCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PublicInterface';
        $request = $this->cloudServersPublicInterfaceCreateRequest($id, $public_interface, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersPublicInterfaceCreate'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\PublicInterface|null $public_interface (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersPublicInterfaceCreateRequest($id, $public_interface = null, string $contentType = self::contentTypes['cloudServersPublicInterfaceCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersPublicInterfaceCreate'
            );
        }



        $resourcePath = '/api/cloud/servers/{id}/public-interface/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($public_interface)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($public_interface));
            } else {
                $httpBody = $public_interface;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersPublicInterfaceCreate2
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\PublicInterface|null $public_interface public_interface (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PublicInterface
     */
    public function cloudServersPublicInterfaceCreate2($id, $public_interface = null, string $contentType = self::contentTypes['cloudServersPublicInterfaceCreate2'][0])
    {
        list($response) = $this->cloudServersPublicInterfaceCreate2WithHttpInfo($id, $public_interface, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersPublicInterfaceCreate2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\PublicInterface|null $public_interface (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PublicInterface, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersPublicInterfaceCreate2WithHttpInfo($id, $public_interface = null, string $contentType = self::contentTypes['cloudServersPublicInterfaceCreate2'][0])
    {
        $request = $this->cloudServersPublicInterfaceCreate2Request($id, $public_interface, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PublicInterface' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PublicInterface' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PublicInterface', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PublicInterface';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PublicInterface',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersPublicInterfaceCreate2Async
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\PublicInterface|null $public_interface (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersPublicInterfaceCreate2Async($id, $public_interface = null, string $contentType = self::contentTypes['cloudServersPublicInterfaceCreate2'][0])
    {
        return $this->cloudServersPublicInterfaceCreate2AsyncWithHttpInfo($id, $public_interface, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersPublicInterfaceCreate2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\PublicInterface|null $public_interface (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersPublicInterfaceCreate2AsyncWithHttpInfo($id, $public_interface = null, string $contentType = self::contentTypes['cloudServersPublicInterfaceCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PublicInterface';
        $request = $this->cloudServersPublicInterfaceCreate2Request($id, $public_interface, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersPublicInterfaceCreate2'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\PublicInterface|null $public_interface (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersPublicInterfaceCreate2Request($id, $public_interface = null, string $contentType = self::contentTypes['cloudServersPublicInterfaceCreate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersPublicInterfaceCreate2'
            );
        }



        $resourcePath = '/api/v1/cloud/servers/{id}/public-interface/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($public_interface)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($public_interface));
            } else {
                $httpBody = $public_interface;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersPublicInterfaceDestroy
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cloudServersPublicInterfaceDestroy($id, string $contentType = self::contentTypes['cloudServersPublicInterfaceDestroy'][0])
    {
        $this->cloudServersPublicInterfaceDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation cloudServersPublicInterfaceDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersPublicInterfaceDestroyWithHttpInfo($id, string $contentType = self::contentTypes['cloudServersPublicInterfaceDestroy'][0])
    {
        $request = $this->cloudServersPublicInterfaceDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersPublicInterfaceDestroyAsync
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersPublicInterfaceDestroyAsync($id, string $contentType = self::contentTypes['cloudServersPublicInterfaceDestroy'][0])
    {
        return $this->cloudServersPublicInterfaceDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersPublicInterfaceDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersPublicInterfaceDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudServersPublicInterfaceDestroy'][0])
    {
        $returnType = '';
        $request = $this->cloudServersPublicInterfaceDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersPublicInterfaceDestroy'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersPublicInterfaceDestroyRequest($id, string $contentType = self::contentTypes['cloudServersPublicInterfaceDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersPublicInterfaceDestroy'
            );
        }


        $resourcePath = '/api/cloud/servers/{id}/public-interface/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersPublicInterfaceDestroy2
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cloudServersPublicInterfaceDestroy2($id, string $contentType = self::contentTypes['cloudServersPublicInterfaceDestroy2'][0])
    {
        $this->cloudServersPublicInterfaceDestroy2WithHttpInfo($id, $contentType);
    }

    /**
     * Operation cloudServersPublicInterfaceDestroy2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersPublicInterfaceDestroy2WithHttpInfo($id, string $contentType = self::contentTypes['cloudServersPublicInterfaceDestroy2'][0])
    {
        $request = $this->cloudServersPublicInterfaceDestroy2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersPublicInterfaceDestroy2Async
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersPublicInterfaceDestroy2Async($id, string $contentType = self::contentTypes['cloudServersPublicInterfaceDestroy2'][0])
    {
        return $this->cloudServersPublicInterfaceDestroy2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersPublicInterfaceDestroy2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersPublicInterfaceDestroy2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudServersPublicInterfaceDestroy2'][0])
    {
        $returnType = '';
        $request = $this->cloudServersPublicInterfaceDestroy2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersPublicInterfaceDestroy2'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersPublicInterfaceDestroy2Request($id, string $contentType = self::contentTypes['cloudServersPublicInterfaceDestroy2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersPublicInterfaceDestroy2'
            );
        }


        $resourcePath = '/api/v1/cloud/servers/{id}/public-interface/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersPublicInterfaceRetrieve
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PublicInterface
     */
    public function cloudServersPublicInterfaceRetrieve($id, string $contentType = self::contentTypes['cloudServersPublicInterfaceRetrieve'][0])
    {
        list($response) = $this->cloudServersPublicInterfaceRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersPublicInterfaceRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PublicInterface, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersPublicInterfaceRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['cloudServersPublicInterfaceRetrieve'][0])
    {
        $request = $this->cloudServersPublicInterfaceRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PublicInterface' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PublicInterface' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PublicInterface', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PublicInterface';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PublicInterface',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersPublicInterfaceRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersPublicInterfaceRetrieveAsync($id, string $contentType = self::contentTypes['cloudServersPublicInterfaceRetrieve'][0])
    {
        return $this->cloudServersPublicInterfaceRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersPublicInterfaceRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersPublicInterfaceRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudServersPublicInterfaceRetrieve'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PublicInterface';
        $request = $this->cloudServersPublicInterfaceRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersPublicInterfaceRetrieve'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersPublicInterfaceRetrieveRequest($id, string $contentType = self::contentTypes['cloudServersPublicInterfaceRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersPublicInterfaceRetrieve'
            );
        }


        $resourcePath = '/api/cloud/servers/{id}/public-interface/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersPublicInterfaceRetrieve2
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PublicInterface
     */
    public function cloudServersPublicInterfaceRetrieve2($id, string $contentType = self::contentTypes['cloudServersPublicInterfaceRetrieve2'][0])
    {
        list($response) = $this->cloudServersPublicInterfaceRetrieve2WithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersPublicInterfaceRetrieve2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PublicInterface, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersPublicInterfaceRetrieve2WithHttpInfo($id, string $contentType = self::contentTypes['cloudServersPublicInterfaceRetrieve2'][0])
    {
        $request = $this->cloudServersPublicInterfaceRetrieve2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PublicInterface' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PublicInterface' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PublicInterface', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PublicInterface';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PublicInterface',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersPublicInterfaceRetrieve2Async
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersPublicInterfaceRetrieve2Async($id, string $contentType = self::contentTypes['cloudServersPublicInterfaceRetrieve2'][0])
    {
        return $this->cloudServersPublicInterfaceRetrieve2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersPublicInterfaceRetrieve2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersPublicInterfaceRetrieve2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudServersPublicInterfaceRetrieve2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PublicInterface';
        $request = $this->cloudServersPublicInterfaceRetrieve2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersPublicInterfaceRetrieve2'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersPublicInterfaceRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersPublicInterfaceRetrieve2Request($id, string $contentType = self::contentTypes['cloudServersPublicInterfaceRetrieve2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersPublicInterfaceRetrieve2'
            );
        }


        $resourcePath = '/api/v1/cloud/servers/{id}/public-interface/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersRetrieve
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cloudServersRetrieve($id, string $contentType = self::contentTypes['cloudServersRetrieve'][0])
    {
        $this->cloudServersRetrieveWithHttpInfo($id, $contentType);
    }

    /**
     * Operation cloudServersRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['cloudServersRetrieve'][0])
    {
        $request = $this->cloudServersRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersRetrieveAsync($id, string $contentType = self::contentTypes['cloudServersRetrieve'][0])
    {
        return $this->cloudServersRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudServersRetrieve'][0])
    {
        $returnType = '';
        $request = $this->cloudServersRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersRetrieve'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersRetrieveRequest($id, string $contentType = self::contentTypes['cloudServersRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersRetrieve'
            );
        }


        $resourcePath = '/api/cloud/servers/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersRetrieve2
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cloudServersRetrieve2($id, string $contentType = self::contentTypes['cloudServersRetrieve2'][0])
    {
        $this->cloudServersRetrieve2WithHttpInfo($id, $contentType);
    }

    /**
     * Operation cloudServersRetrieve2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersRetrieve2WithHttpInfo($id, string $contentType = self::contentTypes['cloudServersRetrieve2'][0])
    {
        $request = $this->cloudServersRetrieve2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersRetrieve2Async
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersRetrieve2Async($id, string $contentType = self::contentTypes['cloudServersRetrieve2'][0])
    {
        return $this->cloudServersRetrieve2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersRetrieve2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersRetrieve2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudServersRetrieve2'][0])
    {
        $returnType = '';
        $request = $this->cloudServersRetrieve2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersRetrieve2'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersRetrieve2Request($id, string $contentType = self::contentTypes['cloudServersRetrieve2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersRetrieve2'
            );
        }


        $resourcePath = '/api/v1/cloud/servers/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersRetryProvisionCreate
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersRetryProvisionCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\RetryProvision
     */
    public function cloudServersRetryProvisionCreate($id, $server = null, string $contentType = self::contentTypes['cloudServersRetryProvisionCreate'][0])
    {
        list($response) = $this->cloudServersRetryProvisionCreateWithHttpInfo($id, $server, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersRetryProvisionCreateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersRetryProvisionCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\RetryProvision, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersRetryProvisionCreateWithHttpInfo($id, $server = null, string $contentType = self::contentTypes['cloudServersRetryProvisionCreate'][0])
    {
        $request = $this->cloudServersRetryProvisionCreateRequest($id, $server, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\RetryProvision' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\RetryProvision' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\RetryProvision', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\RetryProvision';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\RetryProvision',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersRetryProvisionCreateAsync
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersRetryProvisionCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersRetryProvisionCreateAsync($id, $server = null, string $contentType = self::contentTypes['cloudServersRetryProvisionCreate'][0])
    {
        return $this->cloudServersRetryProvisionCreateAsyncWithHttpInfo($id, $server, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersRetryProvisionCreateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersRetryProvisionCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersRetryProvisionCreateAsyncWithHttpInfo($id, $server = null, string $contentType = self::contentTypes['cloudServersRetryProvisionCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\RetryProvision';
        $request = $this->cloudServersRetryProvisionCreateRequest($id, $server, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersRetryProvisionCreate'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersRetryProvisionCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersRetryProvisionCreateRequest($id, $server = null, string $contentType = self::contentTypes['cloudServersRetryProvisionCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersRetryProvisionCreate'
            );
        }



        $resourcePath = '/api/cloud/servers/{id}/retry-provision/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($server)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($server));
            } else {
                $httpBody = $server;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersRetryProvisionCreate2
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersRetryProvisionCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\RetryProvision
     */
    public function cloudServersRetryProvisionCreate2($id, $server = null, string $contentType = self::contentTypes['cloudServersRetryProvisionCreate2'][0])
    {
        list($response) = $this->cloudServersRetryProvisionCreate2WithHttpInfo($id, $server, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersRetryProvisionCreate2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersRetryProvisionCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\RetryProvision, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersRetryProvisionCreate2WithHttpInfo($id, $server = null, string $contentType = self::contentTypes['cloudServersRetryProvisionCreate2'][0])
    {
        $request = $this->cloudServersRetryProvisionCreate2Request($id, $server, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\RetryProvision' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\RetryProvision' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\RetryProvision', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\RetryProvision';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\RetryProvision',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersRetryProvisionCreate2Async
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersRetryProvisionCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersRetryProvisionCreate2Async($id, $server = null, string $contentType = self::contentTypes['cloudServersRetryProvisionCreate2'][0])
    {
        return $this->cloudServersRetryProvisionCreate2AsyncWithHttpInfo($id, $server, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersRetryProvisionCreate2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersRetryProvisionCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersRetryProvisionCreate2AsyncWithHttpInfo($id, $server = null, string $contentType = self::contentTypes['cloudServersRetryProvisionCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\RetryProvision';
        $request = $this->cloudServersRetryProvisionCreate2Request($id, $server, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersRetryProvisionCreate2'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersRetryProvisionCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersRetryProvisionCreate2Request($id, $server = null, string $contentType = self::contentTypes['cloudServersRetryProvisionCreate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersRetryProvisionCreate2'
            );
        }



        $resourcePath = '/api/v1/cloud/servers/{id}/retry-provision/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($server)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($server));
            } else {
                $httpBody = $server;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersSnapshotsCreate
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\SnapshotCreate $snapshot_create snapshot_create (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedSnapshotList|\PidginHost\\Sdk\Model\SnapshotCreateQueued
     */
    public function cloudServersSnapshotsCreate($id, $snapshot_create, $page = null, string $contentType = self::contentTypes['cloudServersSnapshotsCreate'][0])
    {
        list($response) = $this->cloudServersSnapshotsCreateWithHttpInfo($id, $snapshot_create, $page, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersSnapshotsCreateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\SnapshotCreate $snapshot_create (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedSnapshotList|\PidginHost\\Sdk\Model\SnapshotCreateQueued, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersSnapshotsCreateWithHttpInfo($id, $snapshot_create, $page = null, string $contentType = self::contentTypes['cloudServersSnapshotsCreate'][0])
    {
        $request = $this->cloudServersSnapshotsCreateRequest($id, $snapshot_create, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedSnapshotList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedSnapshotList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedSnapshotList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 202:
                    if ('\PidginHost\\Sdk\Model\SnapshotCreateQueued' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\SnapshotCreateQueued' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\SnapshotCreateQueued', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedSnapshotList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedSnapshotList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\SnapshotCreateQueued',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersSnapshotsCreateAsync
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\SnapshotCreate $snapshot_create (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersSnapshotsCreateAsync($id, $snapshot_create, $page = null, string $contentType = self::contentTypes['cloudServersSnapshotsCreate'][0])
    {
        return $this->cloudServersSnapshotsCreateAsyncWithHttpInfo($id, $snapshot_create, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersSnapshotsCreateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\SnapshotCreate $snapshot_create (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersSnapshotsCreateAsyncWithHttpInfo($id, $snapshot_create, $page = null, string $contentType = self::contentTypes['cloudServersSnapshotsCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedSnapshotList';
        $request = $this->cloudServersSnapshotsCreateRequest($id, $snapshot_create, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersSnapshotsCreate'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\SnapshotCreate $snapshot_create (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersSnapshotsCreateRequest($id, $snapshot_create, $page = null, string $contentType = self::contentTypes['cloudServersSnapshotsCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersSnapshotsCreate'
            );
        }

        // verify the required parameter 'snapshot_create' is set
        if ($snapshot_create === null || (is_array($snapshot_create) && count($snapshot_create) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $snapshot_create when calling cloudServersSnapshotsCreate'
            );
        }



        $resourcePath = '/api/cloud/servers/{id}/snapshots/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($snapshot_create)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($snapshot_create));
            } else {
                $httpBody = $snapshot_create;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersSnapshotsCreate2
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\SnapshotCreate $snapshot_create snapshot_create (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedSnapshotList|\PidginHost\\Sdk\Model\SnapshotCreateQueued
     */
    public function cloudServersSnapshotsCreate2($id, $snapshot_create, $page = null, string $contentType = self::contentTypes['cloudServersSnapshotsCreate2'][0])
    {
        list($response) = $this->cloudServersSnapshotsCreate2WithHttpInfo($id, $snapshot_create, $page, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersSnapshotsCreate2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\SnapshotCreate $snapshot_create (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedSnapshotList|\PidginHost\\Sdk\Model\SnapshotCreateQueued, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersSnapshotsCreate2WithHttpInfo($id, $snapshot_create, $page = null, string $contentType = self::contentTypes['cloudServersSnapshotsCreate2'][0])
    {
        $request = $this->cloudServersSnapshotsCreate2Request($id, $snapshot_create, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedSnapshotList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedSnapshotList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedSnapshotList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 202:
                    if ('\PidginHost\\Sdk\Model\SnapshotCreateQueued' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\SnapshotCreateQueued' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\SnapshotCreateQueued', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedSnapshotList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedSnapshotList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\SnapshotCreateQueued',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersSnapshotsCreate2Async
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\SnapshotCreate $snapshot_create (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersSnapshotsCreate2Async($id, $snapshot_create, $page = null, string $contentType = self::contentTypes['cloudServersSnapshotsCreate2'][0])
    {
        return $this->cloudServersSnapshotsCreate2AsyncWithHttpInfo($id, $snapshot_create, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersSnapshotsCreate2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\SnapshotCreate $snapshot_create (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersSnapshotsCreate2AsyncWithHttpInfo($id, $snapshot_create, $page = null, string $contentType = self::contentTypes['cloudServersSnapshotsCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedSnapshotList';
        $request = $this->cloudServersSnapshotsCreate2Request($id, $snapshot_create, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersSnapshotsCreate2'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  \PidginHost\\Sdk\Model\SnapshotCreate $snapshot_create (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersSnapshotsCreate2Request($id, $snapshot_create, $page = null, string $contentType = self::contentTypes['cloudServersSnapshotsCreate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersSnapshotsCreate2'
            );
        }

        // verify the required parameter 'snapshot_create' is set
        if ($snapshot_create === null || (is_array($snapshot_create) && count($snapshot_create) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $snapshot_create when calling cloudServersSnapshotsCreate2'
            );
        }



        $resourcePath = '/api/v1/cloud/servers/{id}/snapshots/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($snapshot_create)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($snapshot_create));
            } else {
                $httpBody = $snapshot_create;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersSnapshotsDestroy
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $snapshot_name snapshot_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\SnapshotDeleteQueued
     */
    public function cloudServersSnapshotsDestroy($id, $snapshot_name, string $contentType = self::contentTypes['cloudServersSnapshotsDestroy'][0])
    {
        list($response) = $this->cloudServersSnapshotsDestroyWithHttpInfo($id, $snapshot_name, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersSnapshotsDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $snapshot_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\SnapshotDeleteQueued, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersSnapshotsDestroyWithHttpInfo($id, $snapshot_name, string $contentType = self::contentTypes['cloudServersSnapshotsDestroy'][0])
    {
        $request = $this->cloudServersSnapshotsDestroyRequest($id, $snapshot_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    if ('\PidginHost\\Sdk\Model\SnapshotDeleteQueued' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\SnapshotDeleteQueued' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\SnapshotDeleteQueued', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\SnapshotDeleteQueued';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\SnapshotDeleteQueued',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersSnapshotsDestroyAsync
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $snapshot_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersSnapshotsDestroyAsync($id, $snapshot_name, string $contentType = self::contentTypes['cloudServersSnapshotsDestroy'][0])
    {
        return $this->cloudServersSnapshotsDestroyAsyncWithHttpInfo($id, $snapshot_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersSnapshotsDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $snapshot_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersSnapshotsDestroyAsyncWithHttpInfo($id, $snapshot_name, string $contentType = self::contentTypes['cloudServersSnapshotsDestroy'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\SnapshotDeleteQueued';
        $request = $this->cloudServersSnapshotsDestroyRequest($id, $snapshot_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersSnapshotsDestroy'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $snapshot_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersSnapshotsDestroyRequest($id, $snapshot_name, string $contentType = self::contentTypes['cloudServersSnapshotsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersSnapshotsDestroy'
            );
        }

        // verify the required parameter 'snapshot_name' is set
        if ($snapshot_name === null || (is_array($snapshot_name) && count($snapshot_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $snapshot_name when calling cloudServersSnapshotsDestroy'
            );
        }
        if (!preg_match("/^[A-Za-z0-9_.-]{1,63}$/", $snapshot_name)) {
            throw new \InvalidArgumentException("invalid value for \"snapshot_name\" when calling CloudApi.cloudServersSnapshotsDestroy, must conform to the pattern /^[A-Za-z0-9_.-]{1,63}$/.");
        }
        

        $resourcePath = '/api/cloud/servers/{id}/snapshots/{snapshot_name}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($snapshot_name !== null) {
            $resourcePath = str_replace(
                '{' . 'snapshot_name' . '}',
                ObjectSerializer::toPathValue($snapshot_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersSnapshotsDestroy2
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $snapshot_name snapshot_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\SnapshotDeleteQueued
     */
    public function cloudServersSnapshotsDestroy2($id, $snapshot_name, string $contentType = self::contentTypes['cloudServersSnapshotsDestroy2'][0])
    {
        list($response) = $this->cloudServersSnapshotsDestroy2WithHttpInfo($id, $snapshot_name, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersSnapshotsDestroy2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $snapshot_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\SnapshotDeleteQueued, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersSnapshotsDestroy2WithHttpInfo($id, $snapshot_name, string $contentType = self::contentTypes['cloudServersSnapshotsDestroy2'][0])
    {
        $request = $this->cloudServersSnapshotsDestroy2Request($id, $snapshot_name, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    if ('\PidginHost\\Sdk\Model\SnapshotDeleteQueued' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\SnapshotDeleteQueued' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\SnapshotDeleteQueued', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\SnapshotDeleteQueued';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\SnapshotDeleteQueued',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersSnapshotsDestroy2Async
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $snapshot_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersSnapshotsDestroy2Async($id, $snapshot_name, string $contentType = self::contentTypes['cloudServersSnapshotsDestroy2'][0])
    {
        return $this->cloudServersSnapshotsDestroy2AsyncWithHttpInfo($id, $snapshot_name, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersSnapshotsDestroy2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $snapshot_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersSnapshotsDestroy2AsyncWithHttpInfo($id, $snapshot_name, string $contentType = self::contentTypes['cloudServersSnapshotsDestroy2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\SnapshotDeleteQueued';
        $request = $this->cloudServersSnapshotsDestroy2Request($id, $snapshot_name, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersSnapshotsDestroy2'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $snapshot_name (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersSnapshotsDestroy2Request($id, $snapshot_name, string $contentType = self::contentTypes['cloudServersSnapshotsDestroy2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersSnapshotsDestroy2'
            );
        }

        // verify the required parameter 'snapshot_name' is set
        if ($snapshot_name === null || (is_array($snapshot_name) && count($snapshot_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $snapshot_name when calling cloudServersSnapshotsDestroy2'
            );
        }
        if (!preg_match("/^[A-Za-z0-9_.-]{1,63}$/", $snapshot_name)) {
            throw new \InvalidArgumentException("invalid value for \"snapshot_name\" when calling CloudApi.cloudServersSnapshotsDestroy2, must conform to the pattern /^[A-Za-z0-9_.-]{1,63}$/.");
        }
        

        $resourcePath = '/api/v1/cloud/servers/{id}/snapshots/{snapshot_name}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($snapshot_name !== null) {
            $resourcePath = str_replace(
                '{' . 'snapshot_name' . '}',
                ObjectSerializer::toPathValue($snapshot_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersSnapshotsList
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedSnapshotList|\PidginHost\\Sdk\Model\SnapshotCreateQueued
     */
    public function cloudServersSnapshotsList($id, $page = null, string $contentType = self::contentTypes['cloudServersSnapshotsList'][0])
    {
        list($response) = $this->cloudServersSnapshotsListWithHttpInfo($id, $page, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersSnapshotsListWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedSnapshotList|\PidginHost\\Sdk\Model\SnapshotCreateQueued, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersSnapshotsListWithHttpInfo($id, $page = null, string $contentType = self::contentTypes['cloudServersSnapshotsList'][0])
    {
        $request = $this->cloudServersSnapshotsListRequest($id, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedSnapshotList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedSnapshotList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedSnapshotList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 202:
                    if ('\PidginHost\\Sdk\Model\SnapshotCreateQueued' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\SnapshotCreateQueued' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\SnapshotCreateQueued', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedSnapshotList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedSnapshotList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\SnapshotCreateQueued',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersSnapshotsListAsync
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersSnapshotsListAsync($id, $page = null, string $contentType = self::contentTypes['cloudServersSnapshotsList'][0])
    {
        return $this->cloudServersSnapshotsListAsyncWithHttpInfo($id, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersSnapshotsListAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersSnapshotsListAsyncWithHttpInfo($id, $page = null, string $contentType = self::contentTypes['cloudServersSnapshotsList'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedSnapshotList';
        $request = $this->cloudServersSnapshotsListRequest($id, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersSnapshotsList'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersSnapshotsListRequest($id, $page = null, string $contentType = self::contentTypes['cloudServersSnapshotsList'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersSnapshotsList'
            );
        }



        $resourcePath = '/api/cloud/servers/{id}/snapshots/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersSnapshotsList2
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedSnapshotList|\PidginHost\\Sdk\Model\SnapshotCreateQueued
     */
    public function cloudServersSnapshotsList2($id, $page = null, string $contentType = self::contentTypes['cloudServersSnapshotsList2'][0])
    {
        list($response) = $this->cloudServersSnapshotsList2WithHttpInfo($id, $page, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersSnapshotsList2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedSnapshotList|\PidginHost\\Sdk\Model\SnapshotCreateQueued, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersSnapshotsList2WithHttpInfo($id, $page = null, string $contentType = self::contentTypes['cloudServersSnapshotsList2'][0])
    {
        $request = $this->cloudServersSnapshotsList2Request($id, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedSnapshotList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedSnapshotList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedSnapshotList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 202:
                    if ('\PidginHost\\Sdk\Model\SnapshotCreateQueued' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\SnapshotCreateQueued' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\SnapshotCreateQueued', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedSnapshotList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedSnapshotList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\SnapshotCreateQueued',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersSnapshotsList2Async
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersSnapshotsList2Async($id, $page = null, string $contentType = self::contentTypes['cloudServersSnapshotsList2'][0])
    {
        return $this->cloudServersSnapshotsList2AsyncWithHttpInfo($id, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersSnapshotsList2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersSnapshotsList2AsyncWithHttpInfo($id, $page = null, string $contentType = self::contentTypes['cloudServersSnapshotsList2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedSnapshotList';
        $request = $this->cloudServersSnapshotsList2Request($id, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersSnapshotsList2'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersSnapshotsList2Request($id, $page = null, string $contentType = self::contentTypes['cloudServersSnapshotsList2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersSnapshotsList2'
            );
        }



        $resourcePath = '/api/v1/cloud/servers/{id}/snapshots/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersSnapshotsRollbackCreate
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $snapshot_name snapshot_name (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsRollbackCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\SnapshotRollbackQueued
     */
    public function cloudServersSnapshotsRollbackCreate($id, $snapshot_name, $server = null, string $contentType = self::contentTypes['cloudServersSnapshotsRollbackCreate'][0])
    {
        list($response) = $this->cloudServersSnapshotsRollbackCreateWithHttpInfo($id, $snapshot_name, $server, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersSnapshotsRollbackCreateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $snapshot_name (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsRollbackCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\SnapshotRollbackQueued, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersSnapshotsRollbackCreateWithHttpInfo($id, $snapshot_name, $server = null, string $contentType = self::contentTypes['cloudServersSnapshotsRollbackCreate'][0])
    {
        $request = $this->cloudServersSnapshotsRollbackCreateRequest($id, $snapshot_name, $server, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    if ('\PidginHost\\Sdk\Model\SnapshotRollbackQueued' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\SnapshotRollbackQueued' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\SnapshotRollbackQueued', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\SnapshotRollbackQueued';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\SnapshotRollbackQueued',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersSnapshotsRollbackCreateAsync
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $snapshot_name (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsRollbackCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersSnapshotsRollbackCreateAsync($id, $snapshot_name, $server = null, string $contentType = self::contentTypes['cloudServersSnapshotsRollbackCreate'][0])
    {
        return $this->cloudServersSnapshotsRollbackCreateAsyncWithHttpInfo($id, $snapshot_name, $server, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersSnapshotsRollbackCreateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $snapshot_name (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsRollbackCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersSnapshotsRollbackCreateAsyncWithHttpInfo($id, $snapshot_name, $server = null, string $contentType = self::contentTypes['cloudServersSnapshotsRollbackCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\SnapshotRollbackQueued';
        $request = $this->cloudServersSnapshotsRollbackCreateRequest($id, $snapshot_name, $server, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersSnapshotsRollbackCreate'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $snapshot_name (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsRollbackCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersSnapshotsRollbackCreateRequest($id, $snapshot_name, $server = null, string $contentType = self::contentTypes['cloudServersSnapshotsRollbackCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersSnapshotsRollbackCreate'
            );
        }

        // verify the required parameter 'snapshot_name' is set
        if ($snapshot_name === null || (is_array($snapshot_name) && count($snapshot_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $snapshot_name when calling cloudServersSnapshotsRollbackCreate'
            );
        }
        if (!preg_match("/^[A-Za-z0-9_.-]{1,63}$/", $snapshot_name)) {
            throw new \InvalidArgumentException("invalid value for \"snapshot_name\" when calling CloudApi.cloudServersSnapshotsRollbackCreate, must conform to the pattern /^[A-Za-z0-9_.-]{1,63}$/.");
        }
        


        $resourcePath = '/api/cloud/servers/{id}/snapshots/{snapshot_name}/rollback/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($snapshot_name !== null) {
            $resourcePath = str_replace(
                '{' . 'snapshot_name' . '}',
                ObjectSerializer::toPathValue($snapshot_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($server)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($server));
            } else {
                $httpBody = $server;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersSnapshotsRollbackCreate2
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $snapshot_name snapshot_name (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsRollbackCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\SnapshotRollbackQueued
     */
    public function cloudServersSnapshotsRollbackCreate2($id, $snapshot_name, $server = null, string $contentType = self::contentTypes['cloudServersSnapshotsRollbackCreate2'][0])
    {
        list($response) = $this->cloudServersSnapshotsRollbackCreate2WithHttpInfo($id, $snapshot_name, $server, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersSnapshotsRollbackCreate2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $snapshot_name (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsRollbackCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\SnapshotRollbackQueued, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersSnapshotsRollbackCreate2WithHttpInfo($id, $snapshot_name, $server = null, string $contentType = self::contentTypes['cloudServersSnapshotsRollbackCreate2'][0])
    {
        $request = $this->cloudServersSnapshotsRollbackCreate2Request($id, $snapshot_name, $server, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    if ('\PidginHost\\Sdk\Model\SnapshotRollbackQueued' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\SnapshotRollbackQueued' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\SnapshotRollbackQueued', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\SnapshotRollbackQueued';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\SnapshotRollbackQueued',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersSnapshotsRollbackCreate2Async
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $snapshot_name (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsRollbackCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersSnapshotsRollbackCreate2Async($id, $snapshot_name, $server = null, string $contentType = self::contentTypes['cloudServersSnapshotsRollbackCreate2'][0])
    {
        return $this->cloudServersSnapshotsRollbackCreate2AsyncWithHttpInfo($id, $snapshot_name, $server, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersSnapshotsRollbackCreate2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $snapshot_name (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsRollbackCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersSnapshotsRollbackCreate2AsyncWithHttpInfo($id, $snapshot_name, $server = null, string $contentType = self::contentTypes['cloudServersSnapshotsRollbackCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\SnapshotRollbackQueued';
        $request = $this->cloudServersSnapshotsRollbackCreate2Request($id, $snapshot_name, $server, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersSnapshotsRollbackCreate2'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $snapshot_name (required)
     * @param  \PidginHost\\Sdk\Model\Server|null $server (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersSnapshotsRollbackCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersSnapshotsRollbackCreate2Request($id, $snapshot_name, $server = null, string $contentType = self::contentTypes['cloudServersSnapshotsRollbackCreate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersSnapshotsRollbackCreate2'
            );
        }

        // verify the required parameter 'snapshot_name' is set
        if ($snapshot_name === null || (is_array($snapshot_name) && count($snapshot_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $snapshot_name when calling cloudServersSnapshotsRollbackCreate2'
            );
        }
        if (!preg_match("/^[A-Za-z0-9_.-]{1,63}$/", $snapshot_name)) {
            throw new \InvalidArgumentException("invalid value for \"snapshot_name\" when calling CloudApi.cloudServersSnapshotsRollbackCreate2, must conform to the pattern /^[A-Za-z0-9_.-]{1,63}$/.");
        }
        


        $resourcePath = '/api/v1/cloud/servers/{id}/snapshots/{snapshot_name}/rollback/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($snapshot_name !== null) {
            $resourcePath = str_replace(
                '{' . 'snapshot_name' . '}',
                ObjectSerializer::toPathValue($snapshot_name),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($server)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($server));
            } else {
                $httpBody = $server;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersUpdate
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cloudServersUpdate($id, string $contentType = self::contentTypes['cloudServersUpdate'][0])
    {
        $this->cloudServersUpdateWithHttpInfo($id, $contentType);
    }

    /**
     * Operation cloudServersUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersUpdateWithHttpInfo($id, string $contentType = self::contentTypes['cloudServersUpdate'][0])
    {
        $request = $this->cloudServersUpdateRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersUpdateAsync
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersUpdateAsync($id, string $contentType = self::contentTypes['cloudServersUpdate'][0])
    {
        return $this->cloudServersUpdateAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersUpdateAsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudServersUpdate'][0])
    {
        $returnType = '';
        $request = $this->cloudServersUpdateRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersUpdate'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersUpdateRequest($id, string $contentType = self::contentTypes['cloudServersUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersUpdate'
            );
        }


        $resourcePath = '/api/cloud/servers/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersUpdate2
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cloudServersUpdate2($id, string $contentType = self::contentTypes['cloudServersUpdate2'][0])
    {
        $this->cloudServersUpdate2WithHttpInfo($id, $contentType);
    }

    /**
     * Operation cloudServersUpdate2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersUpdate2WithHttpInfo($id, string $contentType = self::contentTypes['cloudServersUpdate2'][0])
    {
        $request = $this->cloudServersUpdate2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersUpdate2Async
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersUpdate2Async($id, string $contentType = self::contentTypes['cloudServersUpdate2'][0])
    {
        return $this->cloudServersUpdate2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersUpdate2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersUpdate2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudServersUpdate2'][0])
    {
        $returnType = '';
        $request = $this->cloudServersUpdate2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersUpdate2'
     *
     * @param  int $id A unique integer value identifying this virtual machine. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersUpdate2Request($id, string $contentType = self::contentTypes['cloudServersUpdate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudServersUpdate2'
            );
        }


        $resourcePath = '/api/v1/cloud/servers/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersVolumesCreate
     *
     * @param  string $server_id server_id (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\Volume
     */
    public function cloudServersVolumesCreate($server_id, $volume, string $contentType = self::contentTypes['cloudServersVolumesCreate'][0])
    {
        list($response) = $this->cloudServersVolumesCreateWithHttpInfo($server_id, $volume, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersVolumesCreateWithHttpInfo
     *
     * @param  string $server_id (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\Volume, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersVolumesCreateWithHttpInfo($server_id, $volume, string $contentType = self::contentTypes['cloudServersVolumesCreate'][0])
    {
        $request = $this->cloudServersVolumesCreateRequest($server_id, $volume, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\Volume' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\Volume' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\Volume', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\Volume';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\Volume',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersVolumesCreateAsync
     *
     * @param  string $server_id (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersVolumesCreateAsync($server_id, $volume, string $contentType = self::contentTypes['cloudServersVolumesCreate'][0])
    {
        return $this->cloudServersVolumesCreateAsyncWithHttpInfo($server_id, $volume, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersVolumesCreateAsyncWithHttpInfo
     *
     * @param  string $server_id (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersVolumesCreateAsyncWithHttpInfo($server_id, $volume, string $contentType = self::contentTypes['cloudServersVolumesCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\Volume';
        $request = $this->cloudServersVolumesCreateRequest($server_id, $volume, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersVolumesCreate'
     *
     * @param  string $server_id (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersVolumesCreateRequest($server_id, $volume, string $contentType = self::contentTypes['cloudServersVolumesCreate'][0])
    {

        // verify the required parameter 'server_id' is set
        if ($server_id === null || (is_array($server_id) && count($server_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_id when calling cloudServersVolumesCreate'
            );
        }
        if (!preg_match("/^\\d{1,10}$/", $server_id)) {
            throw new \InvalidArgumentException("invalid value for \"server_id\" when calling CloudApi.cloudServersVolumesCreate, must conform to the pattern /^\\d{1,10}$/.");
        }
        
        // verify the required parameter 'volume' is set
        if ($volume === null || (is_array($volume) && count($volume) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $volume when calling cloudServersVolumesCreate'
            );
        }


        $resourcePath = '/api/cloud/servers/{server_id}/volumes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($server_id !== null) {
            $resourcePath = str_replace(
                '{' . 'server_id' . '}',
                ObjectSerializer::toPathValue($server_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($volume)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($volume));
            } else {
                $httpBody = $volume;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersVolumesCreate2
     *
     * @param  string $server_id server_id (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\Volume
     */
    public function cloudServersVolumesCreate2($server_id, $volume, string $contentType = self::contentTypes['cloudServersVolumesCreate2'][0])
    {
        list($response) = $this->cloudServersVolumesCreate2WithHttpInfo($server_id, $volume, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersVolumesCreate2WithHttpInfo
     *
     * @param  string $server_id (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\Volume, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersVolumesCreate2WithHttpInfo($server_id, $volume, string $contentType = self::contentTypes['cloudServersVolumesCreate2'][0])
    {
        $request = $this->cloudServersVolumesCreate2Request($server_id, $volume, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\Volume' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\Volume' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\Volume', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\Volume';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\Volume',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersVolumesCreate2Async
     *
     * @param  string $server_id (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersVolumesCreate2Async($server_id, $volume, string $contentType = self::contentTypes['cloudServersVolumesCreate2'][0])
    {
        return $this->cloudServersVolumesCreate2AsyncWithHttpInfo($server_id, $volume, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersVolumesCreate2AsyncWithHttpInfo
     *
     * @param  string $server_id (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersVolumesCreate2AsyncWithHttpInfo($server_id, $volume, string $contentType = self::contentTypes['cloudServersVolumesCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\Volume';
        $request = $this->cloudServersVolumesCreate2Request($server_id, $volume, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersVolumesCreate2'
     *
     * @param  string $server_id (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersVolumesCreate2Request($server_id, $volume, string $contentType = self::contentTypes['cloudServersVolumesCreate2'][0])
    {

        // verify the required parameter 'server_id' is set
        if ($server_id === null || (is_array($server_id) && count($server_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_id when calling cloudServersVolumesCreate2'
            );
        }
        if (!preg_match("/^\\d{1,10}$/", $server_id)) {
            throw new \InvalidArgumentException("invalid value for \"server_id\" when calling CloudApi.cloudServersVolumesCreate2, must conform to the pattern /^\\d{1,10}$/.");
        }
        
        // verify the required parameter 'volume' is set
        if ($volume === null || (is_array($volume) && count($volume) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $volume when calling cloudServersVolumesCreate2'
            );
        }


        $resourcePath = '/api/v1/cloud/servers/{server_id}/volumes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($server_id !== null) {
            $resourcePath = str_replace(
                '{' . 'server_id' . '}',
                ObjectSerializer::toPathValue($server_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($volume)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($volume));
            } else {
                $httpBody = $volume;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersVolumesDestroy
     *
     * @param  string $server_id server_id (required)
     * @param  string $volume_id volume_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cloudServersVolumesDestroy($server_id, $volume_id, string $contentType = self::contentTypes['cloudServersVolumesDestroy'][0])
    {
        $this->cloudServersVolumesDestroyWithHttpInfo($server_id, $volume_id, $contentType);
    }

    /**
     * Operation cloudServersVolumesDestroyWithHttpInfo
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersVolumesDestroyWithHttpInfo($server_id, $volume_id, string $contentType = self::contentTypes['cloudServersVolumesDestroy'][0])
    {
        $request = $this->cloudServersVolumesDestroyRequest($server_id, $volume_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersVolumesDestroyAsync
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersVolumesDestroyAsync($server_id, $volume_id, string $contentType = self::contentTypes['cloudServersVolumesDestroy'][0])
    {
        return $this->cloudServersVolumesDestroyAsyncWithHttpInfo($server_id, $volume_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersVolumesDestroyAsyncWithHttpInfo
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersVolumesDestroyAsyncWithHttpInfo($server_id, $volume_id, string $contentType = self::contentTypes['cloudServersVolumesDestroy'][0])
    {
        $returnType = '';
        $request = $this->cloudServersVolumesDestroyRequest($server_id, $volume_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersVolumesDestroy'
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersVolumesDestroyRequest($server_id, $volume_id, string $contentType = self::contentTypes['cloudServersVolumesDestroy'][0])
    {

        // verify the required parameter 'server_id' is set
        if ($server_id === null || (is_array($server_id) && count($server_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_id when calling cloudServersVolumesDestroy'
            );
        }
        if (!preg_match("/^\\d{1,10}$/", $server_id)) {
            throw new \InvalidArgumentException("invalid value for \"server_id\" when calling CloudApi.cloudServersVolumesDestroy, must conform to the pattern /^\\d{1,10}$/.");
        }
        
        // verify the required parameter 'volume_id' is set
        if ($volume_id === null || (is_array($volume_id) && count($volume_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $volume_id when calling cloudServersVolumesDestroy'
            );
        }


        $resourcePath = '/api/cloud/servers/{server_id}/volumes/{volume_id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($server_id !== null) {
            $resourcePath = str_replace(
                '{' . 'server_id' . '}',
                ObjectSerializer::toPathValue($server_id),
                $resourcePath
            );
        }
        // path params
        if ($volume_id !== null) {
            $resourcePath = str_replace(
                '{' . 'volume_id' . '}',
                ObjectSerializer::toPathValue($volume_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersVolumesDestroy2
     *
     * @param  string $server_id server_id (required)
     * @param  string $volume_id volume_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cloudServersVolumesDestroy2($server_id, $volume_id, string $contentType = self::contentTypes['cloudServersVolumesDestroy2'][0])
    {
        $this->cloudServersVolumesDestroy2WithHttpInfo($server_id, $volume_id, $contentType);
    }

    /**
     * Operation cloudServersVolumesDestroy2WithHttpInfo
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersVolumesDestroy2WithHttpInfo($server_id, $volume_id, string $contentType = self::contentTypes['cloudServersVolumesDestroy2'][0])
    {
        $request = $this->cloudServersVolumesDestroy2Request($server_id, $volume_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersVolumesDestroy2Async
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersVolumesDestroy2Async($server_id, $volume_id, string $contentType = self::contentTypes['cloudServersVolumesDestroy2'][0])
    {
        return $this->cloudServersVolumesDestroy2AsyncWithHttpInfo($server_id, $volume_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersVolumesDestroy2AsyncWithHttpInfo
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersVolumesDestroy2AsyncWithHttpInfo($server_id, $volume_id, string $contentType = self::contentTypes['cloudServersVolumesDestroy2'][0])
    {
        $returnType = '';
        $request = $this->cloudServersVolumesDestroy2Request($server_id, $volume_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersVolumesDestroy2'
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersVolumesDestroy2Request($server_id, $volume_id, string $contentType = self::contentTypes['cloudServersVolumesDestroy2'][0])
    {

        // verify the required parameter 'server_id' is set
        if ($server_id === null || (is_array($server_id) && count($server_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_id when calling cloudServersVolumesDestroy2'
            );
        }
        if (!preg_match("/^\\d{1,10}$/", $server_id)) {
            throw new \InvalidArgumentException("invalid value for \"server_id\" when calling CloudApi.cloudServersVolumesDestroy2, must conform to the pattern /^\\d{1,10}$/.");
        }
        
        // verify the required parameter 'volume_id' is set
        if ($volume_id === null || (is_array($volume_id) && count($volume_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $volume_id when calling cloudServersVolumesDestroy2'
            );
        }


        $resourcePath = '/api/v1/cloud/servers/{server_id}/volumes/{volume_id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($server_id !== null) {
            $resourcePath = str_replace(
                '{' . 'server_id' . '}',
                ObjectSerializer::toPathValue($server_id),
                $resourcePath
            );
        }
        // path params
        if ($volume_id !== null) {
            $resourcePath = str_replace(
                '{' . 'volume_id' . '}',
                ObjectSerializer::toPathValue($volume_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersVolumesList
     *
     * @param  string $server_id server_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\Volume[]
     */
    public function cloudServersVolumesList($server_id, string $contentType = self::contentTypes['cloudServersVolumesList'][0])
    {
        list($response) = $this->cloudServersVolumesListWithHttpInfo($server_id, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersVolumesListWithHttpInfo
     *
     * @param  string $server_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\Volume[], HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersVolumesListWithHttpInfo($server_id, string $contentType = self::contentTypes['cloudServersVolumesList'][0])
    {
        $request = $this->cloudServersVolumesListRequest($server_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\Volume[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\Volume[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\Volume[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\Volume[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\Volume[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersVolumesListAsync
     *
     * @param  string $server_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersVolumesListAsync($server_id, string $contentType = self::contentTypes['cloudServersVolumesList'][0])
    {
        return $this->cloudServersVolumesListAsyncWithHttpInfo($server_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersVolumesListAsyncWithHttpInfo
     *
     * @param  string $server_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersVolumesListAsyncWithHttpInfo($server_id, string $contentType = self::contentTypes['cloudServersVolumesList'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\Volume[]';
        $request = $this->cloudServersVolumesListRequest($server_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersVolumesList'
     *
     * @param  string $server_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersVolumesListRequest($server_id, string $contentType = self::contentTypes['cloudServersVolumesList'][0])
    {

        // verify the required parameter 'server_id' is set
        if ($server_id === null || (is_array($server_id) && count($server_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_id when calling cloudServersVolumesList'
            );
        }
        if (!preg_match("/^\\d{1,10}$/", $server_id)) {
            throw new \InvalidArgumentException("invalid value for \"server_id\" when calling CloudApi.cloudServersVolumesList, must conform to the pattern /^\\d{1,10}$/.");
        }
        

        $resourcePath = '/api/cloud/servers/{server_id}/volumes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($server_id !== null) {
            $resourcePath = str_replace(
                '{' . 'server_id' . '}',
                ObjectSerializer::toPathValue($server_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersVolumesList2
     *
     * @param  string $server_id server_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\Volume[]
     */
    public function cloudServersVolumesList2($server_id, string $contentType = self::contentTypes['cloudServersVolumesList2'][0])
    {
        list($response) = $this->cloudServersVolumesList2WithHttpInfo($server_id, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersVolumesList2WithHttpInfo
     *
     * @param  string $server_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\Volume[], HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersVolumesList2WithHttpInfo($server_id, string $contentType = self::contentTypes['cloudServersVolumesList2'][0])
    {
        $request = $this->cloudServersVolumesList2Request($server_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\Volume[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\Volume[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\Volume[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\Volume[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\Volume[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersVolumesList2Async
     *
     * @param  string $server_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersVolumesList2Async($server_id, string $contentType = self::contentTypes['cloudServersVolumesList2'][0])
    {
        return $this->cloudServersVolumesList2AsyncWithHttpInfo($server_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersVolumesList2AsyncWithHttpInfo
     *
     * @param  string $server_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersVolumesList2AsyncWithHttpInfo($server_id, string $contentType = self::contentTypes['cloudServersVolumesList2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\Volume[]';
        $request = $this->cloudServersVolumesList2Request($server_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersVolumesList2'
     *
     * @param  string $server_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersVolumesList2Request($server_id, string $contentType = self::contentTypes['cloudServersVolumesList2'][0])
    {

        // verify the required parameter 'server_id' is set
        if ($server_id === null || (is_array($server_id) && count($server_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_id when calling cloudServersVolumesList2'
            );
        }
        if (!preg_match("/^\\d{1,10}$/", $server_id)) {
            throw new \InvalidArgumentException("invalid value for \"server_id\" when calling CloudApi.cloudServersVolumesList2, must conform to the pattern /^\\d{1,10}$/.");
        }
        

        $resourcePath = '/api/v1/cloud/servers/{server_id}/volumes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($server_id !== null) {
            $resourcePath = str_replace(
                '{' . 'server_id' . '}',
                ObjectSerializer::toPathValue($server_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersVolumesPartialUpdate
     *
     * @param  string $server_id server_id (required)
     * @param  string $volume_id volume_id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedVolume|null $patched_volume patched_volume (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\Volume
     */
    public function cloudServersVolumesPartialUpdate($server_id, $volume_id, $patched_volume = null, string $contentType = self::contentTypes['cloudServersVolumesPartialUpdate'][0])
    {
        list($response) = $this->cloudServersVolumesPartialUpdateWithHttpInfo($server_id, $volume_id, $patched_volume, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersVolumesPartialUpdateWithHttpInfo
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedVolume|null $patched_volume (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\Volume, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersVolumesPartialUpdateWithHttpInfo($server_id, $volume_id, $patched_volume = null, string $contentType = self::contentTypes['cloudServersVolumesPartialUpdate'][0])
    {
        $request = $this->cloudServersVolumesPartialUpdateRequest($server_id, $volume_id, $patched_volume, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\Volume' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\Volume' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\Volume', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\Volume';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\Volume',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersVolumesPartialUpdateAsync
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedVolume|null $patched_volume (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersVolumesPartialUpdateAsync($server_id, $volume_id, $patched_volume = null, string $contentType = self::contentTypes['cloudServersVolumesPartialUpdate'][0])
    {
        return $this->cloudServersVolumesPartialUpdateAsyncWithHttpInfo($server_id, $volume_id, $patched_volume, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersVolumesPartialUpdateAsyncWithHttpInfo
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedVolume|null $patched_volume (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersVolumesPartialUpdateAsyncWithHttpInfo($server_id, $volume_id, $patched_volume = null, string $contentType = self::contentTypes['cloudServersVolumesPartialUpdate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\Volume';
        $request = $this->cloudServersVolumesPartialUpdateRequest($server_id, $volume_id, $patched_volume, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersVolumesPartialUpdate'
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedVolume|null $patched_volume (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersVolumesPartialUpdateRequest($server_id, $volume_id, $patched_volume = null, string $contentType = self::contentTypes['cloudServersVolumesPartialUpdate'][0])
    {

        // verify the required parameter 'server_id' is set
        if ($server_id === null || (is_array($server_id) && count($server_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_id when calling cloudServersVolumesPartialUpdate'
            );
        }
        if (!preg_match("/^\\d{1,10}$/", $server_id)) {
            throw new \InvalidArgumentException("invalid value for \"server_id\" when calling CloudApi.cloudServersVolumesPartialUpdate, must conform to the pattern /^\\d{1,10}$/.");
        }
        
        // verify the required parameter 'volume_id' is set
        if ($volume_id === null || (is_array($volume_id) && count($volume_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $volume_id when calling cloudServersVolumesPartialUpdate'
            );
        }



        $resourcePath = '/api/cloud/servers/{server_id}/volumes/{volume_id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($server_id !== null) {
            $resourcePath = str_replace(
                '{' . 'server_id' . '}',
                ObjectSerializer::toPathValue($server_id),
                $resourcePath
            );
        }
        // path params
        if ($volume_id !== null) {
            $resourcePath = str_replace(
                '{' . 'volume_id' . '}',
                ObjectSerializer::toPathValue($volume_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_volume)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_volume));
            } else {
                $httpBody = $patched_volume;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersVolumesPartialUpdate2
     *
     * @param  string $server_id server_id (required)
     * @param  string $volume_id volume_id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedVolume|null $patched_volume patched_volume (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\Volume
     */
    public function cloudServersVolumesPartialUpdate2($server_id, $volume_id, $patched_volume = null, string $contentType = self::contentTypes['cloudServersVolumesPartialUpdate2'][0])
    {
        list($response) = $this->cloudServersVolumesPartialUpdate2WithHttpInfo($server_id, $volume_id, $patched_volume, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersVolumesPartialUpdate2WithHttpInfo
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedVolume|null $patched_volume (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\Volume, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersVolumesPartialUpdate2WithHttpInfo($server_id, $volume_id, $patched_volume = null, string $contentType = self::contentTypes['cloudServersVolumesPartialUpdate2'][0])
    {
        $request = $this->cloudServersVolumesPartialUpdate2Request($server_id, $volume_id, $patched_volume, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\Volume' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\Volume' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\Volume', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\Volume';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\Volume',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersVolumesPartialUpdate2Async
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedVolume|null $patched_volume (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersVolumesPartialUpdate2Async($server_id, $volume_id, $patched_volume = null, string $contentType = self::contentTypes['cloudServersVolumesPartialUpdate2'][0])
    {
        return $this->cloudServersVolumesPartialUpdate2AsyncWithHttpInfo($server_id, $volume_id, $patched_volume, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersVolumesPartialUpdate2AsyncWithHttpInfo
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedVolume|null $patched_volume (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersVolumesPartialUpdate2AsyncWithHttpInfo($server_id, $volume_id, $patched_volume = null, string $contentType = self::contentTypes['cloudServersVolumesPartialUpdate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\Volume';
        $request = $this->cloudServersVolumesPartialUpdate2Request($server_id, $volume_id, $patched_volume, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersVolumesPartialUpdate2'
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedVolume|null $patched_volume (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersVolumesPartialUpdate2Request($server_id, $volume_id, $patched_volume = null, string $contentType = self::contentTypes['cloudServersVolumesPartialUpdate2'][0])
    {

        // verify the required parameter 'server_id' is set
        if ($server_id === null || (is_array($server_id) && count($server_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_id when calling cloudServersVolumesPartialUpdate2'
            );
        }
        if (!preg_match("/^\\d{1,10}$/", $server_id)) {
            throw new \InvalidArgumentException("invalid value for \"server_id\" when calling CloudApi.cloudServersVolumesPartialUpdate2, must conform to the pattern /^\\d{1,10}$/.");
        }
        
        // verify the required parameter 'volume_id' is set
        if ($volume_id === null || (is_array($volume_id) && count($volume_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $volume_id when calling cloudServersVolumesPartialUpdate2'
            );
        }



        $resourcePath = '/api/v1/cloud/servers/{server_id}/volumes/{volume_id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($server_id !== null) {
            $resourcePath = str_replace(
                '{' . 'server_id' . '}',
                ObjectSerializer::toPathValue($server_id),
                $resourcePath
            );
        }
        // path params
        if ($volume_id !== null) {
            $resourcePath = str_replace(
                '{' . 'volume_id' . '}',
                ObjectSerializer::toPathValue($volume_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_volume)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_volume));
            } else {
                $httpBody = $patched_volume;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersVolumesRetrieve
     *
     * @param  string $server_id server_id (required)
     * @param  string $volume_id volume_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\Volume
     */
    public function cloudServersVolumesRetrieve($server_id, $volume_id, string $contentType = self::contentTypes['cloudServersVolumesRetrieve'][0])
    {
        list($response) = $this->cloudServersVolumesRetrieveWithHttpInfo($server_id, $volume_id, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersVolumesRetrieveWithHttpInfo
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\Volume, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersVolumesRetrieveWithHttpInfo($server_id, $volume_id, string $contentType = self::contentTypes['cloudServersVolumesRetrieve'][0])
    {
        $request = $this->cloudServersVolumesRetrieveRequest($server_id, $volume_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\Volume' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\Volume' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\Volume', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\Volume';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\Volume',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersVolumesRetrieveAsync
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersVolumesRetrieveAsync($server_id, $volume_id, string $contentType = self::contentTypes['cloudServersVolumesRetrieve'][0])
    {
        return $this->cloudServersVolumesRetrieveAsyncWithHttpInfo($server_id, $volume_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersVolumesRetrieveAsyncWithHttpInfo
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersVolumesRetrieveAsyncWithHttpInfo($server_id, $volume_id, string $contentType = self::contentTypes['cloudServersVolumesRetrieve'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\Volume';
        $request = $this->cloudServersVolumesRetrieveRequest($server_id, $volume_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersVolumesRetrieve'
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersVolumesRetrieveRequest($server_id, $volume_id, string $contentType = self::contentTypes['cloudServersVolumesRetrieve'][0])
    {

        // verify the required parameter 'server_id' is set
        if ($server_id === null || (is_array($server_id) && count($server_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_id when calling cloudServersVolumesRetrieve'
            );
        }
        if (!preg_match("/^\\d{1,10}$/", $server_id)) {
            throw new \InvalidArgumentException("invalid value for \"server_id\" when calling CloudApi.cloudServersVolumesRetrieve, must conform to the pattern /^\\d{1,10}$/.");
        }
        
        // verify the required parameter 'volume_id' is set
        if ($volume_id === null || (is_array($volume_id) && count($volume_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $volume_id when calling cloudServersVolumesRetrieve'
            );
        }


        $resourcePath = '/api/cloud/servers/{server_id}/volumes/{volume_id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($server_id !== null) {
            $resourcePath = str_replace(
                '{' . 'server_id' . '}',
                ObjectSerializer::toPathValue($server_id),
                $resourcePath
            );
        }
        // path params
        if ($volume_id !== null) {
            $resourcePath = str_replace(
                '{' . 'volume_id' . '}',
                ObjectSerializer::toPathValue($volume_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersVolumesRetrieve2
     *
     * @param  string $server_id server_id (required)
     * @param  string $volume_id volume_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\Volume
     */
    public function cloudServersVolumesRetrieve2($server_id, $volume_id, string $contentType = self::contentTypes['cloudServersVolumesRetrieve2'][0])
    {
        list($response) = $this->cloudServersVolumesRetrieve2WithHttpInfo($server_id, $volume_id, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersVolumesRetrieve2WithHttpInfo
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\Volume, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersVolumesRetrieve2WithHttpInfo($server_id, $volume_id, string $contentType = self::contentTypes['cloudServersVolumesRetrieve2'][0])
    {
        $request = $this->cloudServersVolumesRetrieve2Request($server_id, $volume_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\Volume' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\Volume' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\Volume', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\Volume';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\Volume',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersVolumesRetrieve2Async
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersVolumesRetrieve2Async($server_id, $volume_id, string $contentType = self::contentTypes['cloudServersVolumesRetrieve2'][0])
    {
        return $this->cloudServersVolumesRetrieve2AsyncWithHttpInfo($server_id, $volume_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersVolumesRetrieve2AsyncWithHttpInfo
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersVolumesRetrieve2AsyncWithHttpInfo($server_id, $volume_id, string $contentType = self::contentTypes['cloudServersVolumesRetrieve2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\Volume';
        $request = $this->cloudServersVolumesRetrieve2Request($server_id, $volume_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersVolumesRetrieve2'
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersVolumesRetrieve2Request($server_id, $volume_id, string $contentType = self::contentTypes['cloudServersVolumesRetrieve2'][0])
    {

        // verify the required parameter 'server_id' is set
        if ($server_id === null || (is_array($server_id) && count($server_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_id when calling cloudServersVolumesRetrieve2'
            );
        }
        if (!preg_match("/^\\d{1,10}$/", $server_id)) {
            throw new \InvalidArgumentException("invalid value for \"server_id\" when calling CloudApi.cloudServersVolumesRetrieve2, must conform to the pattern /^\\d{1,10}$/.");
        }
        
        // verify the required parameter 'volume_id' is set
        if ($volume_id === null || (is_array($volume_id) && count($volume_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $volume_id when calling cloudServersVolumesRetrieve2'
            );
        }


        $resourcePath = '/api/v1/cloud/servers/{server_id}/volumes/{volume_id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($server_id !== null) {
            $resourcePath = str_replace(
                '{' . 'server_id' . '}',
                ObjectSerializer::toPathValue($server_id),
                $resourcePath
            );
        }
        // path params
        if ($volume_id !== null) {
            $resourcePath = str_replace(
                '{' . 'volume_id' . '}',
                ObjectSerializer::toPathValue($volume_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersVolumesUpdate
     *
     * @param  string $server_id server_id (required)
     * @param  string $volume_id volume_id (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\Volume
     */
    public function cloudServersVolumesUpdate($server_id, $volume_id, $volume, string $contentType = self::contentTypes['cloudServersVolumesUpdate'][0])
    {
        list($response) = $this->cloudServersVolumesUpdateWithHttpInfo($server_id, $volume_id, $volume, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersVolumesUpdateWithHttpInfo
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\Volume, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersVolumesUpdateWithHttpInfo($server_id, $volume_id, $volume, string $contentType = self::contentTypes['cloudServersVolumesUpdate'][0])
    {
        $request = $this->cloudServersVolumesUpdateRequest($server_id, $volume_id, $volume, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\Volume' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\Volume' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\Volume', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\Volume';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\Volume',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersVolumesUpdateAsync
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersVolumesUpdateAsync($server_id, $volume_id, $volume, string $contentType = self::contentTypes['cloudServersVolumesUpdate'][0])
    {
        return $this->cloudServersVolumesUpdateAsyncWithHttpInfo($server_id, $volume_id, $volume, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersVolumesUpdateAsyncWithHttpInfo
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersVolumesUpdateAsyncWithHttpInfo($server_id, $volume_id, $volume, string $contentType = self::contentTypes['cloudServersVolumesUpdate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\Volume';
        $request = $this->cloudServersVolumesUpdateRequest($server_id, $volume_id, $volume, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersVolumesUpdate'
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersVolumesUpdateRequest($server_id, $volume_id, $volume, string $contentType = self::contentTypes['cloudServersVolumesUpdate'][0])
    {

        // verify the required parameter 'server_id' is set
        if ($server_id === null || (is_array($server_id) && count($server_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_id when calling cloudServersVolumesUpdate'
            );
        }
        if (!preg_match("/^\\d{1,10}$/", $server_id)) {
            throw new \InvalidArgumentException("invalid value for \"server_id\" when calling CloudApi.cloudServersVolumesUpdate, must conform to the pattern /^\\d{1,10}$/.");
        }
        
        // verify the required parameter 'volume_id' is set
        if ($volume_id === null || (is_array($volume_id) && count($volume_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $volume_id when calling cloudServersVolumesUpdate'
            );
        }

        // verify the required parameter 'volume' is set
        if ($volume === null || (is_array($volume) && count($volume) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $volume when calling cloudServersVolumesUpdate'
            );
        }


        $resourcePath = '/api/cloud/servers/{server_id}/volumes/{volume_id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($server_id !== null) {
            $resourcePath = str_replace(
                '{' . 'server_id' . '}',
                ObjectSerializer::toPathValue($server_id),
                $resourcePath
            );
        }
        // path params
        if ($volume_id !== null) {
            $resourcePath = str_replace(
                '{' . 'volume_id' . '}',
                ObjectSerializer::toPathValue($volume_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($volume)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($volume));
            } else {
                $httpBody = $volume;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudServersVolumesUpdate2
     *
     * @param  string $server_id server_id (required)
     * @param  string $volume_id volume_id (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\Volume
     */
    public function cloudServersVolumesUpdate2($server_id, $volume_id, $volume, string $contentType = self::contentTypes['cloudServersVolumesUpdate2'][0])
    {
        list($response) = $this->cloudServersVolumesUpdate2WithHttpInfo($server_id, $volume_id, $volume, $contentType);
        return $response;
    }

    /**
     * Operation cloudServersVolumesUpdate2WithHttpInfo
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\Volume, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudServersVolumesUpdate2WithHttpInfo($server_id, $volume_id, $volume, string $contentType = self::contentTypes['cloudServersVolumesUpdate2'][0])
    {
        $request = $this->cloudServersVolumesUpdate2Request($server_id, $volume_id, $volume, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\Volume' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\Volume' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\Volume', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\Volume';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\Volume',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudServersVolumesUpdate2Async
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersVolumesUpdate2Async($server_id, $volume_id, $volume, string $contentType = self::contentTypes['cloudServersVolumesUpdate2'][0])
    {
        return $this->cloudServersVolumesUpdate2AsyncWithHttpInfo($server_id, $volume_id, $volume, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudServersVolumesUpdate2AsyncWithHttpInfo
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudServersVolumesUpdate2AsyncWithHttpInfo($server_id, $volume_id, $volume, string $contentType = self::contentTypes['cloudServersVolumesUpdate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\Volume';
        $request = $this->cloudServersVolumesUpdate2Request($server_id, $volume_id, $volume, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudServersVolumesUpdate2'
     *
     * @param  string $server_id (required)
     * @param  string $volume_id (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudServersVolumesUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudServersVolumesUpdate2Request($server_id, $volume_id, $volume, string $contentType = self::contentTypes['cloudServersVolumesUpdate2'][0])
    {

        // verify the required parameter 'server_id' is set
        if ($server_id === null || (is_array($server_id) && count($server_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $server_id when calling cloudServersVolumesUpdate2'
            );
        }
        if (!preg_match("/^\\d{1,10}$/", $server_id)) {
            throw new \InvalidArgumentException("invalid value for \"server_id\" when calling CloudApi.cloudServersVolumesUpdate2, must conform to the pattern /^\\d{1,10}$/.");
        }
        
        // verify the required parameter 'volume_id' is set
        if ($volume_id === null || (is_array($volume_id) && count($volume_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $volume_id when calling cloudServersVolumesUpdate2'
            );
        }

        // verify the required parameter 'volume' is set
        if ($volume === null || (is_array($volume) && count($volume) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $volume when calling cloudServersVolumesUpdate2'
            );
        }


        $resourcePath = '/api/v1/cloud/servers/{server_id}/volumes/{volume_id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($server_id !== null) {
            $resourcePath = str_replace(
                '{' . 'server_id' . '}',
                ObjectSerializer::toPathValue($server_id),
                $resourcePath
            );
        }
        // path params
        if ($volume_id !== null) {
            $resourcePath = str_replace(
                '{' . 'volume_id' . '}',
                ObjectSerializer::toPathValue($volume_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($volume)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($volume));
            } else {
                $httpBody = $volume;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudStorageProductsList
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudStorageProductsList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedStorageProductList
     */
    public function cloudStorageProductsList($page = null, string $contentType = self::contentTypes['cloudStorageProductsList'][0])
    {
        list($response) = $this->cloudStorageProductsListWithHttpInfo($page, $contentType);
        return $response;
    }

    /**
     * Operation cloudStorageProductsListWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudStorageProductsList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedStorageProductList, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudStorageProductsListWithHttpInfo($page = null, string $contentType = self::contentTypes['cloudStorageProductsList'][0])
    {
        $request = $this->cloudStorageProductsListRequest($page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedStorageProductList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedStorageProductList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedStorageProductList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedStorageProductList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedStorageProductList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudStorageProductsListAsync
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudStorageProductsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudStorageProductsListAsync($page = null, string $contentType = self::contentTypes['cloudStorageProductsList'][0])
    {
        return $this->cloudStorageProductsListAsyncWithHttpInfo($page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudStorageProductsListAsyncWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudStorageProductsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudStorageProductsListAsyncWithHttpInfo($page = null, string $contentType = self::contentTypes['cloudStorageProductsList'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedStorageProductList';
        $request = $this->cloudStorageProductsListRequest($page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudStorageProductsList'
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudStorageProductsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudStorageProductsListRequest($page = null, string $contentType = self::contentTypes['cloudStorageProductsList'][0])
    {



        $resourcePath = '/api/cloud/storage-products/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudStorageProductsList2
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudStorageProductsList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedStorageProductList
     */
    public function cloudStorageProductsList2($page = null, string $contentType = self::contentTypes['cloudStorageProductsList2'][0])
    {
        list($response) = $this->cloudStorageProductsList2WithHttpInfo($page, $contentType);
        return $response;
    }

    /**
     * Operation cloudStorageProductsList2WithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudStorageProductsList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedStorageProductList, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudStorageProductsList2WithHttpInfo($page = null, string $contentType = self::contentTypes['cloudStorageProductsList2'][0])
    {
        $request = $this->cloudStorageProductsList2Request($page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedStorageProductList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedStorageProductList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedStorageProductList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedStorageProductList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedStorageProductList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudStorageProductsList2Async
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudStorageProductsList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudStorageProductsList2Async($page = null, string $contentType = self::contentTypes['cloudStorageProductsList2'][0])
    {
        return $this->cloudStorageProductsList2AsyncWithHttpInfo($page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudStorageProductsList2AsyncWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudStorageProductsList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudStorageProductsList2AsyncWithHttpInfo($page = null, string $contentType = self::contentTypes['cloudStorageProductsList2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedStorageProductList';
        $request = $this->cloudStorageProductsList2Request($page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudStorageProductsList2'
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudStorageProductsList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudStorageProductsList2Request($page = null, string $contentType = self::contentTypes['cloudStorageProductsList2'][0])
    {



        $resourcePath = '/api/v1/cloud/storage-products/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudStorageProductsRetrieve
     *
     * @param  int $id A unique integer value identifying this metered product. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudStorageProductsRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\StorageProduct
     */
    public function cloudStorageProductsRetrieve($id, string $contentType = self::contentTypes['cloudStorageProductsRetrieve'][0])
    {
        list($response) = $this->cloudStorageProductsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation cloudStorageProductsRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this metered product. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudStorageProductsRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\StorageProduct, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudStorageProductsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['cloudStorageProductsRetrieve'][0])
    {
        $request = $this->cloudStorageProductsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\StorageProduct' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\StorageProduct' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\StorageProduct', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\StorageProduct';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\StorageProduct',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudStorageProductsRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this metered product. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudStorageProductsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudStorageProductsRetrieveAsync($id, string $contentType = self::contentTypes['cloudStorageProductsRetrieve'][0])
    {
        return $this->cloudStorageProductsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudStorageProductsRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this metered product. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudStorageProductsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudStorageProductsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudStorageProductsRetrieve'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\StorageProduct';
        $request = $this->cloudStorageProductsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudStorageProductsRetrieve'
     *
     * @param  int $id A unique integer value identifying this metered product. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudStorageProductsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudStorageProductsRetrieveRequest($id, string $contentType = self::contentTypes['cloudStorageProductsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudStorageProductsRetrieve'
            );
        }


        $resourcePath = '/api/cloud/storage-products/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudStorageProductsRetrieve2
     *
     * @param  int $id A unique integer value identifying this metered product. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudStorageProductsRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\StorageProduct
     */
    public function cloudStorageProductsRetrieve2($id, string $contentType = self::contentTypes['cloudStorageProductsRetrieve2'][0])
    {
        list($response) = $this->cloudStorageProductsRetrieve2WithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation cloudStorageProductsRetrieve2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this metered product. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudStorageProductsRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\StorageProduct, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudStorageProductsRetrieve2WithHttpInfo($id, string $contentType = self::contentTypes['cloudStorageProductsRetrieve2'][0])
    {
        $request = $this->cloudStorageProductsRetrieve2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\StorageProduct' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\StorageProduct' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\StorageProduct', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\StorageProduct';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\StorageProduct',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudStorageProductsRetrieve2Async
     *
     * @param  int $id A unique integer value identifying this metered product. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudStorageProductsRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudStorageProductsRetrieve2Async($id, string $contentType = self::contentTypes['cloudStorageProductsRetrieve2'][0])
    {
        return $this->cloudStorageProductsRetrieve2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudStorageProductsRetrieve2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this metered product. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudStorageProductsRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudStorageProductsRetrieve2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudStorageProductsRetrieve2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\StorageProduct';
        $request = $this->cloudStorageProductsRetrieve2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudStorageProductsRetrieve2'
     *
     * @param  int $id A unique integer value identifying this metered product. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudStorageProductsRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudStorageProductsRetrieve2Request($id, string $contentType = self::contentTypes['cloudStorageProductsRetrieve2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudStorageProductsRetrieve2'
            );
        }


        $resourcePath = '/api/v1/cloud/storage-products/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudVolumesAttachCreate
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\AttachVolume $attach_volume attach_volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesAttachCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\AttachVolume
     */
    public function cloudVolumesAttachCreate($id, $attach_volume, string $contentType = self::contentTypes['cloudVolumesAttachCreate'][0])
    {
        list($response) = $this->cloudVolumesAttachCreateWithHttpInfo($id, $attach_volume, $contentType);
        return $response;
    }

    /**
     * Operation cloudVolumesAttachCreateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\AttachVolume $attach_volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesAttachCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\AttachVolume, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudVolumesAttachCreateWithHttpInfo($id, $attach_volume, string $contentType = self::contentTypes['cloudVolumesAttachCreate'][0])
    {
        $request = $this->cloudVolumesAttachCreateRequest($id, $attach_volume, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\AttachVolume' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\AttachVolume' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\AttachVolume', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\AttachVolume';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\AttachVolume',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudVolumesAttachCreateAsync
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\AttachVolume $attach_volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesAttachCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesAttachCreateAsync($id, $attach_volume, string $contentType = self::contentTypes['cloudVolumesAttachCreate'][0])
    {
        return $this->cloudVolumesAttachCreateAsyncWithHttpInfo($id, $attach_volume, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudVolumesAttachCreateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\AttachVolume $attach_volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesAttachCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesAttachCreateAsyncWithHttpInfo($id, $attach_volume, string $contentType = self::contentTypes['cloudVolumesAttachCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\AttachVolume';
        $request = $this->cloudVolumesAttachCreateRequest($id, $attach_volume, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudVolumesAttachCreate'
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\AttachVolume $attach_volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesAttachCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudVolumesAttachCreateRequest($id, $attach_volume, string $contentType = self::contentTypes['cloudVolumesAttachCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudVolumesAttachCreate'
            );
        }

        // verify the required parameter 'attach_volume' is set
        if ($attach_volume === null || (is_array($attach_volume) && count($attach_volume) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attach_volume when calling cloudVolumesAttachCreate'
            );
        }


        $resourcePath = '/api/cloud/volumes/{id}/attach/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($attach_volume)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($attach_volume));
            } else {
                $httpBody = $attach_volume;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudVolumesAttachCreate2
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\AttachVolume $attach_volume attach_volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesAttachCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\AttachVolume
     */
    public function cloudVolumesAttachCreate2($id, $attach_volume, string $contentType = self::contentTypes['cloudVolumesAttachCreate2'][0])
    {
        list($response) = $this->cloudVolumesAttachCreate2WithHttpInfo($id, $attach_volume, $contentType);
        return $response;
    }

    /**
     * Operation cloudVolumesAttachCreate2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\AttachVolume $attach_volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesAttachCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\AttachVolume, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudVolumesAttachCreate2WithHttpInfo($id, $attach_volume, string $contentType = self::contentTypes['cloudVolumesAttachCreate2'][0])
    {
        $request = $this->cloudVolumesAttachCreate2Request($id, $attach_volume, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\AttachVolume' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\AttachVolume' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\AttachVolume', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\AttachVolume';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\AttachVolume',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudVolumesAttachCreate2Async
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\AttachVolume $attach_volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesAttachCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesAttachCreate2Async($id, $attach_volume, string $contentType = self::contentTypes['cloudVolumesAttachCreate2'][0])
    {
        return $this->cloudVolumesAttachCreate2AsyncWithHttpInfo($id, $attach_volume, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudVolumesAttachCreate2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\AttachVolume $attach_volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesAttachCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesAttachCreate2AsyncWithHttpInfo($id, $attach_volume, string $contentType = self::contentTypes['cloudVolumesAttachCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\AttachVolume';
        $request = $this->cloudVolumesAttachCreate2Request($id, $attach_volume, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudVolumesAttachCreate2'
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\AttachVolume $attach_volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesAttachCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudVolumesAttachCreate2Request($id, $attach_volume, string $contentType = self::contentTypes['cloudVolumesAttachCreate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudVolumesAttachCreate2'
            );
        }

        // verify the required parameter 'attach_volume' is set
        if ($attach_volume === null || (is_array($attach_volume) && count($attach_volume) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $attach_volume when calling cloudVolumesAttachCreate2'
            );
        }


        $resourcePath = '/api/v1/cloud/volumes/{id}/attach/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($attach_volume)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($attach_volume));
            } else {
                $httpBody = $attach_volume;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudVolumesDestroy
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cloudVolumesDestroy($id, string $contentType = self::contentTypes['cloudVolumesDestroy'][0])
    {
        $this->cloudVolumesDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation cloudVolumesDestroyWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudVolumesDestroyWithHttpInfo($id, string $contentType = self::contentTypes['cloudVolumesDestroy'][0])
    {
        $request = $this->cloudVolumesDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cloudVolumesDestroyAsync
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesDestroyAsync($id, string $contentType = self::contentTypes['cloudVolumesDestroy'][0])
    {
        return $this->cloudVolumesDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudVolumesDestroyAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudVolumesDestroy'][0])
    {
        $returnType = '';
        $request = $this->cloudVolumesDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudVolumesDestroy'
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudVolumesDestroyRequest($id, string $contentType = self::contentTypes['cloudVolumesDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudVolumesDestroy'
            );
        }


        $resourcePath = '/api/cloud/volumes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudVolumesDestroy2
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function cloudVolumesDestroy2($id, string $contentType = self::contentTypes['cloudVolumesDestroy2'][0])
    {
        $this->cloudVolumesDestroy2WithHttpInfo($id, $contentType);
    }

    /**
     * Operation cloudVolumesDestroy2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudVolumesDestroy2WithHttpInfo($id, string $contentType = self::contentTypes['cloudVolumesDestroy2'][0])
    {
        $request = $this->cloudVolumesDestroy2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation cloudVolumesDestroy2Async
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesDestroy2Async($id, string $contentType = self::contentTypes['cloudVolumesDestroy2'][0])
    {
        return $this->cloudVolumesDestroy2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudVolumesDestroy2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesDestroy2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudVolumesDestroy2'][0])
    {
        $returnType = '';
        $request = $this->cloudVolumesDestroy2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudVolumesDestroy2'
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudVolumesDestroy2Request($id, string $contentType = self::contentTypes['cloudVolumesDestroy2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudVolumesDestroy2'
            );
        }


        $resourcePath = '/api/v1/cloud/volumes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudVolumesDetachCreate
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesDetachCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\DetachVolume
     */
    public function cloudVolumesDetachCreate($id, $volume, string $contentType = self::contentTypes['cloudVolumesDetachCreate'][0])
    {
        list($response) = $this->cloudVolumesDetachCreateWithHttpInfo($id, $volume, $contentType);
        return $response;
    }

    /**
     * Operation cloudVolumesDetachCreateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesDetachCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\DetachVolume, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudVolumesDetachCreateWithHttpInfo($id, $volume, string $contentType = self::contentTypes['cloudVolumesDetachCreate'][0])
    {
        $request = $this->cloudVolumesDetachCreateRequest($id, $volume, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\DetachVolume' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\DetachVolume' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\DetachVolume', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\DetachVolume';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\DetachVolume',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudVolumesDetachCreateAsync
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesDetachCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesDetachCreateAsync($id, $volume, string $contentType = self::contentTypes['cloudVolumesDetachCreate'][0])
    {
        return $this->cloudVolumesDetachCreateAsyncWithHttpInfo($id, $volume, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudVolumesDetachCreateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesDetachCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesDetachCreateAsyncWithHttpInfo($id, $volume, string $contentType = self::contentTypes['cloudVolumesDetachCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\DetachVolume';
        $request = $this->cloudVolumesDetachCreateRequest($id, $volume, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudVolumesDetachCreate'
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesDetachCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudVolumesDetachCreateRequest($id, $volume, string $contentType = self::contentTypes['cloudVolumesDetachCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudVolumesDetachCreate'
            );
        }

        // verify the required parameter 'volume' is set
        if ($volume === null || (is_array($volume) && count($volume) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $volume when calling cloudVolumesDetachCreate'
            );
        }


        $resourcePath = '/api/cloud/volumes/{id}/detach/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($volume)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($volume));
            } else {
                $httpBody = $volume;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudVolumesDetachCreate2
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesDetachCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\DetachVolume
     */
    public function cloudVolumesDetachCreate2($id, $volume, string $contentType = self::contentTypes['cloudVolumesDetachCreate2'][0])
    {
        list($response) = $this->cloudVolumesDetachCreate2WithHttpInfo($id, $volume, $contentType);
        return $response;
    }

    /**
     * Operation cloudVolumesDetachCreate2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesDetachCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\DetachVolume, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudVolumesDetachCreate2WithHttpInfo($id, $volume, string $contentType = self::contentTypes['cloudVolumesDetachCreate2'][0])
    {
        $request = $this->cloudVolumesDetachCreate2Request($id, $volume, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\DetachVolume' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\DetachVolume' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\DetachVolume', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\DetachVolume';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\DetachVolume',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudVolumesDetachCreate2Async
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesDetachCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesDetachCreate2Async($id, $volume, string $contentType = self::contentTypes['cloudVolumesDetachCreate2'][0])
    {
        return $this->cloudVolumesDetachCreate2AsyncWithHttpInfo($id, $volume, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudVolumesDetachCreate2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesDetachCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesDetachCreate2AsyncWithHttpInfo($id, $volume, string $contentType = self::contentTypes['cloudVolumesDetachCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\DetachVolume';
        $request = $this->cloudVolumesDetachCreate2Request($id, $volume, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudVolumesDetachCreate2'
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesDetachCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudVolumesDetachCreate2Request($id, $volume, string $contentType = self::contentTypes['cloudVolumesDetachCreate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudVolumesDetachCreate2'
            );
        }

        // verify the required parameter 'volume' is set
        if ($volume === null || (is_array($volume) && count($volume) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $volume when calling cloudVolumesDetachCreate2'
            );
        }


        $resourcePath = '/api/v1/cloud/volumes/{id}/detach/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($volume)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($volume));
            } else {
                $httpBody = $volume;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudVolumesList
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\Volume[]
     */
    public function cloudVolumesList(string $contentType = self::contentTypes['cloudVolumesList'][0])
    {
        list($response) = $this->cloudVolumesListWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation cloudVolumesListWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\Volume[], HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudVolumesListWithHttpInfo(string $contentType = self::contentTypes['cloudVolumesList'][0])
    {
        $request = $this->cloudVolumesListRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\Volume[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\Volume[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\Volume[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\Volume[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\Volume[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudVolumesListAsync
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesListAsync(string $contentType = self::contentTypes['cloudVolumesList'][0])
    {
        return $this->cloudVolumesListAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudVolumesListAsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesListAsyncWithHttpInfo(string $contentType = self::contentTypes['cloudVolumesList'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\Volume[]';
        $request = $this->cloudVolumesListRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudVolumesList'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudVolumesListRequest(string $contentType = self::contentTypes['cloudVolumesList'][0])
    {


        $resourcePath = '/api/cloud/volumes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudVolumesList2
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\Volume[]
     */
    public function cloudVolumesList2(string $contentType = self::contentTypes['cloudVolumesList2'][0])
    {
        list($response) = $this->cloudVolumesList2WithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation cloudVolumesList2WithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\Volume[], HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudVolumesList2WithHttpInfo(string $contentType = self::contentTypes['cloudVolumesList2'][0])
    {
        $request = $this->cloudVolumesList2Request($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\Volume[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\Volume[]' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\Volume[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\Volume[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\Volume[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudVolumesList2Async
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesList2Async(string $contentType = self::contentTypes['cloudVolumesList2'][0])
    {
        return $this->cloudVolumesList2AsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudVolumesList2AsyncWithHttpInfo
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesList2AsyncWithHttpInfo(string $contentType = self::contentTypes['cloudVolumesList2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\Volume[]';
        $request = $this->cloudVolumesList2Request($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudVolumesList2'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudVolumesList2Request(string $contentType = self::contentTypes['cloudVolumesList2'][0])
    {


        $resourcePath = '/api/v1/cloud/volumes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudVolumesPartialUpdate
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedVolume|null $patched_volume patched_volume (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\Volume
     */
    public function cloudVolumesPartialUpdate($id, $patched_volume = null, string $contentType = self::contentTypes['cloudVolumesPartialUpdate'][0])
    {
        list($response) = $this->cloudVolumesPartialUpdateWithHttpInfo($id, $patched_volume, $contentType);
        return $response;
    }

    /**
     * Operation cloudVolumesPartialUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedVolume|null $patched_volume (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\Volume, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudVolumesPartialUpdateWithHttpInfo($id, $patched_volume = null, string $contentType = self::contentTypes['cloudVolumesPartialUpdate'][0])
    {
        $request = $this->cloudVolumesPartialUpdateRequest($id, $patched_volume, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\Volume' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\Volume' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\Volume', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\Volume';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\Volume',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudVolumesPartialUpdateAsync
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedVolume|null $patched_volume (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesPartialUpdateAsync($id, $patched_volume = null, string $contentType = self::contentTypes['cloudVolumesPartialUpdate'][0])
    {
        return $this->cloudVolumesPartialUpdateAsyncWithHttpInfo($id, $patched_volume, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudVolumesPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedVolume|null $patched_volume (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesPartialUpdateAsyncWithHttpInfo($id, $patched_volume = null, string $contentType = self::contentTypes['cloudVolumesPartialUpdate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\Volume';
        $request = $this->cloudVolumesPartialUpdateRequest($id, $patched_volume, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudVolumesPartialUpdate'
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedVolume|null $patched_volume (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudVolumesPartialUpdateRequest($id, $patched_volume = null, string $contentType = self::contentTypes['cloudVolumesPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudVolumesPartialUpdate'
            );
        }



        $resourcePath = '/api/cloud/volumes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_volume)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_volume));
            } else {
                $httpBody = $patched_volume;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudVolumesPartialUpdate2
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedVolume|null $patched_volume patched_volume (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\Volume
     */
    public function cloudVolumesPartialUpdate2($id, $patched_volume = null, string $contentType = self::contentTypes['cloudVolumesPartialUpdate2'][0])
    {
        list($response) = $this->cloudVolumesPartialUpdate2WithHttpInfo($id, $patched_volume, $contentType);
        return $response;
    }

    /**
     * Operation cloudVolumesPartialUpdate2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedVolume|null $patched_volume (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\Volume, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudVolumesPartialUpdate2WithHttpInfo($id, $patched_volume = null, string $contentType = self::contentTypes['cloudVolumesPartialUpdate2'][0])
    {
        $request = $this->cloudVolumesPartialUpdate2Request($id, $patched_volume, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\Volume' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\Volume' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\Volume', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\Volume';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\Volume',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudVolumesPartialUpdate2Async
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedVolume|null $patched_volume (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesPartialUpdate2Async($id, $patched_volume = null, string $contentType = self::contentTypes['cloudVolumesPartialUpdate2'][0])
    {
        return $this->cloudVolumesPartialUpdate2AsyncWithHttpInfo($id, $patched_volume, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudVolumesPartialUpdate2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedVolume|null $patched_volume (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesPartialUpdate2AsyncWithHttpInfo($id, $patched_volume = null, string $contentType = self::contentTypes['cloudVolumesPartialUpdate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\Volume';
        $request = $this->cloudVolumesPartialUpdate2Request($id, $patched_volume, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudVolumesPartialUpdate2'
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\PatchedVolume|null $patched_volume (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudVolumesPartialUpdate2Request($id, $patched_volume = null, string $contentType = self::contentTypes['cloudVolumesPartialUpdate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudVolumesPartialUpdate2'
            );
        }



        $resourcePath = '/api/v1/cloud/volumes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_volume)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_volume));
            } else {
                $httpBody = $patched_volume;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudVolumesRetrieve
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\Volume
     */
    public function cloudVolumesRetrieve($id, string $contentType = self::contentTypes['cloudVolumesRetrieve'][0])
    {
        list($response) = $this->cloudVolumesRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation cloudVolumesRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\Volume, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudVolumesRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['cloudVolumesRetrieve'][0])
    {
        $request = $this->cloudVolumesRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\Volume' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\Volume' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\Volume', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\Volume';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\Volume',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudVolumesRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesRetrieveAsync($id, string $contentType = self::contentTypes['cloudVolumesRetrieve'][0])
    {
        return $this->cloudVolumesRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudVolumesRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudVolumesRetrieve'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\Volume';
        $request = $this->cloudVolumesRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudVolumesRetrieve'
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudVolumesRetrieveRequest($id, string $contentType = self::contentTypes['cloudVolumesRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudVolumesRetrieve'
            );
        }


        $resourcePath = '/api/cloud/volumes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudVolumesRetrieve2
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\Volume
     */
    public function cloudVolumesRetrieve2($id, string $contentType = self::contentTypes['cloudVolumesRetrieve2'][0])
    {
        list($response) = $this->cloudVolumesRetrieve2WithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation cloudVolumesRetrieve2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\Volume, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudVolumesRetrieve2WithHttpInfo($id, string $contentType = self::contentTypes['cloudVolumesRetrieve2'][0])
    {
        $request = $this->cloudVolumesRetrieve2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\Volume' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\Volume' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\Volume', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\Volume';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\Volume',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudVolumesRetrieve2Async
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesRetrieve2Async($id, string $contentType = self::contentTypes['cloudVolumesRetrieve2'][0])
    {
        return $this->cloudVolumesRetrieve2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudVolumesRetrieve2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesRetrieve2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['cloudVolumesRetrieve2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\Volume';
        $request = $this->cloudVolumesRetrieve2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudVolumesRetrieve2'
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudVolumesRetrieve2Request($id, string $contentType = self::contentTypes['cloudVolumesRetrieve2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudVolumesRetrieve2'
            );
        }


        $resourcePath = '/api/v1/cloud/volumes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudVolumesUpdate
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\Volume
     */
    public function cloudVolumesUpdate($id, $volume, string $contentType = self::contentTypes['cloudVolumesUpdate'][0])
    {
        list($response) = $this->cloudVolumesUpdateWithHttpInfo($id, $volume, $contentType);
        return $response;
    }

    /**
     * Operation cloudVolumesUpdateWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\Volume, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudVolumesUpdateWithHttpInfo($id, $volume, string $contentType = self::contentTypes['cloudVolumesUpdate'][0])
    {
        $request = $this->cloudVolumesUpdateRequest($id, $volume, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\Volume' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\Volume' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\Volume', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\Volume';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\Volume',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudVolumesUpdateAsync
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesUpdateAsync($id, $volume, string $contentType = self::contentTypes['cloudVolumesUpdate'][0])
    {
        return $this->cloudVolumesUpdateAsyncWithHttpInfo($id, $volume, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudVolumesUpdateAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesUpdateAsyncWithHttpInfo($id, $volume, string $contentType = self::contentTypes['cloudVolumesUpdate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\Volume';
        $request = $this->cloudVolumesUpdateRequest($id, $volume, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudVolumesUpdate'
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudVolumesUpdateRequest($id, $volume, string $contentType = self::contentTypes['cloudVolumesUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudVolumesUpdate'
            );
        }

        // verify the required parameter 'volume' is set
        if ($volume === null || (is_array($volume) && count($volume) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $volume when calling cloudVolumesUpdate'
            );
        }


        $resourcePath = '/api/cloud/volumes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($volume)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($volume));
            } else {
                $httpBody = $volume;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation cloudVolumesUpdate2
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\Volume
     */
    public function cloudVolumesUpdate2($id, $volume, string $contentType = self::contentTypes['cloudVolumesUpdate2'][0])
    {
        list($response) = $this->cloudVolumesUpdate2WithHttpInfo($id, $volume, $contentType);
        return $response;
    }

    /**
     * Operation cloudVolumesUpdate2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\Volume, HTTP status code, HTTP response headers (array of strings)
     */
    public function cloudVolumesUpdate2WithHttpInfo($id, $volume, string $contentType = self::contentTypes['cloudVolumesUpdate2'][0])
    {
        $request = $this->cloudVolumesUpdate2Request($id, $volume, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\Volume' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\Volume' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\Volume', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\Volume';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\Volume',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation cloudVolumesUpdate2Async
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesUpdate2Async($id, $volume, string $contentType = self::contentTypes['cloudVolumesUpdate2'][0])
    {
        return $this->cloudVolumesUpdate2AsyncWithHttpInfo($id, $volume, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation cloudVolumesUpdate2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function cloudVolumesUpdate2AsyncWithHttpInfo($id, $volume, string $contentType = self::contentTypes['cloudVolumesUpdate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\Volume';
        $request = $this->cloudVolumesUpdate2Request($id, $volume, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'cloudVolumesUpdate2'
     *
     * @param  int $id A unique integer value identifying this storage. (required)
     * @param  \PidginHost\\Sdk\Model\Volume $volume (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['cloudVolumesUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function cloudVolumesUpdate2Request($id, $volume, string $contentType = self::contentTypes['cloudVolumesUpdate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling cloudVolumesUpdate2'
            );
        }

        // verify the required parameter 'volume' is set
        if ($volume === null || (is_array($volume) && count($volume) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $volume when calling cloudVolumesUpdate2'
            );
        }


        $resourcePath = '/api/v1/cloud/volumes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($volume)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($volume));
            } else {
                $httpBody = $volume;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
