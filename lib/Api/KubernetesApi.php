<?php
/**
 * KubernetesApi
 * PHP version 7.4
 *
 * @category Class
 * @package  PidginHost\\Sdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Pidgin Host API
 *
 * The Pidgin Host API allows you to manage Services and resources within the Pidgin Host cloud in a simple, programmatic way using conventional HTTP requests. All of the functionality that you are familiar with in the Pidgin Host control panel is also available through the API, allowing you to script the complex actions that your situation requires.
 *
 * The version of the OpenAPI document: 1.0.0 (v1)
 * Contact: support@pidginhost.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace PidginHost\\Sdk\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use PidginHost\\Sdk\ApiException;
use PidginHost\\Sdk\Configuration;
use PidginHost\\Sdk\HeaderSelector;
use PidginHost\\Sdk\ObjectSerializer;

/**
 * KubernetesApi Class Doc Comment
 *
 * @category Class
 * @package  PidginHost\\Sdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class KubernetesApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'kubernetesClusterTypesList' => [
            'application/json',
        ],
        'kubernetesClusterTypesList2' => [
            'application/json',
        ],
        'kubernetesClustersConnectVmCreate' => [
            'application/json',
        ],
        'kubernetesClustersConnectVmCreate2' => [
            'application/json',
        ],
        'kubernetesClustersConnectedVmsRetrieve' => [
            'application/json',
        ],
        'kubernetesClustersConnectedVmsRetrieve2' => [
            'application/json',
        ],
        'kubernetesClustersCreate' => [
            'application/json',
        ],
        'kubernetesClustersCreate2' => [
            'application/json',
        ],
        'kubernetesClustersDestroy' => [
            'application/json',
        ],
        'kubernetesClustersDestroy2' => [
            'application/json',
        ],
        'kubernetesClustersDisconnectVmCreate' => [
            'application/json',
        ],
        'kubernetesClustersDisconnectVmCreate2' => [
            'application/json',
        ],
        'kubernetesClustersHttproutesCreate' => [
            'application/json',
        ],
        'kubernetesClustersHttproutesCreate2' => [
            'application/json',
        ],
        'kubernetesClustersHttproutesDestroy' => [
            'application/json',
        ],
        'kubernetesClustersHttproutesDestroy2' => [
            'application/json',
        ],
        'kubernetesClustersHttproutesPartialUpdate' => [
            'application/json',
        ],
        'kubernetesClustersHttproutesPartialUpdate2' => [
            'application/json',
        ],
        'kubernetesClustersHttproutesRetrieve' => [
            'application/json',
        ],
        'kubernetesClustersHttproutesRetrieve2' => [
            'application/json',
        ],
        'kubernetesClustersHttproutesRetrieve3' => [
            'application/json',
        ],
        'kubernetesClustersHttproutesRetrieve4' => [
            'application/json',
        ],
        'kubernetesClustersHttproutesUpdate' => [
            'application/json',
        ],
        'kubernetesClustersHttproutesUpdate2' => [
            'application/json',
        ],
        'kubernetesClustersKubeVersionUpgradeCreate' => [
            'application/json',
        ],
        'kubernetesClustersKubeVersionUpgradeCreate2' => [
            'application/json',
        ],
        'kubernetesClustersKubeconfigCreate' => [
            'application/json',
        ],
        'kubernetesClustersKubeconfigCreate2' => [
            'application/json',
        ],
        'kubernetesClustersKubeconfigRetrieve' => [
            'application/json',
        ],
        'kubernetesClustersKubeconfigRetrieve2' => [
            'application/json',
        ],
        'kubernetesClustersList' => [
            'application/json',
        ],
        'kubernetesClustersList2' => [
            'application/json',
        ],
        'kubernetesClustersPartialUpdate' => [
            'application/json',
        ],
        'kubernetesClustersPartialUpdate2' => [
            'application/json',
        ],
        'kubernetesClustersPortForwardsCreate' => [
            'application/json',
        ],
        'kubernetesClustersPortForwardsCreate2' => [
            'application/json',
        ],
        'kubernetesClustersPortForwardsDestroy' => [
            'application/json',
        ],
        'kubernetesClustersPortForwardsDestroy2' => [
            'application/json',
        ],
        'kubernetesClustersPortForwardsPartialUpdate' => [
            'application/json',
        ],
        'kubernetesClustersPortForwardsPartialUpdate2' => [
            'application/json',
        ],
        'kubernetesClustersPortForwardsRetrieve' => [
            'application/json',
        ],
        'kubernetesClustersPortForwardsRetrieve2' => [
            'application/json',
        ],
        'kubernetesClustersPortForwardsRetrieve3' => [
            'application/json',
        ],
        'kubernetesClustersPortForwardsRetrieve4' => [
            'application/json',
        ],
        'kubernetesClustersPortForwardsUpdate' => [
            'application/json',
        ],
        'kubernetesClustersPortForwardsUpdate2' => [
            'application/json',
        ],
        'kubernetesClustersResourcePoolsCreate' => [
            'application/json',
        ],
        'kubernetesClustersResourcePoolsCreate2' => [
            'application/json',
        ],
        'kubernetesClustersResourcePoolsDestroy' => [
            'application/json',
        ],
        'kubernetesClustersResourcePoolsDestroy2' => [
            'application/json',
        ],
        'kubernetesClustersResourcePoolsList' => [
            'application/json',
        ],
        'kubernetesClustersResourcePoolsList2' => [
            'application/json',
        ],
        'kubernetesClustersResourcePoolsNodesDestroy' => [
            'application/json',
        ],
        'kubernetesClustersResourcePoolsNodesDestroy2' => [
            'application/json',
        ],
        'kubernetesClustersResourcePoolsNodesList' => [
            'application/json',
        ],
        'kubernetesClustersResourcePoolsNodesList2' => [
            'application/json',
        ],
        'kubernetesClustersResourcePoolsNodesRetrieve' => [
            'application/json',
        ],
        'kubernetesClustersResourcePoolsNodesRetrieve2' => [
            'application/json',
        ],
        'kubernetesClustersResourcePoolsPartialUpdate' => [
            'application/json',
        ],
        'kubernetesClustersResourcePoolsPartialUpdate2' => [
            'application/json',
        ],
        'kubernetesClustersResourcePoolsRetrieve' => [
            'application/json',
        ],
        'kubernetesClustersResourcePoolsRetrieve2' => [
            'application/json',
        ],
        'kubernetesClustersResourcePoolsUpdate' => [
            'application/json',
        ],
        'kubernetesClustersResourcePoolsUpdate2' => [
            'application/json',
        ],
        'kubernetesClustersRetrieve' => [
            'application/json',
        ],
        'kubernetesClustersRetrieve2' => [
            'application/json',
        ],
        'kubernetesClustersTalosVersionUpgradeCreate' => [
            'application/json',
        ],
        'kubernetesClustersTalosVersionUpgradeCreate2' => [
            'application/json',
        ],
        'kubernetesClustersTcproutesCreate' => [
            'application/json',
        ],
        'kubernetesClustersTcproutesCreate2' => [
            'application/json',
        ],
        'kubernetesClustersTcproutesDestroy' => [
            'application/json',
        ],
        'kubernetesClustersTcproutesDestroy2' => [
            'application/json',
        ],
        'kubernetesClustersTcproutesPartialUpdate' => [
            'application/json',
        ],
        'kubernetesClustersTcproutesPartialUpdate2' => [
            'application/json',
        ],
        'kubernetesClustersTcproutesRetrieve' => [
            'application/json',
        ],
        'kubernetesClustersTcproutesRetrieve2' => [
            'application/json',
        ],
        'kubernetesClustersTcproutesRetrieve3' => [
            'application/json',
        ],
        'kubernetesClustersTcproutesRetrieve4' => [
            'application/json',
        ],
        'kubernetesClustersTcproutesUpdate' => [
            'application/json',
        ],
        'kubernetesClustersTcproutesUpdate2' => [
            'application/json',
        ],
        'kubernetesClustersUdproutesCreate' => [
            'application/json',
        ],
        'kubernetesClustersUdproutesCreate2' => [
            'application/json',
        ],
        'kubernetesClustersUdproutesDestroy' => [
            'application/json',
        ],
        'kubernetesClustersUdproutesDestroy2' => [
            'application/json',
        ],
        'kubernetesClustersUdproutesPartialUpdate' => [
            'application/json',
        ],
        'kubernetesClustersUdproutesPartialUpdate2' => [
            'application/json',
        ],
        'kubernetesClustersUdproutesRetrieve' => [
            'application/json',
        ],
        'kubernetesClustersUdproutesRetrieve2' => [
            'application/json',
        ],
        'kubernetesClustersUdproutesRetrieve3' => [
            'application/json',
        ],
        'kubernetesClustersUdproutesRetrieve4' => [
            'application/json',
        ],
        'kubernetesClustersUdproutesUpdate' => [
            'application/json',
        ],
        'kubernetesClustersUdproutesUpdate2' => [
            'application/json',
        ],
        'kubernetesClustersUpdate' => [
            'application/json',
        ],
        'kubernetesClustersUpdate2' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation kubernetesClusterTypesList
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClusterTypesList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedClusterTypeList
     */
    public function kubernetesClusterTypesList($page = null, string $contentType = self::contentTypes['kubernetesClusterTypesList'][0])
    {
        list($response) = $this->kubernetesClusterTypesListWithHttpInfo($page, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClusterTypesListWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClusterTypesList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedClusterTypeList, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClusterTypesListWithHttpInfo($page = null, string $contentType = self::contentTypes['kubernetesClusterTypesList'][0])
    {
        $request = $this->kubernetesClusterTypesListRequest($page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedClusterTypeList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedClusterTypeList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedClusterTypeList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedClusterTypeList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedClusterTypeList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClusterTypesListAsync
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClusterTypesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClusterTypesListAsync($page = null, string $contentType = self::contentTypes['kubernetesClusterTypesList'][0])
    {
        return $this->kubernetesClusterTypesListAsyncWithHttpInfo($page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClusterTypesListAsyncWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClusterTypesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClusterTypesListAsyncWithHttpInfo($page = null, string $contentType = self::contentTypes['kubernetesClusterTypesList'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedClusterTypeList';
        $request = $this->kubernetesClusterTypesListRequest($page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClusterTypesList'
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClusterTypesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClusterTypesListRequest($page = null, string $contentType = self::contentTypes['kubernetesClusterTypesList'][0])
    {



        $resourcePath = '/api/kubernetes/cluster-types/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClusterTypesList2
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClusterTypesList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedClusterTypeList
     */
    public function kubernetesClusterTypesList2($page = null, string $contentType = self::contentTypes['kubernetesClusterTypesList2'][0])
    {
        list($response) = $this->kubernetesClusterTypesList2WithHttpInfo($page, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClusterTypesList2WithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClusterTypesList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedClusterTypeList, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClusterTypesList2WithHttpInfo($page = null, string $contentType = self::contentTypes['kubernetesClusterTypesList2'][0])
    {
        $request = $this->kubernetesClusterTypesList2Request($page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedClusterTypeList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedClusterTypeList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedClusterTypeList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedClusterTypeList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedClusterTypeList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClusterTypesList2Async
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClusterTypesList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClusterTypesList2Async($page = null, string $contentType = self::contentTypes['kubernetesClusterTypesList2'][0])
    {
        return $this->kubernetesClusterTypesList2AsyncWithHttpInfo($page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClusterTypesList2AsyncWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClusterTypesList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClusterTypesList2AsyncWithHttpInfo($page = null, string $contentType = self::contentTypes['kubernetesClusterTypesList2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedClusterTypeList';
        $request = $this->kubernetesClusterTypesList2Request($page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClusterTypesList2'
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClusterTypesList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClusterTypesList2Request($page = null, string $contentType = self::contentTypes['kubernetesClusterTypesList2'][0])
    {



        $resourcePath = '/api/v1/kubernetes/cluster-types/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersConnectVmCreate
     *
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\ConnectVMRequest $connect_vm_request connect_vm_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersConnectVmCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ConnectVMResponse
     */
    public function kubernetesClustersConnectVmCreate($id, $connect_vm_request, string $contentType = self::contentTypes['kubernetesClustersConnectVmCreate'][0])
    {
        list($response) = $this->kubernetesClustersConnectVmCreateWithHttpInfo($id, $connect_vm_request, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersConnectVmCreateWithHttpInfo
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\ConnectVMRequest $connect_vm_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersConnectVmCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ConnectVMResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersConnectVmCreateWithHttpInfo($id, $connect_vm_request, string $contentType = self::contentTypes['kubernetesClustersConnectVmCreate'][0])
    {
        $request = $this->kubernetesClustersConnectVmCreateRequest($id, $connect_vm_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\ConnectVMResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ConnectVMResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ConnectVMResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ConnectVMResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ConnectVMResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersConnectVmCreateAsync
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\ConnectVMRequest $connect_vm_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersConnectVmCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersConnectVmCreateAsync($id, $connect_vm_request, string $contentType = self::contentTypes['kubernetesClustersConnectVmCreate'][0])
    {
        return $this->kubernetesClustersConnectVmCreateAsyncWithHttpInfo($id, $connect_vm_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersConnectVmCreateAsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\ConnectVMRequest $connect_vm_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersConnectVmCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersConnectVmCreateAsyncWithHttpInfo($id, $connect_vm_request, string $contentType = self::contentTypes['kubernetesClustersConnectVmCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ConnectVMResponse';
        $request = $this->kubernetesClustersConnectVmCreateRequest($id, $connect_vm_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersConnectVmCreate'
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\ConnectVMRequest $connect_vm_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersConnectVmCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersConnectVmCreateRequest($id, $connect_vm_request, string $contentType = self::contentTypes['kubernetesClustersConnectVmCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersConnectVmCreate'
            );
        }

        // verify the required parameter 'connect_vm_request' is set
        if ($connect_vm_request === null || (is_array($connect_vm_request) && count($connect_vm_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $connect_vm_request when calling kubernetesClustersConnectVmCreate'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{id}/connect-vm/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($connect_vm_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($connect_vm_request));
            } else {
                $httpBody = $connect_vm_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersConnectVmCreate2
     *
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\ConnectVMRequest $connect_vm_request connect_vm_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersConnectVmCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ConnectVMResponse
     */
    public function kubernetesClustersConnectVmCreate2($id, $connect_vm_request, string $contentType = self::contentTypes['kubernetesClustersConnectVmCreate2'][0])
    {
        list($response) = $this->kubernetesClustersConnectVmCreate2WithHttpInfo($id, $connect_vm_request, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersConnectVmCreate2WithHttpInfo
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\ConnectVMRequest $connect_vm_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersConnectVmCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ConnectVMResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersConnectVmCreate2WithHttpInfo($id, $connect_vm_request, string $contentType = self::contentTypes['kubernetesClustersConnectVmCreate2'][0])
    {
        $request = $this->kubernetesClustersConnectVmCreate2Request($id, $connect_vm_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\ConnectVMResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ConnectVMResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ConnectVMResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ConnectVMResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ConnectVMResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersConnectVmCreate2Async
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\ConnectVMRequest $connect_vm_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersConnectVmCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersConnectVmCreate2Async($id, $connect_vm_request, string $contentType = self::contentTypes['kubernetesClustersConnectVmCreate2'][0])
    {
        return $this->kubernetesClustersConnectVmCreate2AsyncWithHttpInfo($id, $connect_vm_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersConnectVmCreate2AsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\ConnectVMRequest $connect_vm_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersConnectVmCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersConnectVmCreate2AsyncWithHttpInfo($id, $connect_vm_request, string $contentType = self::contentTypes['kubernetesClustersConnectVmCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ConnectVMResponse';
        $request = $this->kubernetesClustersConnectVmCreate2Request($id, $connect_vm_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersConnectVmCreate2'
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\ConnectVMRequest $connect_vm_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersConnectVmCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersConnectVmCreate2Request($id, $connect_vm_request, string $contentType = self::contentTypes['kubernetesClustersConnectVmCreate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersConnectVmCreate2'
            );
        }

        // verify the required parameter 'connect_vm_request' is set
        if ($connect_vm_request === null || (is_array($connect_vm_request) && count($connect_vm_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $connect_vm_request when calling kubernetesClustersConnectVmCreate2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{id}/connect-vm/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($connect_vm_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($connect_vm_request));
            } else {
                $httpBody = $connect_vm_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersConnectedVmsRetrieve
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersConnectedVmsRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ConnectedVMsResponse
     */
    public function kubernetesClustersConnectedVmsRetrieve($id, string $contentType = self::contentTypes['kubernetesClustersConnectedVmsRetrieve'][0])
    {
        list($response) = $this->kubernetesClustersConnectedVmsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersConnectedVmsRetrieveWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersConnectedVmsRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ConnectedVMsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersConnectedVmsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersConnectedVmsRetrieve'][0])
    {
        $request = $this->kubernetesClustersConnectedVmsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\ConnectedVMsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ConnectedVMsResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ConnectedVMsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ConnectedVMsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ConnectedVMsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersConnectedVmsRetrieveAsync
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersConnectedVmsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersConnectedVmsRetrieveAsync($id, string $contentType = self::contentTypes['kubernetesClustersConnectedVmsRetrieve'][0])
    {
        return $this->kubernetesClustersConnectedVmsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersConnectedVmsRetrieveAsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersConnectedVmsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersConnectedVmsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersConnectedVmsRetrieve'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ConnectedVMsResponse';
        $request = $this->kubernetesClustersConnectedVmsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersConnectedVmsRetrieve'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersConnectedVmsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersConnectedVmsRetrieveRequest($id, string $contentType = self::contentTypes['kubernetesClustersConnectedVmsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersConnectedVmsRetrieve'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{id}/connected-vms/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersConnectedVmsRetrieve2
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersConnectedVmsRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ConnectedVMsResponse
     */
    public function kubernetesClustersConnectedVmsRetrieve2($id, string $contentType = self::contentTypes['kubernetesClustersConnectedVmsRetrieve2'][0])
    {
        list($response) = $this->kubernetesClustersConnectedVmsRetrieve2WithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersConnectedVmsRetrieve2WithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersConnectedVmsRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ConnectedVMsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersConnectedVmsRetrieve2WithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersConnectedVmsRetrieve2'][0])
    {
        $request = $this->kubernetesClustersConnectedVmsRetrieve2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\ConnectedVMsResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ConnectedVMsResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ConnectedVMsResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ConnectedVMsResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ConnectedVMsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersConnectedVmsRetrieve2Async
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersConnectedVmsRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersConnectedVmsRetrieve2Async($id, string $contentType = self::contentTypes['kubernetesClustersConnectedVmsRetrieve2'][0])
    {
        return $this->kubernetesClustersConnectedVmsRetrieve2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersConnectedVmsRetrieve2AsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersConnectedVmsRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersConnectedVmsRetrieve2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersConnectedVmsRetrieve2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ConnectedVMsResponse';
        $request = $this->kubernetesClustersConnectedVmsRetrieve2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersConnectedVmsRetrieve2'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersConnectedVmsRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersConnectedVmsRetrieve2Request($id, string $contentType = self::contentTypes['kubernetesClustersConnectedVmsRetrieve2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersConnectedVmsRetrieve2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{id}/connected-vms/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersCreate
     *
     * @param  \PidginHost\\Sdk\Model\ClusterAdd $cluster_add cluster_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ClusterAddResponse
     */
    public function kubernetesClustersCreate($cluster_add, string $contentType = self::contentTypes['kubernetesClustersCreate'][0])
    {
        list($response) = $this->kubernetesClustersCreateWithHttpInfo($cluster_add, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersCreateWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\ClusterAdd $cluster_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ClusterAddResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersCreateWithHttpInfo($cluster_add, string $contentType = self::contentTypes['kubernetesClustersCreate'][0])
    {
        $request = $this->kubernetesClustersCreateRequest($cluster_add, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\ClusterAddResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ClusterAddResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ClusterAddResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ClusterAddResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ClusterAddResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersCreateAsync
     *
     * @param  \PidginHost\\Sdk\Model\ClusterAdd $cluster_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersCreateAsync($cluster_add, string $contentType = self::contentTypes['kubernetesClustersCreate'][0])
    {
        return $this->kubernetesClustersCreateAsyncWithHttpInfo($cluster_add, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersCreateAsyncWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\ClusterAdd $cluster_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersCreateAsyncWithHttpInfo($cluster_add, string $contentType = self::contentTypes['kubernetesClustersCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ClusterAddResponse';
        $request = $this->kubernetesClustersCreateRequest($cluster_add, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersCreate'
     *
     * @param  \PidginHost\\Sdk\Model\ClusterAdd $cluster_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersCreateRequest($cluster_add, string $contentType = self::contentTypes['kubernetesClustersCreate'][0])
    {

        // verify the required parameter 'cluster_add' is set
        if ($cluster_add === null || (is_array($cluster_add) && count($cluster_add) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_add when calling kubernetesClustersCreate'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($cluster_add)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($cluster_add));
            } else {
                $httpBody = $cluster_add;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersCreate2
     *
     * @param  \PidginHost\\Sdk\Model\ClusterAdd $cluster_add cluster_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ClusterAddResponse
     */
    public function kubernetesClustersCreate2($cluster_add, string $contentType = self::contentTypes['kubernetesClustersCreate2'][0])
    {
        list($response) = $this->kubernetesClustersCreate2WithHttpInfo($cluster_add, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersCreate2WithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\ClusterAdd $cluster_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ClusterAddResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersCreate2WithHttpInfo($cluster_add, string $contentType = self::contentTypes['kubernetesClustersCreate2'][0])
    {
        $request = $this->kubernetesClustersCreate2Request($cluster_add, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\ClusterAddResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ClusterAddResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ClusterAddResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ClusterAddResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ClusterAddResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersCreate2Async
     *
     * @param  \PidginHost\\Sdk\Model\ClusterAdd $cluster_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersCreate2Async($cluster_add, string $contentType = self::contentTypes['kubernetesClustersCreate2'][0])
    {
        return $this->kubernetesClustersCreate2AsyncWithHttpInfo($cluster_add, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersCreate2AsyncWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\ClusterAdd $cluster_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersCreate2AsyncWithHttpInfo($cluster_add, string $contentType = self::contentTypes['kubernetesClustersCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ClusterAddResponse';
        $request = $this->kubernetesClustersCreate2Request($cluster_add, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersCreate2'
     *
     * @param  \PidginHost\\Sdk\Model\ClusterAdd $cluster_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersCreate2Request($cluster_add, string $contentType = self::contentTypes['kubernetesClustersCreate2'][0])
    {

        // verify the required parameter 'cluster_add' is set
        if ($cluster_add === null || (is_array($cluster_add) && count($cluster_add) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_add when calling kubernetesClustersCreate2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($cluster_add)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($cluster_add));
            } else {
                $httpBody = $cluster_add;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersDestroy
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersDestroy($id, string $contentType = self::contentTypes['kubernetesClustersDestroy'][0])
    {
        $this->kubernetesClustersDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation kubernetesClustersDestroyWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersDestroyWithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersDestroy'][0])
    {
        $request = $this->kubernetesClustersDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersDestroyAsync
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersDestroyAsync($id, string $contentType = self::contentTypes['kubernetesClustersDestroy'][0])
    {
        return $this->kubernetesClustersDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersDestroyAsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersDestroy'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersDestroy'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersDestroyRequest($id, string $contentType = self::contentTypes['kubernetesClustersDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersDestroy'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersDestroy2
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersDestroy2($id, string $contentType = self::contentTypes['kubernetesClustersDestroy2'][0])
    {
        $this->kubernetesClustersDestroy2WithHttpInfo($id, $contentType);
    }

    /**
     * Operation kubernetesClustersDestroy2WithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersDestroy2WithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersDestroy2'][0])
    {
        $request = $this->kubernetesClustersDestroy2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersDestroy2Async
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersDestroy2Async($id, string $contentType = self::contentTypes['kubernetesClustersDestroy2'][0])
    {
        return $this->kubernetesClustersDestroy2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersDestroy2AsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersDestroy2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersDestroy2'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersDestroy2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersDestroy2'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersDestroy2Request($id, string $contentType = self::contentTypes['kubernetesClustersDestroy2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersDestroy2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersDisconnectVmCreate
     *
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\DisconnectVMRequest $disconnect_vm_request disconnect_vm_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersDisconnectVmCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\DisconnectVMResponse
     */
    public function kubernetesClustersDisconnectVmCreate($id, $disconnect_vm_request, string $contentType = self::contentTypes['kubernetesClustersDisconnectVmCreate'][0])
    {
        list($response) = $this->kubernetesClustersDisconnectVmCreateWithHttpInfo($id, $disconnect_vm_request, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersDisconnectVmCreateWithHttpInfo
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\DisconnectVMRequest $disconnect_vm_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersDisconnectVmCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\DisconnectVMResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersDisconnectVmCreateWithHttpInfo($id, $disconnect_vm_request, string $contentType = self::contentTypes['kubernetesClustersDisconnectVmCreate'][0])
    {
        $request = $this->kubernetesClustersDisconnectVmCreateRequest($id, $disconnect_vm_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\DisconnectVMResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\DisconnectVMResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\DisconnectVMResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\DisconnectVMResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\DisconnectVMResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersDisconnectVmCreateAsync
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\DisconnectVMRequest $disconnect_vm_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersDisconnectVmCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersDisconnectVmCreateAsync($id, $disconnect_vm_request, string $contentType = self::contentTypes['kubernetesClustersDisconnectVmCreate'][0])
    {
        return $this->kubernetesClustersDisconnectVmCreateAsyncWithHttpInfo($id, $disconnect_vm_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersDisconnectVmCreateAsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\DisconnectVMRequest $disconnect_vm_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersDisconnectVmCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersDisconnectVmCreateAsyncWithHttpInfo($id, $disconnect_vm_request, string $contentType = self::contentTypes['kubernetesClustersDisconnectVmCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\DisconnectVMResponse';
        $request = $this->kubernetesClustersDisconnectVmCreateRequest($id, $disconnect_vm_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersDisconnectVmCreate'
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\DisconnectVMRequest $disconnect_vm_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersDisconnectVmCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersDisconnectVmCreateRequest($id, $disconnect_vm_request, string $contentType = self::contentTypes['kubernetesClustersDisconnectVmCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersDisconnectVmCreate'
            );
        }

        // verify the required parameter 'disconnect_vm_request' is set
        if ($disconnect_vm_request === null || (is_array($disconnect_vm_request) && count($disconnect_vm_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $disconnect_vm_request when calling kubernetesClustersDisconnectVmCreate'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{id}/disconnect-vm/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($disconnect_vm_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($disconnect_vm_request));
            } else {
                $httpBody = $disconnect_vm_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersDisconnectVmCreate2
     *
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\DisconnectVMRequest $disconnect_vm_request disconnect_vm_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersDisconnectVmCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\DisconnectVMResponse
     */
    public function kubernetesClustersDisconnectVmCreate2($id, $disconnect_vm_request, string $contentType = self::contentTypes['kubernetesClustersDisconnectVmCreate2'][0])
    {
        list($response) = $this->kubernetesClustersDisconnectVmCreate2WithHttpInfo($id, $disconnect_vm_request, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersDisconnectVmCreate2WithHttpInfo
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\DisconnectVMRequest $disconnect_vm_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersDisconnectVmCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\DisconnectVMResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersDisconnectVmCreate2WithHttpInfo($id, $disconnect_vm_request, string $contentType = self::contentTypes['kubernetesClustersDisconnectVmCreate2'][0])
    {
        $request = $this->kubernetesClustersDisconnectVmCreate2Request($id, $disconnect_vm_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\DisconnectVMResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\DisconnectVMResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\DisconnectVMResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\DisconnectVMResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\DisconnectVMResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersDisconnectVmCreate2Async
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\DisconnectVMRequest $disconnect_vm_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersDisconnectVmCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersDisconnectVmCreate2Async($id, $disconnect_vm_request, string $contentType = self::contentTypes['kubernetesClustersDisconnectVmCreate2'][0])
    {
        return $this->kubernetesClustersDisconnectVmCreate2AsyncWithHttpInfo($id, $disconnect_vm_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersDisconnectVmCreate2AsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\DisconnectVMRequest $disconnect_vm_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersDisconnectVmCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersDisconnectVmCreate2AsyncWithHttpInfo($id, $disconnect_vm_request, string $contentType = self::contentTypes['kubernetesClustersDisconnectVmCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\DisconnectVMResponse';
        $request = $this->kubernetesClustersDisconnectVmCreate2Request($id, $disconnect_vm_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersDisconnectVmCreate2'
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\DisconnectVMRequest $disconnect_vm_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersDisconnectVmCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersDisconnectVmCreate2Request($id, $disconnect_vm_request, string $contentType = self::contentTypes['kubernetesClustersDisconnectVmCreate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersDisconnectVmCreate2'
            );
        }

        // verify the required parameter 'disconnect_vm_request' is set
        if ($disconnect_vm_request === null || (is_array($disconnect_vm_request) && count($disconnect_vm_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $disconnect_vm_request when calling kubernetesClustersDisconnectVmCreate2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{id}/disconnect-vm/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($disconnect_vm_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($disconnect_vm_request));
            } else {
                $httpBody = $disconnect_vm_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersHttproutesCreate
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\HTTPRoute $http_route http_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\HTTPRoute
     */
    public function kubernetesClustersHttproutesCreate($cluster_id, $http_route, string $contentType = self::contentTypes['kubernetesClustersHttproutesCreate'][0])
    {
        list($response) = $this->kubernetesClustersHttproutesCreateWithHttpInfo($cluster_id, $http_route, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersHttproutesCreateWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\HTTPRoute $http_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\HTTPRoute, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersHttproutesCreateWithHttpInfo($cluster_id, $http_route, string $contentType = self::contentTypes['kubernetesClustersHttproutesCreate'][0])
    {
        $request = $this->kubernetesClustersHttproutesCreateRequest($cluster_id, $http_route, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\HTTPRoute' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\HTTPRoute' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\HTTPRoute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\HTTPRoute';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\HTTPRoute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersHttproutesCreateAsync
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\HTTPRoute $http_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersHttproutesCreateAsync($cluster_id, $http_route, string $contentType = self::contentTypes['kubernetesClustersHttproutesCreate'][0])
    {
        return $this->kubernetesClustersHttproutesCreateAsyncWithHttpInfo($cluster_id, $http_route, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersHttproutesCreateAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\HTTPRoute $http_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersHttproutesCreateAsyncWithHttpInfo($cluster_id, $http_route, string $contentType = self::contentTypes['kubernetesClustersHttproutesCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\HTTPRoute';
        $request = $this->kubernetesClustersHttproutesCreateRequest($cluster_id, $http_route, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersHttproutesCreate'
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\HTTPRoute $http_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersHttproutesCreateRequest($cluster_id, $http_route, string $contentType = self::contentTypes['kubernetesClustersHttproutesCreate'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersHttproutesCreate'
            );
        }

        // verify the required parameter 'http_route' is set
        if ($http_route === null || (is_array($http_route) && count($http_route) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $http_route when calling kubernetesClustersHttproutesCreate'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/httproutes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($http_route)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($http_route));
            } else {
                $httpBody = $http_route;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersHttproutesCreate2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\HTTPRoute $http_route http_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\HTTPRoute
     */
    public function kubernetesClustersHttproutesCreate2($cluster_id, $http_route, string $contentType = self::contentTypes['kubernetesClustersHttproutesCreate2'][0])
    {
        list($response) = $this->kubernetesClustersHttproutesCreate2WithHttpInfo($cluster_id, $http_route, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersHttproutesCreate2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\HTTPRoute $http_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\HTTPRoute, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersHttproutesCreate2WithHttpInfo($cluster_id, $http_route, string $contentType = self::contentTypes['kubernetesClustersHttproutesCreate2'][0])
    {
        $request = $this->kubernetesClustersHttproutesCreate2Request($cluster_id, $http_route, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\HTTPRoute' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\HTTPRoute' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\HTTPRoute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\HTTPRoute';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\HTTPRoute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersHttproutesCreate2Async
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\HTTPRoute $http_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersHttproutesCreate2Async($cluster_id, $http_route, string $contentType = self::contentTypes['kubernetesClustersHttproutesCreate2'][0])
    {
        return $this->kubernetesClustersHttproutesCreate2AsyncWithHttpInfo($cluster_id, $http_route, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersHttproutesCreate2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\HTTPRoute $http_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersHttproutesCreate2AsyncWithHttpInfo($cluster_id, $http_route, string $contentType = self::contentTypes['kubernetesClustersHttproutesCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\HTTPRoute';
        $request = $this->kubernetesClustersHttproutesCreate2Request($cluster_id, $http_route, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersHttproutesCreate2'
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\HTTPRoute $http_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersHttproutesCreate2Request($cluster_id, $http_route, string $contentType = self::contentTypes['kubernetesClustersHttproutesCreate2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersHttproutesCreate2'
            );
        }

        // verify the required parameter 'http_route' is set
        if ($http_route === null || (is_array($http_route) && count($http_route) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $http_route when calling kubernetesClustersHttproutesCreate2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/httproutes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($http_route)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($http_route));
            } else {
                $httpBody = $http_route;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersHttproutesDestroy
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersHttproutesDestroy($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersHttproutesDestroy'][0])
    {
        $this->kubernetesClustersHttproutesDestroyWithHttpInfo($cluster_id, $id, $contentType);
    }

    /**
     * Operation kubernetesClustersHttproutesDestroyWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersHttproutesDestroyWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersHttproutesDestroy'][0])
    {
        $request = $this->kubernetesClustersHttproutesDestroyRequest($cluster_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersHttproutesDestroyAsync
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersHttproutesDestroyAsync($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersHttproutesDestroy'][0])
    {
        return $this->kubernetesClustersHttproutesDestroyAsyncWithHttpInfo($cluster_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersHttproutesDestroyAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersHttproutesDestroyAsyncWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersHttproutesDestroy'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersHttproutesDestroyRequest($cluster_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersHttproutesDestroy'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersHttproutesDestroyRequest($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersHttproutesDestroy'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersHttproutesDestroy'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersHttproutesDestroy'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/httproutes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersHttproutesDestroy2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersHttproutesDestroy2($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersHttproutesDestroy2'][0])
    {
        $this->kubernetesClustersHttproutesDestroy2WithHttpInfo($cluster_id, $id, $contentType);
    }

    /**
     * Operation kubernetesClustersHttproutesDestroy2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersHttproutesDestroy2WithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersHttproutesDestroy2'][0])
    {
        $request = $this->kubernetesClustersHttproutesDestroy2Request($cluster_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersHttproutesDestroy2Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersHttproutesDestroy2Async($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersHttproutesDestroy2'][0])
    {
        return $this->kubernetesClustersHttproutesDestroy2AsyncWithHttpInfo($cluster_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersHttproutesDestroy2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersHttproutesDestroy2AsyncWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersHttproutesDestroy2'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersHttproutesDestroy2Request($cluster_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersHttproutesDestroy2'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersHttproutesDestroy2Request($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersHttproutesDestroy2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersHttproutesDestroy2'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersHttproutesDestroy2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/httproutes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersHttproutesPartialUpdate
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedHTTPRoute|null $patched_http_route patched_http_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\HTTPRoute
     */
    public function kubernetesClustersHttproutesPartialUpdate($cluster_id, $id, $patched_http_route = null, string $contentType = self::contentTypes['kubernetesClustersHttproutesPartialUpdate'][0])
    {
        list($response) = $this->kubernetesClustersHttproutesPartialUpdateWithHttpInfo($cluster_id, $id, $patched_http_route, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersHttproutesPartialUpdateWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedHTTPRoute|null $patched_http_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\HTTPRoute, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersHttproutesPartialUpdateWithHttpInfo($cluster_id, $id, $patched_http_route = null, string $contentType = self::contentTypes['kubernetesClustersHttproutesPartialUpdate'][0])
    {
        $request = $this->kubernetesClustersHttproutesPartialUpdateRequest($cluster_id, $id, $patched_http_route, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\HTTPRoute' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\HTTPRoute' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\HTTPRoute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\HTTPRoute';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\HTTPRoute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersHttproutesPartialUpdateAsync
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedHTTPRoute|null $patched_http_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersHttproutesPartialUpdateAsync($cluster_id, $id, $patched_http_route = null, string $contentType = self::contentTypes['kubernetesClustersHttproutesPartialUpdate'][0])
    {
        return $this->kubernetesClustersHttproutesPartialUpdateAsyncWithHttpInfo($cluster_id, $id, $patched_http_route, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersHttproutesPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedHTTPRoute|null $patched_http_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersHttproutesPartialUpdateAsyncWithHttpInfo($cluster_id, $id, $patched_http_route = null, string $contentType = self::contentTypes['kubernetesClustersHttproutesPartialUpdate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\HTTPRoute';
        $request = $this->kubernetesClustersHttproutesPartialUpdateRequest($cluster_id, $id, $patched_http_route, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersHttproutesPartialUpdate'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedHTTPRoute|null $patched_http_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersHttproutesPartialUpdateRequest($cluster_id, $id, $patched_http_route = null, string $contentType = self::contentTypes['kubernetesClustersHttproutesPartialUpdate'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersHttproutesPartialUpdate'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersHttproutesPartialUpdate'
            );
        }



        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/httproutes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_http_route)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_http_route));
            } else {
                $httpBody = $patched_http_route;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersHttproutesPartialUpdate2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedHTTPRoute|null $patched_http_route patched_http_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\HTTPRoute
     */
    public function kubernetesClustersHttproutesPartialUpdate2($cluster_id, $id, $patched_http_route = null, string $contentType = self::contentTypes['kubernetesClustersHttproutesPartialUpdate2'][0])
    {
        list($response) = $this->kubernetesClustersHttproutesPartialUpdate2WithHttpInfo($cluster_id, $id, $patched_http_route, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersHttproutesPartialUpdate2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedHTTPRoute|null $patched_http_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\HTTPRoute, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersHttproutesPartialUpdate2WithHttpInfo($cluster_id, $id, $patched_http_route = null, string $contentType = self::contentTypes['kubernetesClustersHttproutesPartialUpdate2'][0])
    {
        $request = $this->kubernetesClustersHttproutesPartialUpdate2Request($cluster_id, $id, $patched_http_route, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\HTTPRoute' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\HTTPRoute' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\HTTPRoute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\HTTPRoute';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\HTTPRoute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersHttproutesPartialUpdate2Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedHTTPRoute|null $patched_http_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersHttproutesPartialUpdate2Async($cluster_id, $id, $patched_http_route = null, string $contentType = self::contentTypes['kubernetesClustersHttproutesPartialUpdate2'][0])
    {
        return $this->kubernetesClustersHttproutesPartialUpdate2AsyncWithHttpInfo($cluster_id, $id, $patched_http_route, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersHttproutesPartialUpdate2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedHTTPRoute|null $patched_http_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersHttproutesPartialUpdate2AsyncWithHttpInfo($cluster_id, $id, $patched_http_route = null, string $contentType = self::contentTypes['kubernetesClustersHttproutesPartialUpdate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\HTTPRoute';
        $request = $this->kubernetesClustersHttproutesPartialUpdate2Request($cluster_id, $id, $patched_http_route, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersHttproutesPartialUpdate2'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedHTTPRoute|null $patched_http_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersHttproutesPartialUpdate2Request($cluster_id, $id, $patched_http_route = null, string $contentType = self::contentTypes['kubernetesClustersHttproutesPartialUpdate2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersHttproutesPartialUpdate2'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersHttproutesPartialUpdate2'
            );
        }



        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/httproutes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_http_route)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_http_route));
            } else {
                $httpBody = $patched_http_route;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersHttproutesRetrieve
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersHttproutesRetrieve($cluster_id, string $contentType = self::contentTypes['kubernetesClustersHttproutesRetrieve'][0])
    {
        $this->kubernetesClustersHttproutesRetrieveWithHttpInfo($cluster_id, $contentType);
    }

    /**
     * Operation kubernetesClustersHttproutesRetrieveWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersHttproutesRetrieveWithHttpInfo($cluster_id, string $contentType = self::contentTypes['kubernetesClustersHttproutesRetrieve'][0])
    {
        $request = $this->kubernetesClustersHttproutesRetrieveRequest($cluster_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersHttproutesRetrieveAsync
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersHttproutesRetrieveAsync($cluster_id, string $contentType = self::contentTypes['kubernetesClustersHttproutesRetrieve'][0])
    {
        return $this->kubernetesClustersHttproutesRetrieveAsyncWithHttpInfo($cluster_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersHttproutesRetrieveAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersHttproutesRetrieveAsyncWithHttpInfo($cluster_id, string $contentType = self::contentTypes['kubernetesClustersHttproutesRetrieve'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersHttproutesRetrieveRequest($cluster_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersHttproutesRetrieve'
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersHttproutesRetrieveRequest($cluster_id, string $contentType = self::contentTypes['kubernetesClustersHttproutesRetrieve'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersHttproutesRetrieve'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/httproutes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersHttproutesRetrieve2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersHttproutesRetrieve2($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersHttproutesRetrieve2'][0])
    {
        $this->kubernetesClustersHttproutesRetrieve2WithHttpInfo($cluster_id, $id, $contentType);
    }

    /**
     * Operation kubernetesClustersHttproutesRetrieve2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersHttproutesRetrieve2WithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersHttproutesRetrieve2'][0])
    {
        $request = $this->kubernetesClustersHttproutesRetrieve2Request($cluster_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersHttproutesRetrieve2Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersHttproutesRetrieve2Async($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersHttproutesRetrieve2'][0])
    {
        return $this->kubernetesClustersHttproutesRetrieve2AsyncWithHttpInfo($cluster_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersHttproutesRetrieve2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersHttproutesRetrieve2AsyncWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersHttproutesRetrieve2'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersHttproutesRetrieve2Request($cluster_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersHttproutesRetrieve2'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersHttproutesRetrieve2Request($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersHttproutesRetrieve2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersHttproutesRetrieve2'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersHttproutesRetrieve2'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/httproutes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersHttproutesRetrieve3
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesRetrieve3'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersHttproutesRetrieve3($cluster_id, string $contentType = self::contentTypes['kubernetesClustersHttproutesRetrieve3'][0])
    {
        $this->kubernetesClustersHttproutesRetrieve3WithHttpInfo($cluster_id, $contentType);
    }

    /**
     * Operation kubernetesClustersHttproutesRetrieve3WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesRetrieve3'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersHttproutesRetrieve3WithHttpInfo($cluster_id, string $contentType = self::contentTypes['kubernetesClustersHttproutesRetrieve3'][0])
    {
        $request = $this->kubernetesClustersHttproutesRetrieve3Request($cluster_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersHttproutesRetrieve3Async
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesRetrieve3'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersHttproutesRetrieve3Async($cluster_id, string $contentType = self::contentTypes['kubernetesClustersHttproutesRetrieve3'][0])
    {
        return $this->kubernetesClustersHttproutesRetrieve3AsyncWithHttpInfo($cluster_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersHttproutesRetrieve3AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesRetrieve3'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersHttproutesRetrieve3AsyncWithHttpInfo($cluster_id, string $contentType = self::contentTypes['kubernetesClustersHttproutesRetrieve3'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersHttproutesRetrieve3Request($cluster_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersHttproutesRetrieve3'
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesRetrieve3'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersHttproutesRetrieve3Request($cluster_id, string $contentType = self::contentTypes['kubernetesClustersHttproutesRetrieve3'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersHttproutesRetrieve3'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/httproutes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersHttproutesRetrieve4
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesRetrieve4'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersHttproutesRetrieve4($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersHttproutesRetrieve4'][0])
    {
        $this->kubernetesClustersHttproutesRetrieve4WithHttpInfo($cluster_id, $id, $contentType);
    }

    /**
     * Operation kubernetesClustersHttproutesRetrieve4WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesRetrieve4'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersHttproutesRetrieve4WithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersHttproutesRetrieve4'][0])
    {
        $request = $this->kubernetesClustersHttproutesRetrieve4Request($cluster_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersHttproutesRetrieve4Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesRetrieve4'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersHttproutesRetrieve4Async($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersHttproutesRetrieve4'][0])
    {
        return $this->kubernetesClustersHttproutesRetrieve4AsyncWithHttpInfo($cluster_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersHttproutesRetrieve4AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesRetrieve4'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersHttproutesRetrieve4AsyncWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersHttproutesRetrieve4'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersHttproutesRetrieve4Request($cluster_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersHttproutesRetrieve4'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesRetrieve4'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersHttproutesRetrieve4Request($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersHttproutesRetrieve4'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersHttproutesRetrieve4'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersHttproutesRetrieve4'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/httproutes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersHttproutesUpdate
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\HTTPRoute $http_route http_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\HTTPRoute
     */
    public function kubernetesClustersHttproutesUpdate($cluster_id, $id, $http_route, string $contentType = self::contentTypes['kubernetesClustersHttproutesUpdate'][0])
    {
        list($response) = $this->kubernetesClustersHttproutesUpdateWithHttpInfo($cluster_id, $id, $http_route, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersHttproutesUpdateWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\HTTPRoute $http_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\HTTPRoute, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersHttproutesUpdateWithHttpInfo($cluster_id, $id, $http_route, string $contentType = self::contentTypes['kubernetesClustersHttproutesUpdate'][0])
    {
        $request = $this->kubernetesClustersHttproutesUpdateRequest($cluster_id, $id, $http_route, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\HTTPRoute' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\HTTPRoute' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\HTTPRoute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\HTTPRoute';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\HTTPRoute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersHttproutesUpdateAsync
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\HTTPRoute $http_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersHttproutesUpdateAsync($cluster_id, $id, $http_route, string $contentType = self::contentTypes['kubernetesClustersHttproutesUpdate'][0])
    {
        return $this->kubernetesClustersHttproutesUpdateAsyncWithHttpInfo($cluster_id, $id, $http_route, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersHttproutesUpdateAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\HTTPRoute $http_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersHttproutesUpdateAsyncWithHttpInfo($cluster_id, $id, $http_route, string $contentType = self::contentTypes['kubernetesClustersHttproutesUpdate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\HTTPRoute';
        $request = $this->kubernetesClustersHttproutesUpdateRequest($cluster_id, $id, $http_route, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersHttproutesUpdate'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\HTTPRoute $http_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersHttproutesUpdateRequest($cluster_id, $id, $http_route, string $contentType = self::contentTypes['kubernetesClustersHttproutesUpdate'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersHttproutesUpdate'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersHttproutesUpdate'
            );
        }

        // verify the required parameter 'http_route' is set
        if ($http_route === null || (is_array($http_route) && count($http_route) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $http_route when calling kubernetesClustersHttproutesUpdate'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/httproutes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($http_route)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($http_route));
            } else {
                $httpBody = $http_route;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersHttproutesUpdate2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\HTTPRoute $http_route http_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\HTTPRoute
     */
    public function kubernetesClustersHttproutesUpdate2($cluster_id, $id, $http_route, string $contentType = self::contentTypes['kubernetesClustersHttproutesUpdate2'][0])
    {
        list($response) = $this->kubernetesClustersHttproutesUpdate2WithHttpInfo($cluster_id, $id, $http_route, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersHttproutesUpdate2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\HTTPRoute $http_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\HTTPRoute, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersHttproutesUpdate2WithHttpInfo($cluster_id, $id, $http_route, string $contentType = self::contentTypes['kubernetesClustersHttproutesUpdate2'][0])
    {
        $request = $this->kubernetesClustersHttproutesUpdate2Request($cluster_id, $id, $http_route, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\HTTPRoute' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\HTTPRoute' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\HTTPRoute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\HTTPRoute';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\HTTPRoute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersHttproutesUpdate2Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\HTTPRoute $http_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersHttproutesUpdate2Async($cluster_id, $id, $http_route, string $contentType = self::contentTypes['kubernetesClustersHttproutesUpdate2'][0])
    {
        return $this->kubernetesClustersHttproutesUpdate2AsyncWithHttpInfo($cluster_id, $id, $http_route, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersHttproutesUpdate2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\HTTPRoute $http_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersHttproutesUpdate2AsyncWithHttpInfo($cluster_id, $id, $http_route, string $contentType = self::contentTypes['kubernetesClustersHttproutesUpdate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\HTTPRoute';
        $request = $this->kubernetesClustersHttproutesUpdate2Request($cluster_id, $id, $http_route, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersHttproutesUpdate2'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\HTTPRoute $http_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersHttproutesUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersHttproutesUpdate2Request($cluster_id, $id, $http_route, string $contentType = self::contentTypes['kubernetesClustersHttproutesUpdate2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersHttproutesUpdate2'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersHttproutesUpdate2'
            );
        }

        // verify the required parameter 'http_route' is set
        if ($http_route === null || (is_array($http_route) && count($http_route) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $http_route when calling kubernetesClustersHttproutesUpdate2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/httproutes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($http_route)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($http_route));
            } else {
                $httpBody = $http_route;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersKubeVersionUpgradeCreate
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeVersionUpgradeCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\KubeUpgradeResponse
     */
    public function kubernetesClustersKubeVersionUpgradeCreate($id, string $contentType = self::contentTypes['kubernetesClustersKubeVersionUpgradeCreate'][0])
    {
        list($response) = $this->kubernetesClustersKubeVersionUpgradeCreateWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersKubeVersionUpgradeCreateWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeVersionUpgradeCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\KubeUpgradeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersKubeVersionUpgradeCreateWithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersKubeVersionUpgradeCreate'][0])
    {
        $request = $this->kubernetesClustersKubeVersionUpgradeCreateRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\KubeUpgradeResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\KubeUpgradeResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\KubeUpgradeResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\KubeUpgradeResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\KubeUpgradeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersKubeVersionUpgradeCreateAsync
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeVersionUpgradeCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersKubeVersionUpgradeCreateAsync($id, string $contentType = self::contentTypes['kubernetesClustersKubeVersionUpgradeCreate'][0])
    {
        return $this->kubernetesClustersKubeVersionUpgradeCreateAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersKubeVersionUpgradeCreateAsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeVersionUpgradeCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersKubeVersionUpgradeCreateAsyncWithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersKubeVersionUpgradeCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\KubeUpgradeResponse';
        $request = $this->kubernetesClustersKubeVersionUpgradeCreateRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersKubeVersionUpgradeCreate'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeVersionUpgradeCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersKubeVersionUpgradeCreateRequest($id, string $contentType = self::contentTypes['kubernetesClustersKubeVersionUpgradeCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersKubeVersionUpgradeCreate'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{id}/kube-version-upgrade/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersKubeVersionUpgradeCreate2
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeVersionUpgradeCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\KubeUpgradeResponse
     */
    public function kubernetesClustersKubeVersionUpgradeCreate2($id, string $contentType = self::contentTypes['kubernetesClustersKubeVersionUpgradeCreate2'][0])
    {
        list($response) = $this->kubernetesClustersKubeVersionUpgradeCreate2WithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersKubeVersionUpgradeCreate2WithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeVersionUpgradeCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\KubeUpgradeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersKubeVersionUpgradeCreate2WithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersKubeVersionUpgradeCreate2'][0])
    {
        $request = $this->kubernetesClustersKubeVersionUpgradeCreate2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\KubeUpgradeResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\KubeUpgradeResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\KubeUpgradeResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\KubeUpgradeResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\KubeUpgradeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersKubeVersionUpgradeCreate2Async
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeVersionUpgradeCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersKubeVersionUpgradeCreate2Async($id, string $contentType = self::contentTypes['kubernetesClustersKubeVersionUpgradeCreate2'][0])
    {
        return $this->kubernetesClustersKubeVersionUpgradeCreate2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersKubeVersionUpgradeCreate2AsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeVersionUpgradeCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersKubeVersionUpgradeCreate2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersKubeVersionUpgradeCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\KubeUpgradeResponse';
        $request = $this->kubernetesClustersKubeVersionUpgradeCreate2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersKubeVersionUpgradeCreate2'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeVersionUpgradeCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersKubeVersionUpgradeCreate2Request($id, string $contentType = self::contentTypes['kubernetesClustersKubeVersionUpgradeCreate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersKubeVersionUpgradeCreate2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{id}/kube-version-upgrade/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersKubeconfigCreate
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeconfigCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string
     */
    public function kubernetesClustersKubeconfigCreate($id, string $contentType = self::contentTypes['kubernetesClustersKubeconfigCreate'][0])
    {
        list($response) = $this->kubernetesClustersKubeconfigCreateWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersKubeconfigCreateWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeconfigCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersKubeconfigCreateWithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersKubeconfigCreate'][0])
    {
        $request = $this->kubernetesClustersKubeconfigCreateRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersKubeconfigCreateAsync
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeconfigCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersKubeconfigCreateAsync($id, string $contentType = self::contentTypes['kubernetesClustersKubeconfigCreate'][0])
    {
        return $this->kubernetesClustersKubeconfigCreateAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersKubeconfigCreateAsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeconfigCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersKubeconfigCreateAsyncWithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersKubeconfigCreate'][0])
    {
        $returnType = 'string';
        $request = $this->kubernetesClustersKubeconfigCreateRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersKubeconfigCreate'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeconfigCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersKubeconfigCreateRequest($id, string $contentType = self::contentTypes['kubernetesClustersKubeconfigCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersKubeconfigCreate'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{id}/kubeconfig/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersKubeconfigCreate2
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeconfigCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string
     */
    public function kubernetesClustersKubeconfigCreate2($id, string $contentType = self::contentTypes['kubernetesClustersKubeconfigCreate2'][0])
    {
        list($response) = $this->kubernetesClustersKubeconfigCreate2WithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersKubeconfigCreate2WithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeconfigCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersKubeconfigCreate2WithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersKubeconfigCreate2'][0])
    {
        $request = $this->kubernetesClustersKubeconfigCreate2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersKubeconfigCreate2Async
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeconfigCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersKubeconfigCreate2Async($id, string $contentType = self::contentTypes['kubernetesClustersKubeconfigCreate2'][0])
    {
        return $this->kubernetesClustersKubeconfigCreate2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersKubeconfigCreate2AsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeconfigCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersKubeconfigCreate2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersKubeconfigCreate2'][0])
    {
        $returnType = 'string';
        $request = $this->kubernetesClustersKubeconfigCreate2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersKubeconfigCreate2'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeconfigCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersKubeconfigCreate2Request($id, string $contentType = self::contentTypes['kubernetesClustersKubeconfigCreate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersKubeconfigCreate2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{id}/kubeconfig/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersKubeconfigRetrieve
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeconfigRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string
     */
    public function kubernetesClustersKubeconfigRetrieve($id, string $contentType = self::contentTypes['kubernetesClustersKubeconfigRetrieve'][0])
    {
        list($response) = $this->kubernetesClustersKubeconfigRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersKubeconfigRetrieveWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeconfigRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersKubeconfigRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersKubeconfigRetrieve'][0])
    {
        $request = $this->kubernetesClustersKubeconfigRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersKubeconfigRetrieveAsync
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeconfigRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersKubeconfigRetrieveAsync($id, string $contentType = self::contentTypes['kubernetesClustersKubeconfigRetrieve'][0])
    {
        return $this->kubernetesClustersKubeconfigRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersKubeconfigRetrieveAsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeconfigRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersKubeconfigRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersKubeconfigRetrieve'][0])
    {
        $returnType = 'string';
        $request = $this->kubernetesClustersKubeconfigRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersKubeconfigRetrieve'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeconfigRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersKubeconfigRetrieveRequest($id, string $contentType = self::contentTypes['kubernetesClustersKubeconfigRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersKubeconfigRetrieve'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{id}/kubeconfig/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersKubeconfigRetrieve2
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeconfigRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return string
     */
    public function kubernetesClustersKubeconfigRetrieve2($id, string $contentType = self::contentTypes['kubernetesClustersKubeconfigRetrieve2'][0])
    {
        list($response) = $this->kubernetesClustersKubeconfigRetrieve2WithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersKubeconfigRetrieve2WithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeconfigRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersKubeconfigRetrieve2WithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersKubeconfigRetrieve2'][0])
    {
        $request = $this->kubernetesClustersKubeconfigRetrieve2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('string' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('string' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'string', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = 'string';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'string',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersKubeconfigRetrieve2Async
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeconfigRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersKubeconfigRetrieve2Async($id, string $contentType = self::contentTypes['kubernetesClustersKubeconfigRetrieve2'][0])
    {
        return $this->kubernetesClustersKubeconfigRetrieve2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersKubeconfigRetrieve2AsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeconfigRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersKubeconfigRetrieve2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersKubeconfigRetrieve2'][0])
    {
        $returnType = 'string';
        $request = $this->kubernetesClustersKubeconfigRetrieve2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersKubeconfigRetrieve2'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersKubeconfigRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersKubeconfigRetrieve2Request($id, string $contentType = self::contentTypes['kubernetesClustersKubeconfigRetrieve2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersKubeconfigRetrieve2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{id}/kubeconfig/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersList
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedClusterDetailList
     */
    public function kubernetesClustersList($page = null, string $contentType = self::contentTypes['kubernetesClustersList'][0])
    {
        list($response) = $this->kubernetesClustersListWithHttpInfo($page, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersListWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedClusterDetailList, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersListWithHttpInfo($page = null, string $contentType = self::contentTypes['kubernetesClustersList'][0])
    {
        $request = $this->kubernetesClustersListRequest($page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedClusterDetailList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedClusterDetailList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedClusterDetailList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedClusterDetailList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedClusterDetailList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersListAsync
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersListAsync($page = null, string $contentType = self::contentTypes['kubernetesClustersList'][0])
    {
        return $this->kubernetesClustersListAsyncWithHttpInfo($page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersListAsyncWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersListAsyncWithHttpInfo($page = null, string $contentType = self::contentTypes['kubernetesClustersList'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedClusterDetailList';
        $request = $this->kubernetesClustersListRequest($page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersList'
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersListRequest($page = null, string $contentType = self::contentTypes['kubernetesClustersList'][0])
    {



        $resourcePath = '/api/kubernetes/clusters/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersList2
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedClusterDetailList
     */
    public function kubernetesClustersList2($page = null, string $contentType = self::contentTypes['kubernetesClustersList2'][0])
    {
        list($response) = $this->kubernetesClustersList2WithHttpInfo($page, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersList2WithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedClusterDetailList, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersList2WithHttpInfo($page = null, string $contentType = self::contentTypes['kubernetesClustersList2'][0])
    {
        $request = $this->kubernetesClustersList2Request($page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedClusterDetailList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedClusterDetailList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedClusterDetailList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedClusterDetailList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedClusterDetailList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersList2Async
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersList2Async($page = null, string $contentType = self::contentTypes['kubernetesClustersList2'][0])
    {
        return $this->kubernetesClustersList2AsyncWithHttpInfo($page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersList2AsyncWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersList2AsyncWithHttpInfo($page = null, string $contentType = self::contentTypes['kubernetesClustersList2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedClusterDetailList';
        $request = $this->kubernetesClustersList2Request($page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersList2'
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersList2Request($page = null, string $contentType = self::contentTypes['kubernetesClustersList2'][0])
    {



        $resourcePath = '/api/v1/kubernetes/clusters/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersPartialUpdate
     *
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedClusterDetail|null $patched_cluster_detail patched_cluster_detail (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ClusterDetail
     */
    public function kubernetesClustersPartialUpdate($id, $patched_cluster_detail = null, string $contentType = self::contentTypes['kubernetesClustersPartialUpdate'][0])
    {
        list($response) = $this->kubernetesClustersPartialUpdateWithHttpInfo($id, $patched_cluster_detail, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersPartialUpdateWithHttpInfo
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedClusterDetail|null $patched_cluster_detail (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ClusterDetail, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersPartialUpdateWithHttpInfo($id, $patched_cluster_detail = null, string $contentType = self::contentTypes['kubernetesClustersPartialUpdate'][0])
    {
        $request = $this->kubernetesClustersPartialUpdateRequest($id, $patched_cluster_detail, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\ClusterDetail' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ClusterDetail' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ClusterDetail', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ClusterDetail';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ClusterDetail',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersPartialUpdateAsync
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedClusterDetail|null $patched_cluster_detail (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPartialUpdateAsync($id, $patched_cluster_detail = null, string $contentType = self::contentTypes['kubernetesClustersPartialUpdate'][0])
    {
        return $this->kubernetesClustersPartialUpdateAsyncWithHttpInfo($id, $patched_cluster_detail, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersPartialUpdateAsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedClusterDetail|null $patched_cluster_detail (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPartialUpdateAsyncWithHttpInfo($id, $patched_cluster_detail = null, string $contentType = self::contentTypes['kubernetesClustersPartialUpdate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ClusterDetail';
        $request = $this->kubernetesClustersPartialUpdateRequest($id, $patched_cluster_detail, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersPartialUpdate'
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedClusterDetail|null $patched_cluster_detail (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersPartialUpdateRequest($id, $patched_cluster_detail = null, string $contentType = self::contentTypes['kubernetesClustersPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersPartialUpdate'
            );
        }



        $resourcePath = '/api/kubernetes/clusters/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_cluster_detail)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_cluster_detail));
            } else {
                $httpBody = $patched_cluster_detail;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersPartialUpdate2
     *
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedClusterDetail|null $patched_cluster_detail patched_cluster_detail (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ClusterDetail
     */
    public function kubernetesClustersPartialUpdate2($id, $patched_cluster_detail = null, string $contentType = self::contentTypes['kubernetesClustersPartialUpdate2'][0])
    {
        list($response) = $this->kubernetesClustersPartialUpdate2WithHttpInfo($id, $patched_cluster_detail, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersPartialUpdate2WithHttpInfo
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedClusterDetail|null $patched_cluster_detail (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ClusterDetail, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersPartialUpdate2WithHttpInfo($id, $patched_cluster_detail = null, string $contentType = self::contentTypes['kubernetesClustersPartialUpdate2'][0])
    {
        $request = $this->kubernetesClustersPartialUpdate2Request($id, $patched_cluster_detail, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\ClusterDetail' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ClusterDetail' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ClusterDetail', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ClusterDetail';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ClusterDetail',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersPartialUpdate2Async
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedClusterDetail|null $patched_cluster_detail (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPartialUpdate2Async($id, $patched_cluster_detail = null, string $contentType = self::contentTypes['kubernetesClustersPartialUpdate2'][0])
    {
        return $this->kubernetesClustersPartialUpdate2AsyncWithHttpInfo($id, $patched_cluster_detail, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersPartialUpdate2AsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedClusterDetail|null $patched_cluster_detail (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPartialUpdate2AsyncWithHttpInfo($id, $patched_cluster_detail = null, string $contentType = self::contentTypes['kubernetesClustersPartialUpdate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ClusterDetail';
        $request = $this->kubernetesClustersPartialUpdate2Request($id, $patched_cluster_detail, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersPartialUpdate2'
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedClusterDetail|null $patched_cluster_detail (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersPartialUpdate2Request($id, $patched_cluster_detail = null, string $contentType = self::contentTypes['kubernetesClustersPartialUpdate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersPartialUpdate2'
            );
        }



        $resourcePath = '/api/v1/kubernetes/clusters/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_cluster_detail)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_cluster_detail));
            } else {
                $httpBody = $patched_cluster_detail;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersPortForwardsCreate
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersPortForwardsCreate($cluster_id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsCreate'][0])
    {
        $this->kubernetesClustersPortForwardsCreateWithHttpInfo($cluster_id, $contentType);
    }

    /**
     * Operation kubernetesClustersPortForwardsCreateWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersPortForwardsCreateWithHttpInfo($cluster_id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsCreate'][0])
    {
        $request = $this->kubernetesClustersPortForwardsCreateRequest($cluster_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersPortForwardsCreateAsync
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPortForwardsCreateAsync($cluster_id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsCreate'][0])
    {
        return $this->kubernetesClustersPortForwardsCreateAsyncWithHttpInfo($cluster_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersPortForwardsCreateAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPortForwardsCreateAsyncWithHttpInfo($cluster_id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsCreate'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersPortForwardsCreateRequest($cluster_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersPortForwardsCreate'
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersPortForwardsCreateRequest($cluster_id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsCreate'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersPortForwardsCreate'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/port-forwards/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersPortForwardsCreate2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersPortForwardsCreate2($cluster_id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsCreate2'][0])
    {
        $this->kubernetesClustersPortForwardsCreate2WithHttpInfo($cluster_id, $contentType);
    }

    /**
     * Operation kubernetesClustersPortForwardsCreate2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersPortForwardsCreate2WithHttpInfo($cluster_id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsCreate2'][0])
    {
        $request = $this->kubernetesClustersPortForwardsCreate2Request($cluster_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersPortForwardsCreate2Async
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPortForwardsCreate2Async($cluster_id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsCreate2'][0])
    {
        return $this->kubernetesClustersPortForwardsCreate2AsyncWithHttpInfo($cluster_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersPortForwardsCreate2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPortForwardsCreate2AsyncWithHttpInfo($cluster_id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsCreate2'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersPortForwardsCreate2Request($cluster_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersPortForwardsCreate2'
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersPortForwardsCreate2Request($cluster_id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsCreate2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersPortForwardsCreate2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/port-forwards/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersPortForwardsDestroy
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersPortForwardsDestroy($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsDestroy'][0])
    {
        $this->kubernetesClustersPortForwardsDestroyWithHttpInfo($cluster_id, $id, $contentType);
    }

    /**
     * Operation kubernetesClustersPortForwardsDestroyWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersPortForwardsDestroyWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsDestroy'][0])
    {
        $request = $this->kubernetesClustersPortForwardsDestroyRequest($cluster_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersPortForwardsDestroyAsync
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPortForwardsDestroyAsync($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsDestroy'][0])
    {
        return $this->kubernetesClustersPortForwardsDestroyAsyncWithHttpInfo($cluster_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersPortForwardsDestroyAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPortForwardsDestroyAsyncWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsDestroy'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersPortForwardsDestroyRequest($cluster_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersPortForwardsDestroy'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersPortForwardsDestroyRequest($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsDestroy'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersPortForwardsDestroy'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersPortForwardsDestroy'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/port-forwards/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersPortForwardsDestroy2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersPortForwardsDestroy2($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsDestroy2'][0])
    {
        $this->kubernetesClustersPortForwardsDestroy2WithHttpInfo($cluster_id, $id, $contentType);
    }

    /**
     * Operation kubernetesClustersPortForwardsDestroy2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersPortForwardsDestroy2WithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsDestroy2'][0])
    {
        $request = $this->kubernetesClustersPortForwardsDestroy2Request($cluster_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersPortForwardsDestroy2Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPortForwardsDestroy2Async($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsDestroy2'][0])
    {
        return $this->kubernetesClustersPortForwardsDestroy2AsyncWithHttpInfo($cluster_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersPortForwardsDestroy2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPortForwardsDestroy2AsyncWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsDestroy2'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersPortForwardsDestroy2Request($cluster_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersPortForwardsDestroy2'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersPortForwardsDestroy2Request($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsDestroy2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersPortForwardsDestroy2'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersPortForwardsDestroy2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/port-forwards/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersPortForwardsPartialUpdate
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersPortForwardsPartialUpdate($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsPartialUpdate'][0])
    {
        $this->kubernetesClustersPortForwardsPartialUpdateWithHttpInfo($cluster_id, $id, $contentType);
    }

    /**
     * Operation kubernetesClustersPortForwardsPartialUpdateWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersPortForwardsPartialUpdateWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsPartialUpdate'][0])
    {
        $request = $this->kubernetesClustersPortForwardsPartialUpdateRequest($cluster_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersPortForwardsPartialUpdateAsync
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPortForwardsPartialUpdateAsync($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsPartialUpdate'][0])
    {
        return $this->kubernetesClustersPortForwardsPartialUpdateAsyncWithHttpInfo($cluster_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersPortForwardsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPortForwardsPartialUpdateAsyncWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsPartialUpdate'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersPortForwardsPartialUpdateRequest($cluster_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersPortForwardsPartialUpdate'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersPortForwardsPartialUpdateRequest($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsPartialUpdate'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersPortForwardsPartialUpdate'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersPortForwardsPartialUpdate'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/port-forwards/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersPortForwardsPartialUpdate2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersPortForwardsPartialUpdate2($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsPartialUpdate2'][0])
    {
        $this->kubernetesClustersPortForwardsPartialUpdate2WithHttpInfo($cluster_id, $id, $contentType);
    }

    /**
     * Operation kubernetesClustersPortForwardsPartialUpdate2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersPortForwardsPartialUpdate2WithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsPartialUpdate2'][0])
    {
        $request = $this->kubernetesClustersPortForwardsPartialUpdate2Request($cluster_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersPortForwardsPartialUpdate2Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPortForwardsPartialUpdate2Async($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsPartialUpdate2'][0])
    {
        return $this->kubernetesClustersPortForwardsPartialUpdate2AsyncWithHttpInfo($cluster_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersPortForwardsPartialUpdate2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPortForwardsPartialUpdate2AsyncWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsPartialUpdate2'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersPortForwardsPartialUpdate2Request($cluster_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersPortForwardsPartialUpdate2'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersPortForwardsPartialUpdate2Request($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsPartialUpdate2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersPortForwardsPartialUpdate2'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersPortForwardsPartialUpdate2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/port-forwards/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersPortForwardsRetrieve
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersPortForwardsRetrieve($cluster_id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsRetrieve'][0])
    {
        $this->kubernetesClustersPortForwardsRetrieveWithHttpInfo($cluster_id, $contentType);
    }

    /**
     * Operation kubernetesClustersPortForwardsRetrieveWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersPortForwardsRetrieveWithHttpInfo($cluster_id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsRetrieve'][0])
    {
        $request = $this->kubernetesClustersPortForwardsRetrieveRequest($cluster_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersPortForwardsRetrieveAsync
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPortForwardsRetrieveAsync($cluster_id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsRetrieve'][0])
    {
        return $this->kubernetesClustersPortForwardsRetrieveAsyncWithHttpInfo($cluster_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersPortForwardsRetrieveAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPortForwardsRetrieveAsyncWithHttpInfo($cluster_id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsRetrieve'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersPortForwardsRetrieveRequest($cluster_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersPortForwardsRetrieve'
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersPortForwardsRetrieveRequest($cluster_id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsRetrieve'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersPortForwardsRetrieve'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/port-forwards/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersPortForwardsRetrieve2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersPortForwardsRetrieve2($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsRetrieve2'][0])
    {
        $this->kubernetesClustersPortForwardsRetrieve2WithHttpInfo($cluster_id, $id, $contentType);
    }

    /**
     * Operation kubernetesClustersPortForwardsRetrieve2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersPortForwardsRetrieve2WithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsRetrieve2'][0])
    {
        $request = $this->kubernetesClustersPortForwardsRetrieve2Request($cluster_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersPortForwardsRetrieve2Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPortForwardsRetrieve2Async($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsRetrieve2'][0])
    {
        return $this->kubernetesClustersPortForwardsRetrieve2AsyncWithHttpInfo($cluster_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersPortForwardsRetrieve2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPortForwardsRetrieve2AsyncWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsRetrieve2'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersPortForwardsRetrieve2Request($cluster_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersPortForwardsRetrieve2'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersPortForwardsRetrieve2Request($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsRetrieve2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersPortForwardsRetrieve2'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersPortForwardsRetrieve2'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/port-forwards/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersPortForwardsRetrieve3
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsRetrieve3'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersPortForwardsRetrieve3($cluster_id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsRetrieve3'][0])
    {
        $this->kubernetesClustersPortForwardsRetrieve3WithHttpInfo($cluster_id, $contentType);
    }

    /**
     * Operation kubernetesClustersPortForwardsRetrieve3WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsRetrieve3'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersPortForwardsRetrieve3WithHttpInfo($cluster_id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsRetrieve3'][0])
    {
        $request = $this->kubernetesClustersPortForwardsRetrieve3Request($cluster_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersPortForwardsRetrieve3Async
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsRetrieve3'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPortForwardsRetrieve3Async($cluster_id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsRetrieve3'][0])
    {
        return $this->kubernetesClustersPortForwardsRetrieve3AsyncWithHttpInfo($cluster_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersPortForwardsRetrieve3AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsRetrieve3'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPortForwardsRetrieve3AsyncWithHttpInfo($cluster_id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsRetrieve3'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersPortForwardsRetrieve3Request($cluster_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersPortForwardsRetrieve3'
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsRetrieve3'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersPortForwardsRetrieve3Request($cluster_id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsRetrieve3'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersPortForwardsRetrieve3'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/port-forwards/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersPortForwardsRetrieve4
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsRetrieve4'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersPortForwardsRetrieve4($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsRetrieve4'][0])
    {
        $this->kubernetesClustersPortForwardsRetrieve4WithHttpInfo($cluster_id, $id, $contentType);
    }

    /**
     * Operation kubernetesClustersPortForwardsRetrieve4WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsRetrieve4'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersPortForwardsRetrieve4WithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsRetrieve4'][0])
    {
        $request = $this->kubernetesClustersPortForwardsRetrieve4Request($cluster_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersPortForwardsRetrieve4Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsRetrieve4'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPortForwardsRetrieve4Async($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsRetrieve4'][0])
    {
        return $this->kubernetesClustersPortForwardsRetrieve4AsyncWithHttpInfo($cluster_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersPortForwardsRetrieve4AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsRetrieve4'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPortForwardsRetrieve4AsyncWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsRetrieve4'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersPortForwardsRetrieve4Request($cluster_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersPortForwardsRetrieve4'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsRetrieve4'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersPortForwardsRetrieve4Request($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsRetrieve4'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersPortForwardsRetrieve4'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersPortForwardsRetrieve4'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/port-forwards/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersPortForwardsUpdate
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersPortForwardsUpdate($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsUpdate'][0])
    {
        $this->kubernetesClustersPortForwardsUpdateWithHttpInfo($cluster_id, $id, $contentType);
    }

    /**
     * Operation kubernetesClustersPortForwardsUpdateWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersPortForwardsUpdateWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsUpdate'][0])
    {
        $request = $this->kubernetesClustersPortForwardsUpdateRequest($cluster_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersPortForwardsUpdateAsync
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPortForwardsUpdateAsync($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsUpdate'][0])
    {
        return $this->kubernetesClustersPortForwardsUpdateAsyncWithHttpInfo($cluster_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersPortForwardsUpdateAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPortForwardsUpdateAsyncWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsUpdate'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersPortForwardsUpdateRequest($cluster_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersPortForwardsUpdate'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersPortForwardsUpdateRequest($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsUpdate'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersPortForwardsUpdate'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersPortForwardsUpdate'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/port-forwards/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersPortForwardsUpdate2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersPortForwardsUpdate2($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsUpdate2'][0])
    {
        $this->kubernetesClustersPortForwardsUpdate2WithHttpInfo($cluster_id, $id, $contentType);
    }

    /**
     * Operation kubernetesClustersPortForwardsUpdate2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersPortForwardsUpdate2WithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsUpdate2'][0])
    {
        $request = $this->kubernetesClustersPortForwardsUpdate2Request($cluster_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersPortForwardsUpdate2Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPortForwardsUpdate2Async($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsUpdate2'][0])
    {
        return $this->kubernetesClustersPortForwardsUpdate2AsyncWithHttpInfo($cluster_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersPortForwardsUpdate2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersPortForwardsUpdate2AsyncWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsUpdate2'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersPortForwardsUpdate2Request($cluster_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersPortForwardsUpdate2'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersPortForwardsUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersPortForwardsUpdate2Request($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersPortForwardsUpdate2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersPortForwardsUpdate2'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersPortForwardsUpdate2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/port-forwards/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersResourcePoolsCreate
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\ResourcePoolAdd $resource_pool_add resource_pool_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ResourcePoolAddResponse
     */
    public function kubernetesClustersResourcePoolsCreate($cluster_id, $resource_pool_add, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsCreate'][0])
    {
        list($response) = $this->kubernetesClustersResourcePoolsCreateWithHttpInfo($cluster_id, $resource_pool_add, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersResourcePoolsCreateWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\ResourcePoolAdd $resource_pool_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ResourcePoolAddResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersResourcePoolsCreateWithHttpInfo($cluster_id, $resource_pool_add, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsCreate'][0])
    {
        $request = $this->kubernetesClustersResourcePoolsCreateRequest($cluster_id, $resource_pool_add, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\ResourcePoolAddResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ResourcePoolAddResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ResourcePoolAddResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ResourcePoolAddResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ResourcePoolAddResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersResourcePoolsCreateAsync
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\ResourcePoolAdd $resource_pool_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsCreateAsync($cluster_id, $resource_pool_add, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsCreate'][0])
    {
        return $this->kubernetesClustersResourcePoolsCreateAsyncWithHttpInfo($cluster_id, $resource_pool_add, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersResourcePoolsCreateAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\ResourcePoolAdd $resource_pool_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsCreateAsyncWithHttpInfo($cluster_id, $resource_pool_add, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ResourcePoolAddResponse';
        $request = $this->kubernetesClustersResourcePoolsCreateRequest($cluster_id, $resource_pool_add, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersResourcePoolsCreate'
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\ResourcePoolAdd $resource_pool_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersResourcePoolsCreateRequest($cluster_id, $resource_pool_add, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsCreate'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersResourcePoolsCreate'
            );
        }

        // verify the required parameter 'resource_pool_add' is set
        if ($resource_pool_add === null || (is_array($resource_pool_add) && count($resource_pool_add) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_pool_add when calling kubernetesClustersResourcePoolsCreate'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/resource-pools/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($resource_pool_add)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($resource_pool_add));
            } else {
                $httpBody = $resource_pool_add;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersResourcePoolsCreate2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\ResourcePoolAdd $resource_pool_add resource_pool_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ResourcePoolAddResponse
     */
    public function kubernetesClustersResourcePoolsCreate2($cluster_id, $resource_pool_add, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsCreate2'][0])
    {
        list($response) = $this->kubernetesClustersResourcePoolsCreate2WithHttpInfo($cluster_id, $resource_pool_add, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersResourcePoolsCreate2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\ResourcePoolAdd $resource_pool_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ResourcePoolAddResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersResourcePoolsCreate2WithHttpInfo($cluster_id, $resource_pool_add, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsCreate2'][0])
    {
        $request = $this->kubernetesClustersResourcePoolsCreate2Request($cluster_id, $resource_pool_add, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\ResourcePoolAddResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ResourcePoolAddResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ResourcePoolAddResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ResourcePoolAddResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ResourcePoolAddResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersResourcePoolsCreate2Async
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\ResourcePoolAdd $resource_pool_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsCreate2Async($cluster_id, $resource_pool_add, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsCreate2'][0])
    {
        return $this->kubernetesClustersResourcePoolsCreate2AsyncWithHttpInfo($cluster_id, $resource_pool_add, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersResourcePoolsCreate2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\ResourcePoolAdd $resource_pool_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsCreate2AsyncWithHttpInfo($cluster_id, $resource_pool_add, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ResourcePoolAddResponse';
        $request = $this->kubernetesClustersResourcePoolsCreate2Request($cluster_id, $resource_pool_add, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersResourcePoolsCreate2'
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\ResourcePoolAdd $resource_pool_add (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersResourcePoolsCreate2Request($cluster_id, $resource_pool_add, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsCreate2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersResourcePoolsCreate2'
            );
        }

        // verify the required parameter 'resource_pool_add' is set
        if ($resource_pool_add === null || (is_array($resource_pool_add) && count($resource_pool_add) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $resource_pool_add when calling kubernetesClustersResourcePoolsCreate2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/resource-pools/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($resource_pool_add)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($resource_pool_add));
            } else {
                $httpBody = $resource_pool_add;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersResourcePoolsDestroy
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersResourcePoolsDestroy($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsDestroy'][0])
    {
        $this->kubernetesClustersResourcePoolsDestroyWithHttpInfo($cluster_id, $id, $contentType);
    }

    /**
     * Operation kubernetesClustersResourcePoolsDestroyWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersResourcePoolsDestroyWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsDestroy'][0])
    {
        $request = $this->kubernetesClustersResourcePoolsDestroyRequest($cluster_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersResourcePoolsDestroyAsync
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsDestroyAsync($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsDestroy'][0])
    {
        return $this->kubernetesClustersResourcePoolsDestroyAsyncWithHttpInfo($cluster_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersResourcePoolsDestroyAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsDestroyAsyncWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsDestroy'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersResourcePoolsDestroyRequest($cluster_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersResourcePoolsDestroy'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersResourcePoolsDestroyRequest($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsDestroy'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersResourcePoolsDestroy'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersResourcePoolsDestroy'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/resource-pools/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersResourcePoolsDestroy2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersResourcePoolsDestroy2($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsDestroy2'][0])
    {
        $this->kubernetesClustersResourcePoolsDestroy2WithHttpInfo($cluster_id, $id, $contentType);
    }

    /**
     * Operation kubernetesClustersResourcePoolsDestroy2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersResourcePoolsDestroy2WithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsDestroy2'][0])
    {
        $request = $this->kubernetesClustersResourcePoolsDestroy2Request($cluster_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersResourcePoolsDestroy2Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsDestroy2Async($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsDestroy2'][0])
    {
        return $this->kubernetesClustersResourcePoolsDestroy2AsyncWithHttpInfo($cluster_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersResourcePoolsDestroy2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsDestroy2AsyncWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsDestroy2'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersResourcePoolsDestroy2Request($cluster_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersResourcePoolsDestroy2'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersResourcePoolsDestroy2Request($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsDestroy2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersResourcePoolsDestroy2'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersResourcePoolsDestroy2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/resource-pools/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersResourcePoolsList
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedResourcePoolList
     */
    public function kubernetesClustersResourcePoolsList($cluster_id, $page = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsList'][0])
    {
        list($response) = $this->kubernetesClustersResourcePoolsListWithHttpInfo($cluster_id, $page, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersResourcePoolsListWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedResourcePoolList, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersResourcePoolsListWithHttpInfo($cluster_id, $page = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsList'][0])
    {
        $request = $this->kubernetesClustersResourcePoolsListRequest($cluster_id, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedResourcePoolList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedResourcePoolList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedResourcePoolList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedResourcePoolList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedResourcePoolList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersResourcePoolsListAsync
     *
     * @param  int $cluster_id (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsListAsync($cluster_id, $page = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsList'][0])
    {
        return $this->kubernetesClustersResourcePoolsListAsyncWithHttpInfo($cluster_id, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersResourcePoolsListAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsListAsyncWithHttpInfo($cluster_id, $page = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsList'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedResourcePoolList';
        $request = $this->kubernetesClustersResourcePoolsListRequest($cluster_id, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersResourcePoolsList'
     *
     * @param  int $cluster_id (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersResourcePoolsListRequest($cluster_id, $page = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsList'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersResourcePoolsList'
            );
        }



        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/resource-pools/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersResourcePoolsList2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedResourcePoolList
     */
    public function kubernetesClustersResourcePoolsList2($cluster_id, $page = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsList2'][0])
    {
        list($response) = $this->kubernetesClustersResourcePoolsList2WithHttpInfo($cluster_id, $page, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersResourcePoolsList2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedResourcePoolList, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersResourcePoolsList2WithHttpInfo($cluster_id, $page = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsList2'][0])
    {
        $request = $this->kubernetesClustersResourcePoolsList2Request($cluster_id, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedResourcePoolList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedResourcePoolList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedResourcePoolList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedResourcePoolList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedResourcePoolList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersResourcePoolsList2Async
     *
     * @param  int $cluster_id (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsList2Async($cluster_id, $page = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsList2'][0])
    {
        return $this->kubernetesClustersResourcePoolsList2AsyncWithHttpInfo($cluster_id, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersResourcePoolsList2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsList2AsyncWithHttpInfo($cluster_id, $page = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsList2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedResourcePoolList';
        $request = $this->kubernetesClustersResourcePoolsList2Request($cluster_id, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersResourcePoolsList2'
     *
     * @param  int $cluster_id (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersResourcePoolsList2Request($cluster_id, $page = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsList2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersResourcePoolsList2'
            );
        }



        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/resource-pools/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersResourcePoolsNodesDestroy
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  int $pool_id pool_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersResourcePoolsNodesDestroy($cluster_id, $id, $pool_id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesDestroy'][0])
    {
        $this->kubernetesClustersResourcePoolsNodesDestroyWithHttpInfo($cluster_id, $id, $pool_id, $contentType);
    }

    /**
     * Operation kubernetesClustersResourcePoolsNodesDestroyWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  int $pool_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersResourcePoolsNodesDestroyWithHttpInfo($cluster_id, $id, $pool_id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesDestroy'][0])
    {
        $request = $this->kubernetesClustersResourcePoolsNodesDestroyRequest($cluster_id, $id, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersResourcePoolsNodesDestroyAsync
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  int $pool_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsNodesDestroyAsync($cluster_id, $id, $pool_id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesDestroy'][0])
    {
        return $this->kubernetesClustersResourcePoolsNodesDestroyAsyncWithHttpInfo($cluster_id, $id, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersResourcePoolsNodesDestroyAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  int $pool_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsNodesDestroyAsyncWithHttpInfo($cluster_id, $id, $pool_id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesDestroy'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersResourcePoolsNodesDestroyRequest($cluster_id, $id, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersResourcePoolsNodesDestroy'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  int $pool_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersResourcePoolsNodesDestroyRequest($cluster_id, $id, $pool_id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesDestroy'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersResourcePoolsNodesDestroy'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersResourcePoolsNodesDestroy'
            );
        }

        // verify the required parameter 'pool_id' is set
        if ($pool_id === null || (is_array($pool_id) && count($pool_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pool_id when calling kubernetesClustersResourcePoolsNodesDestroy'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/resource-pools/{pool_id}/nodes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($pool_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pool_id' . '}',
                ObjectSerializer::toPathValue($pool_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersResourcePoolsNodesDestroy2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  int $pool_id pool_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersResourcePoolsNodesDestroy2($cluster_id, $id, $pool_id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesDestroy2'][0])
    {
        $this->kubernetesClustersResourcePoolsNodesDestroy2WithHttpInfo($cluster_id, $id, $pool_id, $contentType);
    }

    /**
     * Operation kubernetesClustersResourcePoolsNodesDestroy2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  int $pool_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersResourcePoolsNodesDestroy2WithHttpInfo($cluster_id, $id, $pool_id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesDestroy2'][0])
    {
        $request = $this->kubernetesClustersResourcePoolsNodesDestroy2Request($cluster_id, $id, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersResourcePoolsNodesDestroy2Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  int $pool_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsNodesDestroy2Async($cluster_id, $id, $pool_id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesDestroy2'][0])
    {
        return $this->kubernetesClustersResourcePoolsNodesDestroy2AsyncWithHttpInfo($cluster_id, $id, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersResourcePoolsNodesDestroy2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  int $pool_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsNodesDestroy2AsyncWithHttpInfo($cluster_id, $id, $pool_id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesDestroy2'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersResourcePoolsNodesDestroy2Request($cluster_id, $id, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersResourcePoolsNodesDestroy2'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  int $pool_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersResourcePoolsNodesDestroy2Request($cluster_id, $id, $pool_id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesDestroy2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersResourcePoolsNodesDestroy2'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersResourcePoolsNodesDestroy2'
            );
        }

        // verify the required parameter 'pool_id' is set
        if ($pool_id === null || (is_array($pool_id) && count($pool_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pool_id when calling kubernetesClustersResourcePoolsNodesDestroy2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/resource-pools/{pool_id}/nodes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($pool_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pool_id' . '}',
                ObjectSerializer::toPathValue($pool_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersResourcePoolsNodesList
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  int $pool_id pool_id (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedResourcePoolNodeList
     */
    public function kubernetesClustersResourcePoolsNodesList($cluster_id, $pool_id, $page = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesList'][0])
    {
        list($response) = $this->kubernetesClustersResourcePoolsNodesListWithHttpInfo($cluster_id, $pool_id, $page, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersResourcePoolsNodesListWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  int $pool_id (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedResourcePoolNodeList, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersResourcePoolsNodesListWithHttpInfo($cluster_id, $pool_id, $page = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesList'][0])
    {
        $request = $this->kubernetesClustersResourcePoolsNodesListRequest($cluster_id, $pool_id, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedResourcePoolNodeList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedResourcePoolNodeList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedResourcePoolNodeList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedResourcePoolNodeList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedResourcePoolNodeList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersResourcePoolsNodesListAsync
     *
     * @param  int $cluster_id (required)
     * @param  int $pool_id (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsNodesListAsync($cluster_id, $pool_id, $page = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesList'][0])
    {
        return $this->kubernetesClustersResourcePoolsNodesListAsyncWithHttpInfo($cluster_id, $pool_id, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersResourcePoolsNodesListAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  int $pool_id (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsNodesListAsyncWithHttpInfo($cluster_id, $pool_id, $page = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesList'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedResourcePoolNodeList';
        $request = $this->kubernetesClustersResourcePoolsNodesListRequest($cluster_id, $pool_id, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersResourcePoolsNodesList'
     *
     * @param  int $cluster_id (required)
     * @param  int $pool_id (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersResourcePoolsNodesListRequest($cluster_id, $pool_id, $page = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesList'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersResourcePoolsNodesList'
            );
        }

        // verify the required parameter 'pool_id' is set
        if ($pool_id === null || (is_array($pool_id) && count($pool_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pool_id when calling kubernetesClustersResourcePoolsNodesList'
            );
        }



        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/resource-pools/{pool_id}/nodes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($pool_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pool_id' . '}',
                ObjectSerializer::toPathValue($pool_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersResourcePoolsNodesList2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  int $pool_id pool_id (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedResourcePoolNodeList
     */
    public function kubernetesClustersResourcePoolsNodesList2($cluster_id, $pool_id, $page = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesList2'][0])
    {
        list($response) = $this->kubernetesClustersResourcePoolsNodesList2WithHttpInfo($cluster_id, $pool_id, $page, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersResourcePoolsNodesList2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  int $pool_id (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedResourcePoolNodeList, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersResourcePoolsNodesList2WithHttpInfo($cluster_id, $pool_id, $page = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesList2'][0])
    {
        $request = $this->kubernetesClustersResourcePoolsNodesList2Request($cluster_id, $pool_id, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedResourcePoolNodeList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedResourcePoolNodeList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedResourcePoolNodeList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedResourcePoolNodeList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedResourcePoolNodeList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersResourcePoolsNodesList2Async
     *
     * @param  int $cluster_id (required)
     * @param  int $pool_id (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsNodesList2Async($cluster_id, $pool_id, $page = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesList2'][0])
    {
        return $this->kubernetesClustersResourcePoolsNodesList2AsyncWithHttpInfo($cluster_id, $pool_id, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersResourcePoolsNodesList2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  int $pool_id (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsNodesList2AsyncWithHttpInfo($cluster_id, $pool_id, $page = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesList2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedResourcePoolNodeList';
        $request = $this->kubernetesClustersResourcePoolsNodesList2Request($cluster_id, $pool_id, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersResourcePoolsNodesList2'
     *
     * @param  int $cluster_id (required)
     * @param  int $pool_id (required)
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersResourcePoolsNodesList2Request($cluster_id, $pool_id, $page = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesList2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersResourcePoolsNodesList2'
            );
        }

        // verify the required parameter 'pool_id' is set
        if ($pool_id === null || (is_array($pool_id) && count($pool_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pool_id when calling kubernetesClustersResourcePoolsNodesList2'
            );
        }



        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/resource-pools/{pool_id}/nodes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($pool_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pool_id' . '}',
                ObjectSerializer::toPathValue($pool_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersResourcePoolsNodesRetrieve
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  int $pool_id pool_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ResourcePoolNode
     */
    public function kubernetesClustersResourcePoolsNodesRetrieve($cluster_id, $id, $pool_id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesRetrieve'][0])
    {
        list($response) = $this->kubernetesClustersResourcePoolsNodesRetrieveWithHttpInfo($cluster_id, $id, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersResourcePoolsNodesRetrieveWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  int $pool_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ResourcePoolNode, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersResourcePoolsNodesRetrieveWithHttpInfo($cluster_id, $id, $pool_id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesRetrieve'][0])
    {
        $request = $this->kubernetesClustersResourcePoolsNodesRetrieveRequest($cluster_id, $id, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\ResourcePoolNode' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ResourcePoolNode' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ResourcePoolNode', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ResourcePoolNode';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ResourcePoolNode',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersResourcePoolsNodesRetrieveAsync
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  int $pool_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsNodesRetrieveAsync($cluster_id, $id, $pool_id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesRetrieve'][0])
    {
        return $this->kubernetesClustersResourcePoolsNodesRetrieveAsyncWithHttpInfo($cluster_id, $id, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersResourcePoolsNodesRetrieveAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  int $pool_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsNodesRetrieveAsyncWithHttpInfo($cluster_id, $id, $pool_id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesRetrieve'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ResourcePoolNode';
        $request = $this->kubernetesClustersResourcePoolsNodesRetrieveRequest($cluster_id, $id, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersResourcePoolsNodesRetrieve'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  int $pool_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersResourcePoolsNodesRetrieveRequest($cluster_id, $id, $pool_id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesRetrieve'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersResourcePoolsNodesRetrieve'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersResourcePoolsNodesRetrieve'
            );
        }

        // verify the required parameter 'pool_id' is set
        if ($pool_id === null || (is_array($pool_id) && count($pool_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pool_id when calling kubernetesClustersResourcePoolsNodesRetrieve'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/resource-pools/{pool_id}/nodes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($pool_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pool_id' . '}',
                ObjectSerializer::toPathValue($pool_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersResourcePoolsNodesRetrieve2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  int $pool_id pool_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ResourcePoolNode
     */
    public function kubernetesClustersResourcePoolsNodesRetrieve2($cluster_id, $id, $pool_id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesRetrieve2'][0])
    {
        list($response) = $this->kubernetesClustersResourcePoolsNodesRetrieve2WithHttpInfo($cluster_id, $id, $pool_id, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersResourcePoolsNodesRetrieve2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  int $pool_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ResourcePoolNode, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersResourcePoolsNodesRetrieve2WithHttpInfo($cluster_id, $id, $pool_id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesRetrieve2'][0])
    {
        $request = $this->kubernetesClustersResourcePoolsNodesRetrieve2Request($cluster_id, $id, $pool_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\ResourcePoolNode' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ResourcePoolNode' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ResourcePoolNode', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ResourcePoolNode';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ResourcePoolNode',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersResourcePoolsNodesRetrieve2Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  int $pool_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsNodesRetrieve2Async($cluster_id, $id, $pool_id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesRetrieve2'][0])
    {
        return $this->kubernetesClustersResourcePoolsNodesRetrieve2AsyncWithHttpInfo($cluster_id, $id, $pool_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersResourcePoolsNodesRetrieve2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  int $pool_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsNodesRetrieve2AsyncWithHttpInfo($cluster_id, $id, $pool_id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesRetrieve2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ResourcePoolNode';
        $request = $this->kubernetesClustersResourcePoolsNodesRetrieve2Request($cluster_id, $id, $pool_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersResourcePoolsNodesRetrieve2'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  int $pool_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsNodesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersResourcePoolsNodesRetrieve2Request($cluster_id, $id, $pool_id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsNodesRetrieve2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersResourcePoolsNodesRetrieve2'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersResourcePoolsNodesRetrieve2'
            );
        }

        // verify the required parameter 'pool_id' is set
        if ($pool_id === null || (is_array($pool_id) && count($pool_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pool_id when calling kubernetesClustersResourcePoolsNodesRetrieve2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/resource-pools/{pool_id}/nodes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }
        // path params
        if ($pool_id !== null) {
            $resourcePath = str_replace(
                '{' . 'pool_id' . '}',
                ObjectSerializer::toPathValue($pool_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersResourcePoolsPartialUpdate
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedResourcePool|null $patched_resource_pool patched_resource_pool (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ResourcePool
     */
    public function kubernetesClustersResourcePoolsPartialUpdate($cluster_id, $id, $patched_resource_pool = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsPartialUpdate'][0])
    {
        list($response) = $this->kubernetesClustersResourcePoolsPartialUpdateWithHttpInfo($cluster_id, $id, $patched_resource_pool, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersResourcePoolsPartialUpdateWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedResourcePool|null $patched_resource_pool (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ResourcePool, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersResourcePoolsPartialUpdateWithHttpInfo($cluster_id, $id, $patched_resource_pool = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsPartialUpdate'][0])
    {
        $request = $this->kubernetesClustersResourcePoolsPartialUpdateRequest($cluster_id, $id, $patched_resource_pool, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\ResourcePool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ResourcePool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ResourcePool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ResourcePool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ResourcePool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersResourcePoolsPartialUpdateAsync
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedResourcePool|null $patched_resource_pool (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsPartialUpdateAsync($cluster_id, $id, $patched_resource_pool = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsPartialUpdate'][0])
    {
        return $this->kubernetesClustersResourcePoolsPartialUpdateAsyncWithHttpInfo($cluster_id, $id, $patched_resource_pool, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersResourcePoolsPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedResourcePool|null $patched_resource_pool (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsPartialUpdateAsyncWithHttpInfo($cluster_id, $id, $patched_resource_pool = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsPartialUpdate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ResourcePool';
        $request = $this->kubernetesClustersResourcePoolsPartialUpdateRequest($cluster_id, $id, $patched_resource_pool, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersResourcePoolsPartialUpdate'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedResourcePool|null $patched_resource_pool (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersResourcePoolsPartialUpdateRequest($cluster_id, $id, $patched_resource_pool = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsPartialUpdate'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersResourcePoolsPartialUpdate'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersResourcePoolsPartialUpdate'
            );
        }



        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/resource-pools/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_resource_pool)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_resource_pool));
            } else {
                $httpBody = $patched_resource_pool;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersResourcePoolsPartialUpdate2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedResourcePool|null $patched_resource_pool patched_resource_pool (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ResourcePool
     */
    public function kubernetesClustersResourcePoolsPartialUpdate2($cluster_id, $id, $patched_resource_pool = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsPartialUpdate2'][0])
    {
        list($response) = $this->kubernetesClustersResourcePoolsPartialUpdate2WithHttpInfo($cluster_id, $id, $patched_resource_pool, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersResourcePoolsPartialUpdate2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedResourcePool|null $patched_resource_pool (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ResourcePool, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersResourcePoolsPartialUpdate2WithHttpInfo($cluster_id, $id, $patched_resource_pool = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsPartialUpdate2'][0])
    {
        $request = $this->kubernetesClustersResourcePoolsPartialUpdate2Request($cluster_id, $id, $patched_resource_pool, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\ResourcePool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ResourcePool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ResourcePool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ResourcePool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ResourcePool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersResourcePoolsPartialUpdate2Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedResourcePool|null $patched_resource_pool (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsPartialUpdate2Async($cluster_id, $id, $patched_resource_pool = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsPartialUpdate2'][0])
    {
        return $this->kubernetesClustersResourcePoolsPartialUpdate2AsyncWithHttpInfo($cluster_id, $id, $patched_resource_pool, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersResourcePoolsPartialUpdate2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedResourcePool|null $patched_resource_pool (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsPartialUpdate2AsyncWithHttpInfo($cluster_id, $id, $patched_resource_pool = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsPartialUpdate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ResourcePool';
        $request = $this->kubernetesClustersResourcePoolsPartialUpdate2Request($cluster_id, $id, $patched_resource_pool, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersResourcePoolsPartialUpdate2'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedResourcePool|null $patched_resource_pool (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersResourcePoolsPartialUpdate2Request($cluster_id, $id, $patched_resource_pool = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsPartialUpdate2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersResourcePoolsPartialUpdate2'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersResourcePoolsPartialUpdate2'
            );
        }



        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/resource-pools/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_resource_pool)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_resource_pool));
            } else {
                $httpBody = $patched_resource_pool;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersResourcePoolsRetrieve
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ResourcePool
     */
    public function kubernetesClustersResourcePoolsRetrieve($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsRetrieve'][0])
    {
        list($response) = $this->kubernetesClustersResourcePoolsRetrieveWithHttpInfo($cluster_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersResourcePoolsRetrieveWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ResourcePool, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersResourcePoolsRetrieveWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsRetrieve'][0])
    {
        $request = $this->kubernetesClustersResourcePoolsRetrieveRequest($cluster_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\ResourcePool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ResourcePool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ResourcePool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ResourcePool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ResourcePool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersResourcePoolsRetrieveAsync
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsRetrieveAsync($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsRetrieve'][0])
    {
        return $this->kubernetesClustersResourcePoolsRetrieveAsyncWithHttpInfo($cluster_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersResourcePoolsRetrieveAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsRetrieveAsyncWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsRetrieve'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ResourcePool';
        $request = $this->kubernetesClustersResourcePoolsRetrieveRequest($cluster_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersResourcePoolsRetrieve'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersResourcePoolsRetrieveRequest($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsRetrieve'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersResourcePoolsRetrieve'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersResourcePoolsRetrieve'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/resource-pools/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersResourcePoolsRetrieve2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ResourcePool
     */
    public function kubernetesClustersResourcePoolsRetrieve2($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsRetrieve2'][0])
    {
        list($response) = $this->kubernetesClustersResourcePoolsRetrieve2WithHttpInfo($cluster_id, $id, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersResourcePoolsRetrieve2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ResourcePool, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersResourcePoolsRetrieve2WithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsRetrieve2'][0])
    {
        $request = $this->kubernetesClustersResourcePoolsRetrieve2Request($cluster_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\ResourcePool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ResourcePool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ResourcePool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ResourcePool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ResourcePool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersResourcePoolsRetrieve2Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsRetrieve2Async($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsRetrieve2'][0])
    {
        return $this->kubernetesClustersResourcePoolsRetrieve2AsyncWithHttpInfo($cluster_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersResourcePoolsRetrieve2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsRetrieve2AsyncWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsRetrieve2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ResourcePool';
        $request = $this->kubernetesClustersResourcePoolsRetrieve2Request($cluster_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersResourcePoolsRetrieve2'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersResourcePoolsRetrieve2Request($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsRetrieve2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersResourcePoolsRetrieve2'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersResourcePoolsRetrieve2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/resource-pools/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersResourcePoolsUpdate
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\ResourcePool|null $resource_pool resource_pool (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ResourcePool
     */
    public function kubernetesClustersResourcePoolsUpdate($cluster_id, $id, $resource_pool = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsUpdate'][0])
    {
        list($response) = $this->kubernetesClustersResourcePoolsUpdateWithHttpInfo($cluster_id, $id, $resource_pool, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersResourcePoolsUpdateWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\ResourcePool|null $resource_pool (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ResourcePool, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersResourcePoolsUpdateWithHttpInfo($cluster_id, $id, $resource_pool = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsUpdate'][0])
    {
        $request = $this->kubernetesClustersResourcePoolsUpdateRequest($cluster_id, $id, $resource_pool, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\ResourcePool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ResourcePool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ResourcePool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ResourcePool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ResourcePool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersResourcePoolsUpdateAsync
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\ResourcePool|null $resource_pool (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsUpdateAsync($cluster_id, $id, $resource_pool = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsUpdate'][0])
    {
        return $this->kubernetesClustersResourcePoolsUpdateAsyncWithHttpInfo($cluster_id, $id, $resource_pool, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersResourcePoolsUpdateAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\ResourcePool|null $resource_pool (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsUpdateAsyncWithHttpInfo($cluster_id, $id, $resource_pool = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsUpdate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ResourcePool';
        $request = $this->kubernetesClustersResourcePoolsUpdateRequest($cluster_id, $id, $resource_pool, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersResourcePoolsUpdate'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\ResourcePool|null $resource_pool (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersResourcePoolsUpdateRequest($cluster_id, $id, $resource_pool = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsUpdate'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersResourcePoolsUpdate'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersResourcePoolsUpdate'
            );
        }



        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/resource-pools/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($resource_pool)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($resource_pool));
            } else {
                $httpBody = $resource_pool;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersResourcePoolsUpdate2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\ResourcePool|null $resource_pool resource_pool (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ResourcePool
     */
    public function kubernetesClustersResourcePoolsUpdate2($cluster_id, $id, $resource_pool = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsUpdate2'][0])
    {
        list($response) = $this->kubernetesClustersResourcePoolsUpdate2WithHttpInfo($cluster_id, $id, $resource_pool, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersResourcePoolsUpdate2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\ResourcePool|null $resource_pool (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ResourcePool, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersResourcePoolsUpdate2WithHttpInfo($cluster_id, $id, $resource_pool = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsUpdate2'][0])
    {
        $request = $this->kubernetesClustersResourcePoolsUpdate2Request($cluster_id, $id, $resource_pool, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\ResourcePool' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ResourcePool' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ResourcePool', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ResourcePool';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ResourcePool',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersResourcePoolsUpdate2Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\ResourcePool|null $resource_pool (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsUpdate2Async($cluster_id, $id, $resource_pool = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsUpdate2'][0])
    {
        return $this->kubernetesClustersResourcePoolsUpdate2AsyncWithHttpInfo($cluster_id, $id, $resource_pool, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersResourcePoolsUpdate2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\ResourcePool|null $resource_pool (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersResourcePoolsUpdate2AsyncWithHttpInfo($cluster_id, $id, $resource_pool = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsUpdate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ResourcePool';
        $request = $this->kubernetesClustersResourcePoolsUpdate2Request($cluster_id, $id, $resource_pool, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersResourcePoolsUpdate2'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\ResourcePool|null $resource_pool (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersResourcePoolsUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersResourcePoolsUpdate2Request($cluster_id, $id, $resource_pool = null, string $contentType = self::contentTypes['kubernetesClustersResourcePoolsUpdate2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersResourcePoolsUpdate2'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersResourcePoolsUpdate2'
            );
        }



        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/resource-pools/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($resource_pool)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($resource_pool));
            } else {
                $httpBody = $resource_pool;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersRetrieve
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ClusterDetail
     */
    public function kubernetesClustersRetrieve($id, string $contentType = self::contentTypes['kubernetesClustersRetrieve'][0])
    {
        list($response) = $this->kubernetesClustersRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersRetrieveWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ClusterDetail, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersRetrieve'][0])
    {
        $request = $this->kubernetesClustersRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\ClusterDetail' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ClusterDetail' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ClusterDetail', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ClusterDetail';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ClusterDetail',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersRetrieveAsync
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersRetrieveAsync($id, string $contentType = self::contentTypes['kubernetesClustersRetrieve'][0])
    {
        return $this->kubernetesClustersRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersRetrieveAsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersRetrieve'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ClusterDetail';
        $request = $this->kubernetesClustersRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersRetrieve'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersRetrieveRequest($id, string $contentType = self::contentTypes['kubernetesClustersRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersRetrieve'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersRetrieve2
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ClusterDetail
     */
    public function kubernetesClustersRetrieve2($id, string $contentType = self::contentTypes['kubernetesClustersRetrieve2'][0])
    {
        list($response) = $this->kubernetesClustersRetrieve2WithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersRetrieve2WithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ClusterDetail, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersRetrieve2WithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersRetrieve2'][0])
    {
        $request = $this->kubernetesClustersRetrieve2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\ClusterDetail' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ClusterDetail' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ClusterDetail', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ClusterDetail';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ClusterDetail',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersRetrieve2Async
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersRetrieve2Async($id, string $contentType = self::contentTypes['kubernetesClustersRetrieve2'][0])
    {
        return $this->kubernetesClustersRetrieve2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersRetrieve2AsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersRetrieve2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersRetrieve2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ClusterDetail';
        $request = $this->kubernetesClustersRetrieve2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersRetrieve2'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersRetrieve2Request($id, string $contentType = self::contentTypes['kubernetesClustersRetrieve2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersRetrieve2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersTalosVersionUpgradeCreate
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTalosVersionUpgradeCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\TalosUpgradeResponse
     */
    public function kubernetesClustersTalosVersionUpgradeCreate($id, string $contentType = self::contentTypes['kubernetesClustersTalosVersionUpgradeCreate'][0])
    {
        list($response) = $this->kubernetesClustersTalosVersionUpgradeCreateWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersTalosVersionUpgradeCreateWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTalosVersionUpgradeCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\TalosUpgradeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersTalosVersionUpgradeCreateWithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersTalosVersionUpgradeCreate'][0])
    {
        $request = $this->kubernetesClustersTalosVersionUpgradeCreateRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\TalosUpgradeResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\TalosUpgradeResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\TalosUpgradeResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\TalosUpgradeResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\TalosUpgradeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersTalosVersionUpgradeCreateAsync
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTalosVersionUpgradeCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTalosVersionUpgradeCreateAsync($id, string $contentType = self::contentTypes['kubernetesClustersTalosVersionUpgradeCreate'][0])
    {
        return $this->kubernetesClustersTalosVersionUpgradeCreateAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersTalosVersionUpgradeCreateAsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTalosVersionUpgradeCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTalosVersionUpgradeCreateAsyncWithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersTalosVersionUpgradeCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\TalosUpgradeResponse';
        $request = $this->kubernetesClustersTalosVersionUpgradeCreateRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersTalosVersionUpgradeCreate'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTalosVersionUpgradeCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersTalosVersionUpgradeCreateRequest($id, string $contentType = self::contentTypes['kubernetesClustersTalosVersionUpgradeCreate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersTalosVersionUpgradeCreate'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{id}/talos-version-upgrade/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersTalosVersionUpgradeCreate2
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTalosVersionUpgradeCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\TalosUpgradeResponse
     */
    public function kubernetesClustersTalosVersionUpgradeCreate2($id, string $contentType = self::contentTypes['kubernetesClustersTalosVersionUpgradeCreate2'][0])
    {
        list($response) = $this->kubernetesClustersTalosVersionUpgradeCreate2WithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersTalosVersionUpgradeCreate2WithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTalosVersionUpgradeCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\TalosUpgradeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersTalosVersionUpgradeCreate2WithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersTalosVersionUpgradeCreate2'][0])
    {
        $request = $this->kubernetesClustersTalosVersionUpgradeCreate2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\TalosUpgradeResponse' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\TalosUpgradeResponse' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\TalosUpgradeResponse', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\TalosUpgradeResponse';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\TalosUpgradeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersTalosVersionUpgradeCreate2Async
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTalosVersionUpgradeCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTalosVersionUpgradeCreate2Async($id, string $contentType = self::contentTypes['kubernetesClustersTalosVersionUpgradeCreate2'][0])
    {
        return $this->kubernetesClustersTalosVersionUpgradeCreate2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersTalosVersionUpgradeCreate2AsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTalosVersionUpgradeCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTalosVersionUpgradeCreate2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['kubernetesClustersTalosVersionUpgradeCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\TalosUpgradeResponse';
        $request = $this->kubernetesClustersTalosVersionUpgradeCreate2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersTalosVersionUpgradeCreate2'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTalosVersionUpgradeCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersTalosVersionUpgradeCreate2Request($id, string $contentType = self::contentTypes['kubernetesClustersTalosVersionUpgradeCreate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersTalosVersionUpgradeCreate2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{id}/talos-version-upgrade/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersTcproutesCreate
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\TCPRoute $tcp_route tcp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\TCPRoute
     */
    public function kubernetesClustersTcproutesCreate($cluster_id, $tcp_route, string $contentType = self::contentTypes['kubernetesClustersTcproutesCreate'][0])
    {
        list($response) = $this->kubernetesClustersTcproutesCreateWithHttpInfo($cluster_id, $tcp_route, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersTcproutesCreateWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\TCPRoute $tcp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\TCPRoute, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersTcproutesCreateWithHttpInfo($cluster_id, $tcp_route, string $contentType = self::contentTypes['kubernetesClustersTcproutesCreate'][0])
    {
        $request = $this->kubernetesClustersTcproutesCreateRequest($cluster_id, $tcp_route, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\TCPRoute' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\TCPRoute' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\TCPRoute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\TCPRoute';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\TCPRoute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersTcproutesCreateAsync
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\TCPRoute $tcp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTcproutesCreateAsync($cluster_id, $tcp_route, string $contentType = self::contentTypes['kubernetesClustersTcproutesCreate'][0])
    {
        return $this->kubernetesClustersTcproutesCreateAsyncWithHttpInfo($cluster_id, $tcp_route, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersTcproutesCreateAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\TCPRoute $tcp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTcproutesCreateAsyncWithHttpInfo($cluster_id, $tcp_route, string $contentType = self::contentTypes['kubernetesClustersTcproutesCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\TCPRoute';
        $request = $this->kubernetesClustersTcproutesCreateRequest($cluster_id, $tcp_route, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersTcproutesCreate'
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\TCPRoute $tcp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersTcproutesCreateRequest($cluster_id, $tcp_route, string $contentType = self::contentTypes['kubernetesClustersTcproutesCreate'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersTcproutesCreate'
            );
        }

        // verify the required parameter 'tcp_route' is set
        if ($tcp_route === null || (is_array($tcp_route) && count($tcp_route) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tcp_route when calling kubernetesClustersTcproutesCreate'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/tcproutes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tcp_route)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tcp_route));
            } else {
                $httpBody = $tcp_route;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersTcproutesCreate2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\TCPRoute $tcp_route tcp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\TCPRoute
     */
    public function kubernetesClustersTcproutesCreate2($cluster_id, $tcp_route, string $contentType = self::contentTypes['kubernetesClustersTcproutesCreate2'][0])
    {
        list($response) = $this->kubernetesClustersTcproutesCreate2WithHttpInfo($cluster_id, $tcp_route, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersTcproutesCreate2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\TCPRoute $tcp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\TCPRoute, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersTcproutesCreate2WithHttpInfo($cluster_id, $tcp_route, string $contentType = self::contentTypes['kubernetesClustersTcproutesCreate2'][0])
    {
        $request = $this->kubernetesClustersTcproutesCreate2Request($cluster_id, $tcp_route, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\TCPRoute' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\TCPRoute' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\TCPRoute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\TCPRoute';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\TCPRoute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersTcproutesCreate2Async
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\TCPRoute $tcp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTcproutesCreate2Async($cluster_id, $tcp_route, string $contentType = self::contentTypes['kubernetesClustersTcproutesCreate2'][0])
    {
        return $this->kubernetesClustersTcproutesCreate2AsyncWithHttpInfo($cluster_id, $tcp_route, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersTcproutesCreate2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\TCPRoute $tcp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTcproutesCreate2AsyncWithHttpInfo($cluster_id, $tcp_route, string $contentType = self::contentTypes['kubernetesClustersTcproutesCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\TCPRoute';
        $request = $this->kubernetesClustersTcproutesCreate2Request($cluster_id, $tcp_route, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersTcproutesCreate2'
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\TCPRoute $tcp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersTcproutesCreate2Request($cluster_id, $tcp_route, string $contentType = self::contentTypes['kubernetesClustersTcproutesCreate2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersTcproutesCreate2'
            );
        }

        // verify the required parameter 'tcp_route' is set
        if ($tcp_route === null || (is_array($tcp_route) && count($tcp_route) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tcp_route when calling kubernetesClustersTcproutesCreate2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/tcproutes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tcp_route)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tcp_route));
            } else {
                $httpBody = $tcp_route;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersTcproutesDestroy
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersTcproutesDestroy($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersTcproutesDestroy'][0])
    {
        $this->kubernetesClustersTcproutesDestroyWithHttpInfo($cluster_id, $id, $contentType);
    }

    /**
     * Operation kubernetesClustersTcproutesDestroyWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersTcproutesDestroyWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersTcproutesDestroy'][0])
    {
        $request = $this->kubernetesClustersTcproutesDestroyRequest($cluster_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersTcproutesDestroyAsync
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTcproutesDestroyAsync($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersTcproutesDestroy'][0])
    {
        return $this->kubernetesClustersTcproutesDestroyAsyncWithHttpInfo($cluster_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersTcproutesDestroyAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTcproutesDestroyAsyncWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersTcproutesDestroy'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersTcproutesDestroyRequest($cluster_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersTcproutesDestroy'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersTcproutesDestroyRequest($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersTcproutesDestroy'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersTcproutesDestroy'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersTcproutesDestroy'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/tcproutes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersTcproutesDestroy2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersTcproutesDestroy2($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersTcproutesDestroy2'][0])
    {
        $this->kubernetesClustersTcproutesDestroy2WithHttpInfo($cluster_id, $id, $contentType);
    }

    /**
     * Operation kubernetesClustersTcproutesDestroy2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersTcproutesDestroy2WithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersTcproutesDestroy2'][0])
    {
        $request = $this->kubernetesClustersTcproutesDestroy2Request($cluster_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersTcproutesDestroy2Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTcproutesDestroy2Async($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersTcproutesDestroy2'][0])
    {
        return $this->kubernetesClustersTcproutesDestroy2AsyncWithHttpInfo($cluster_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersTcproutesDestroy2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTcproutesDestroy2AsyncWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersTcproutesDestroy2'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersTcproutesDestroy2Request($cluster_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersTcproutesDestroy2'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersTcproutesDestroy2Request($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersTcproutesDestroy2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersTcproutesDestroy2'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersTcproutesDestroy2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/tcproutes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersTcproutesPartialUpdate
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedTCPRoute|null $patched_tcp_route patched_tcp_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\TCPRoute
     */
    public function kubernetesClustersTcproutesPartialUpdate($cluster_id, $id, $patched_tcp_route = null, string $contentType = self::contentTypes['kubernetesClustersTcproutesPartialUpdate'][0])
    {
        list($response) = $this->kubernetesClustersTcproutesPartialUpdateWithHttpInfo($cluster_id, $id, $patched_tcp_route, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersTcproutesPartialUpdateWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedTCPRoute|null $patched_tcp_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\TCPRoute, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersTcproutesPartialUpdateWithHttpInfo($cluster_id, $id, $patched_tcp_route = null, string $contentType = self::contentTypes['kubernetesClustersTcproutesPartialUpdate'][0])
    {
        $request = $this->kubernetesClustersTcproutesPartialUpdateRequest($cluster_id, $id, $patched_tcp_route, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\TCPRoute' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\TCPRoute' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\TCPRoute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\TCPRoute';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\TCPRoute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersTcproutesPartialUpdateAsync
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedTCPRoute|null $patched_tcp_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTcproutesPartialUpdateAsync($cluster_id, $id, $patched_tcp_route = null, string $contentType = self::contentTypes['kubernetesClustersTcproutesPartialUpdate'][0])
    {
        return $this->kubernetesClustersTcproutesPartialUpdateAsyncWithHttpInfo($cluster_id, $id, $patched_tcp_route, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersTcproutesPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedTCPRoute|null $patched_tcp_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTcproutesPartialUpdateAsyncWithHttpInfo($cluster_id, $id, $patched_tcp_route = null, string $contentType = self::contentTypes['kubernetesClustersTcproutesPartialUpdate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\TCPRoute';
        $request = $this->kubernetesClustersTcproutesPartialUpdateRequest($cluster_id, $id, $patched_tcp_route, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersTcproutesPartialUpdate'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedTCPRoute|null $patched_tcp_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersTcproutesPartialUpdateRequest($cluster_id, $id, $patched_tcp_route = null, string $contentType = self::contentTypes['kubernetesClustersTcproutesPartialUpdate'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersTcproutesPartialUpdate'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersTcproutesPartialUpdate'
            );
        }



        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/tcproutes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_tcp_route)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_tcp_route));
            } else {
                $httpBody = $patched_tcp_route;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersTcproutesPartialUpdate2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedTCPRoute|null $patched_tcp_route patched_tcp_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\TCPRoute
     */
    public function kubernetesClustersTcproutesPartialUpdate2($cluster_id, $id, $patched_tcp_route = null, string $contentType = self::contentTypes['kubernetesClustersTcproutesPartialUpdate2'][0])
    {
        list($response) = $this->kubernetesClustersTcproutesPartialUpdate2WithHttpInfo($cluster_id, $id, $patched_tcp_route, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersTcproutesPartialUpdate2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedTCPRoute|null $patched_tcp_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\TCPRoute, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersTcproutesPartialUpdate2WithHttpInfo($cluster_id, $id, $patched_tcp_route = null, string $contentType = self::contentTypes['kubernetesClustersTcproutesPartialUpdate2'][0])
    {
        $request = $this->kubernetesClustersTcproutesPartialUpdate2Request($cluster_id, $id, $patched_tcp_route, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\TCPRoute' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\TCPRoute' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\TCPRoute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\TCPRoute';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\TCPRoute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersTcproutesPartialUpdate2Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedTCPRoute|null $patched_tcp_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTcproutesPartialUpdate2Async($cluster_id, $id, $patched_tcp_route = null, string $contentType = self::contentTypes['kubernetesClustersTcproutesPartialUpdate2'][0])
    {
        return $this->kubernetesClustersTcproutesPartialUpdate2AsyncWithHttpInfo($cluster_id, $id, $patched_tcp_route, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersTcproutesPartialUpdate2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedTCPRoute|null $patched_tcp_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTcproutesPartialUpdate2AsyncWithHttpInfo($cluster_id, $id, $patched_tcp_route = null, string $contentType = self::contentTypes['kubernetesClustersTcproutesPartialUpdate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\TCPRoute';
        $request = $this->kubernetesClustersTcproutesPartialUpdate2Request($cluster_id, $id, $patched_tcp_route, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersTcproutesPartialUpdate2'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedTCPRoute|null $patched_tcp_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersTcproutesPartialUpdate2Request($cluster_id, $id, $patched_tcp_route = null, string $contentType = self::contentTypes['kubernetesClustersTcproutesPartialUpdate2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersTcproutesPartialUpdate2'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersTcproutesPartialUpdate2'
            );
        }



        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/tcproutes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_tcp_route)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_tcp_route));
            } else {
                $httpBody = $patched_tcp_route;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersTcproutesRetrieve
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersTcproutesRetrieve($cluster_id, string $contentType = self::contentTypes['kubernetesClustersTcproutesRetrieve'][0])
    {
        $this->kubernetesClustersTcproutesRetrieveWithHttpInfo($cluster_id, $contentType);
    }

    /**
     * Operation kubernetesClustersTcproutesRetrieveWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersTcproutesRetrieveWithHttpInfo($cluster_id, string $contentType = self::contentTypes['kubernetesClustersTcproutesRetrieve'][0])
    {
        $request = $this->kubernetesClustersTcproutesRetrieveRequest($cluster_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersTcproutesRetrieveAsync
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTcproutesRetrieveAsync($cluster_id, string $contentType = self::contentTypes['kubernetesClustersTcproutesRetrieve'][0])
    {
        return $this->kubernetesClustersTcproutesRetrieveAsyncWithHttpInfo($cluster_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersTcproutesRetrieveAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTcproutesRetrieveAsyncWithHttpInfo($cluster_id, string $contentType = self::contentTypes['kubernetesClustersTcproutesRetrieve'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersTcproutesRetrieveRequest($cluster_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersTcproutesRetrieve'
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersTcproutesRetrieveRequest($cluster_id, string $contentType = self::contentTypes['kubernetesClustersTcproutesRetrieve'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersTcproutesRetrieve'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/tcproutes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersTcproutesRetrieve2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersTcproutesRetrieve2($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersTcproutesRetrieve2'][0])
    {
        $this->kubernetesClustersTcproutesRetrieve2WithHttpInfo($cluster_id, $id, $contentType);
    }

    /**
     * Operation kubernetesClustersTcproutesRetrieve2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersTcproutesRetrieve2WithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersTcproutesRetrieve2'][0])
    {
        $request = $this->kubernetesClustersTcproutesRetrieve2Request($cluster_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersTcproutesRetrieve2Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTcproutesRetrieve2Async($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersTcproutesRetrieve2'][0])
    {
        return $this->kubernetesClustersTcproutesRetrieve2AsyncWithHttpInfo($cluster_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersTcproutesRetrieve2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTcproutesRetrieve2AsyncWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersTcproutesRetrieve2'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersTcproutesRetrieve2Request($cluster_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersTcproutesRetrieve2'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersTcproutesRetrieve2Request($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersTcproutesRetrieve2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersTcproutesRetrieve2'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersTcproutesRetrieve2'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/tcproutes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersTcproutesRetrieve3
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesRetrieve3'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersTcproutesRetrieve3($cluster_id, string $contentType = self::contentTypes['kubernetesClustersTcproutesRetrieve3'][0])
    {
        $this->kubernetesClustersTcproutesRetrieve3WithHttpInfo($cluster_id, $contentType);
    }

    /**
     * Operation kubernetesClustersTcproutesRetrieve3WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesRetrieve3'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersTcproutesRetrieve3WithHttpInfo($cluster_id, string $contentType = self::contentTypes['kubernetesClustersTcproutesRetrieve3'][0])
    {
        $request = $this->kubernetesClustersTcproutesRetrieve3Request($cluster_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersTcproutesRetrieve3Async
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesRetrieve3'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTcproutesRetrieve3Async($cluster_id, string $contentType = self::contentTypes['kubernetesClustersTcproutesRetrieve3'][0])
    {
        return $this->kubernetesClustersTcproutesRetrieve3AsyncWithHttpInfo($cluster_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersTcproutesRetrieve3AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesRetrieve3'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTcproutesRetrieve3AsyncWithHttpInfo($cluster_id, string $contentType = self::contentTypes['kubernetesClustersTcproutesRetrieve3'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersTcproutesRetrieve3Request($cluster_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersTcproutesRetrieve3'
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesRetrieve3'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersTcproutesRetrieve3Request($cluster_id, string $contentType = self::contentTypes['kubernetesClustersTcproutesRetrieve3'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersTcproutesRetrieve3'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/tcproutes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersTcproutesRetrieve4
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesRetrieve4'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersTcproutesRetrieve4($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersTcproutesRetrieve4'][0])
    {
        $this->kubernetesClustersTcproutesRetrieve4WithHttpInfo($cluster_id, $id, $contentType);
    }

    /**
     * Operation kubernetesClustersTcproutesRetrieve4WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesRetrieve4'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersTcproutesRetrieve4WithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersTcproutesRetrieve4'][0])
    {
        $request = $this->kubernetesClustersTcproutesRetrieve4Request($cluster_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersTcproutesRetrieve4Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesRetrieve4'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTcproutesRetrieve4Async($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersTcproutesRetrieve4'][0])
    {
        return $this->kubernetesClustersTcproutesRetrieve4AsyncWithHttpInfo($cluster_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersTcproutesRetrieve4AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesRetrieve4'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTcproutesRetrieve4AsyncWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersTcproutesRetrieve4'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersTcproutesRetrieve4Request($cluster_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersTcproutesRetrieve4'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesRetrieve4'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersTcproutesRetrieve4Request($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersTcproutesRetrieve4'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersTcproutesRetrieve4'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersTcproutesRetrieve4'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/tcproutes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersTcproutesUpdate
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\TCPRoute $tcp_route tcp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\TCPRoute
     */
    public function kubernetesClustersTcproutesUpdate($cluster_id, $id, $tcp_route, string $contentType = self::contentTypes['kubernetesClustersTcproutesUpdate'][0])
    {
        list($response) = $this->kubernetesClustersTcproutesUpdateWithHttpInfo($cluster_id, $id, $tcp_route, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersTcproutesUpdateWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\TCPRoute $tcp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\TCPRoute, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersTcproutesUpdateWithHttpInfo($cluster_id, $id, $tcp_route, string $contentType = self::contentTypes['kubernetesClustersTcproutesUpdate'][0])
    {
        $request = $this->kubernetesClustersTcproutesUpdateRequest($cluster_id, $id, $tcp_route, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\TCPRoute' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\TCPRoute' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\TCPRoute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\TCPRoute';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\TCPRoute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersTcproutesUpdateAsync
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\TCPRoute $tcp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTcproutesUpdateAsync($cluster_id, $id, $tcp_route, string $contentType = self::contentTypes['kubernetesClustersTcproutesUpdate'][0])
    {
        return $this->kubernetesClustersTcproutesUpdateAsyncWithHttpInfo($cluster_id, $id, $tcp_route, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersTcproutesUpdateAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\TCPRoute $tcp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTcproutesUpdateAsyncWithHttpInfo($cluster_id, $id, $tcp_route, string $contentType = self::contentTypes['kubernetesClustersTcproutesUpdate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\TCPRoute';
        $request = $this->kubernetesClustersTcproutesUpdateRequest($cluster_id, $id, $tcp_route, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersTcproutesUpdate'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\TCPRoute $tcp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersTcproutesUpdateRequest($cluster_id, $id, $tcp_route, string $contentType = self::contentTypes['kubernetesClustersTcproutesUpdate'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersTcproutesUpdate'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersTcproutesUpdate'
            );
        }

        // verify the required parameter 'tcp_route' is set
        if ($tcp_route === null || (is_array($tcp_route) && count($tcp_route) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tcp_route when calling kubernetesClustersTcproutesUpdate'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/tcproutes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tcp_route)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tcp_route));
            } else {
                $httpBody = $tcp_route;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersTcproutesUpdate2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\TCPRoute $tcp_route tcp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\TCPRoute
     */
    public function kubernetesClustersTcproutesUpdate2($cluster_id, $id, $tcp_route, string $contentType = self::contentTypes['kubernetesClustersTcproutesUpdate2'][0])
    {
        list($response) = $this->kubernetesClustersTcproutesUpdate2WithHttpInfo($cluster_id, $id, $tcp_route, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersTcproutesUpdate2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\TCPRoute $tcp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\TCPRoute, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersTcproutesUpdate2WithHttpInfo($cluster_id, $id, $tcp_route, string $contentType = self::contentTypes['kubernetesClustersTcproutesUpdate2'][0])
    {
        $request = $this->kubernetesClustersTcproutesUpdate2Request($cluster_id, $id, $tcp_route, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\TCPRoute' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\TCPRoute' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\TCPRoute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\TCPRoute';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\TCPRoute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersTcproutesUpdate2Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\TCPRoute $tcp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTcproutesUpdate2Async($cluster_id, $id, $tcp_route, string $contentType = self::contentTypes['kubernetesClustersTcproutesUpdate2'][0])
    {
        return $this->kubernetesClustersTcproutesUpdate2AsyncWithHttpInfo($cluster_id, $id, $tcp_route, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersTcproutesUpdate2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\TCPRoute $tcp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersTcproutesUpdate2AsyncWithHttpInfo($cluster_id, $id, $tcp_route, string $contentType = self::contentTypes['kubernetesClustersTcproutesUpdate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\TCPRoute';
        $request = $this->kubernetesClustersTcproutesUpdate2Request($cluster_id, $id, $tcp_route, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersTcproutesUpdate2'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\TCPRoute $tcp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersTcproutesUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersTcproutesUpdate2Request($cluster_id, $id, $tcp_route, string $contentType = self::contentTypes['kubernetesClustersTcproutesUpdate2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersTcproutesUpdate2'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersTcproutesUpdate2'
            );
        }

        // verify the required parameter 'tcp_route' is set
        if ($tcp_route === null || (is_array($tcp_route) && count($tcp_route) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tcp_route when calling kubernetesClustersTcproutesUpdate2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/tcproutes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tcp_route)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tcp_route));
            } else {
                $httpBody = $tcp_route;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersUdproutesCreate
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\UDPRoute $udp_route udp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\UDPRoute
     */
    public function kubernetesClustersUdproutesCreate($cluster_id, $udp_route, string $contentType = self::contentTypes['kubernetesClustersUdproutesCreate'][0])
    {
        list($response) = $this->kubernetesClustersUdproutesCreateWithHttpInfo($cluster_id, $udp_route, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersUdproutesCreateWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\UDPRoute $udp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\UDPRoute, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersUdproutesCreateWithHttpInfo($cluster_id, $udp_route, string $contentType = self::contentTypes['kubernetesClustersUdproutesCreate'][0])
    {
        $request = $this->kubernetesClustersUdproutesCreateRequest($cluster_id, $udp_route, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\UDPRoute' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\UDPRoute' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\UDPRoute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\UDPRoute';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\UDPRoute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersUdproutesCreateAsync
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\UDPRoute $udp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUdproutesCreateAsync($cluster_id, $udp_route, string $contentType = self::contentTypes['kubernetesClustersUdproutesCreate'][0])
    {
        return $this->kubernetesClustersUdproutesCreateAsyncWithHttpInfo($cluster_id, $udp_route, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersUdproutesCreateAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\UDPRoute $udp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUdproutesCreateAsyncWithHttpInfo($cluster_id, $udp_route, string $contentType = self::contentTypes['kubernetesClustersUdproutesCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\UDPRoute';
        $request = $this->kubernetesClustersUdproutesCreateRequest($cluster_id, $udp_route, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersUdproutesCreate'
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\UDPRoute $udp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersUdproutesCreateRequest($cluster_id, $udp_route, string $contentType = self::contentTypes['kubernetesClustersUdproutesCreate'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersUdproutesCreate'
            );
        }

        // verify the required parameter 'udp_route' is set
        if ($udp_route === null || (is_array($udp_route) && count($udp_route) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $udp_route when calling kubernetesClustersUdproutesCreate'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/udproutes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($udp_route)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($udp_route));
            } else {
                $httpBody = $udp_route;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersUdproutesCreate2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\UDPRoute $udp_route udp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\UDPRoute
     */
    public function kubernetesClustersUdproutesCreate2($cluster_id, $udp_route, string $contentType = self::contentTypes['kubernetesClustersUdproutesCreate2'][0])
    {
        list($response) = $this->kubernetesClustersUdproutesCreate2WithHttpInfo($cluster_id, $udp_route, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersUdproutesCreate2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\UDPRoute $udp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\UDPRoute, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersUdproutesCreate2WithHttpInfo($cluster_id, $udp_route, string $contentType = self::contentTypes['kubernetesClustersUdproutesCreate2'][0])
    {
        $request = $this->kubernetesClustersUdproutesCreate2Request($cluster_id, $udp_route, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\UDPRoute' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\UDPRoute' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\UDPRoute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\UDPRoute';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\UDPRoute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersUdproutesCreate2Async
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\UDPRoute $udp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUdproutesCreate2Async($cluster_id, $udp_route, string $contentType = self::contentTypes['kubernetesClustersUdproutesCreate2'][0])
    {
        return $this->kubernetesClustersUdproutesCreate2AsyncWithHttpInfo($cluster_id, $udp_route, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersUdproutesCreate2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\UDPRoute $udp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUdproutesCreate2AsyncWithHttpInfo($cluster_id, $udp_route, string $contentType = self::contentTypes['kubernetesClustersUdproutesCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\UDPRoute';
        $request = $this->kubernetesClustersUdproutesCreate2Request($cluster_id, $udp_route, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersUdproutesCreate2'
     *
     * @param  int $cluster_id (required)
     * @param  \PidginHost\\Sdk\Model\UDPRoute $udp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersUdproutesCreate2Request($cluster_id, $udp_route, string $contentType = self::contentTypes['kubernetesClustersUdproutesCreate2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersUdproutesCreate2'
            );
        }

        // verify the required parameter 'udp_route' is set
        if ($udp_route === null || (is_array($udp_route) && count($udp_route) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $udp_route when calling kubernetesClustersUdproutesCreate2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/udproutes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($udp_route)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($udp_route));
            } else {
                $httpBody = $udp_route;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersUdproutesDestroy
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersUdproutesDestroy($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersUdproutesDestroy'][0])
    {
        $this->kubernetesClustersUdproutesDestroyWithHttpInfo($cluster_id, $id, $contentType);
    }

    /**
     * Operation kubernetesClustersUdproutesDestroyWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersUdproutesDestroyWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersUdproutesDestroy'][0])
    {
        $request = $this->kubernetesClustersUdproutesDestroyRequest($cluster_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersUdproutesDestroyAsync
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUdproutesDestroyAsync($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersUdproutesDestroy'][0])
    {
        return $this->kubernetesClustersUdproutesDestroyAsyncWithHttpInfo($cluster_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersUdproutesDestroyAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUdproutesDestroyAsyncWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersUdproutesDestroy'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersUdproutesDestroyRequest($cluster_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersUdproutesDestroy'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersUdproutesDestroyRequest($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersUdproutesDestroy'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersUdproutesDestroy'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersUdproutesDestroy'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/udproutes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersUdproutesDestroy2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersUdproutesDestroy2($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersUdproutesDestroy2'][0])
    {
        $this->kubernetesClustersUdproutesDestroy2WithHttpInfo($cluster_id, $id, $contentType);
    }

    /**
     * Operation kubernetesClustersUdproutesDestroy2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersUdproutesDestroy2WithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersUdproutesDestroy2'][0])
    {
        $request = $this->kubernetesClustersUdproutesDestroy2Request($cluster_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersUdproutesDestroy2Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUdproutesDestroy2Async($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersUdproutesDestroy2'][0])
    {
        return $this->kubernetesClustersUdproutesDestroy2AsyncWithHttpInfo($cluster_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersUdproutesDestroy2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUdproutesDestroy2AsyncWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersUdproutesDestroy2'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersUdproutesDestroy2Request($cluster_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersUdproutesDestroy2'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersUdproutesDestroy2Request($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersUdproutesDestroy2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersUdproutesDestroy2'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersUdproutesDestroy2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/udproutes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersUdproutesPartialUpdate
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedUDPRoute|null $patched_udp_route patched_udp_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\UDPRoute
     */
    public function kubernetesClustersUdproutesPartialUpdate($cluster_id, $id, $patched_udp_route = null, string $contentType = self::contentTypes['kubernetesClustersUdproutesPartialUpdate'][0])
    {
        list($response) = $this->kubernetesClustersUdproutesPartialUpdateWithHttpInfo($cluster_id, $id, $patched_udp_route, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersUdproutesPartialUpdateWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedUDPRoute|null $patched_udp_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\UDPRoute, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersUdproutesPartialUpdateWithHttpInfo($cluster_id, $id, $patched_udp_route = null, string $contentType = self::contentTypes['kubernetesClustersUdproutesPartialUpdate'][0])
    {
        $request = $this->kubernetesClustersUdproutesPartialUpdateRequest($cluster_id, $id, $patched_udp_route, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\UDPRoute' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\UDPRoute' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\UDPRoute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\UDPRoute';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\UDPRoute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersUdproutesPartialUpdateAsync
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedUDPRoute|null $patched_udp_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUdproutesPartialUpdateAsync($cluster_id, $id, $patched_udp_route = null, string $contentType = self::contentTypes['kubernetesClustersUdproutesPartialUpdate'][0])
    {
        return $this->kubernetesClustersUdproutesPartialUpdateAsyncWithHttpInfo($cluster_id, $id, $patched_udp_route, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersUdproutesPartialUpdateAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedUDPRoute|null $patched_udp_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUdproutesPartialUpdateAsyncWithHttpInfo($cluster_id, $id, $patched_udp_route = null, string $contentType = self::contentTypes['kubernetesClustersUdproutesPartialUpdate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\UDPRoute';
        $request = $this->kubernetesClustersUdproutesPartialUpdateRequest($cluster_id, $id, $patched_udp_route, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersUdproutesPartialUpdate'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedUDPRoute|null $patched_udp_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersUdproutesPartialUpdateRequest($cluster_id, $id, $patched_udp_route = null, string $contentType = self::contentTypes['kubernetesClustersUdproutesPartialUpdate'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersUdproutesPartialUpdate'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersUdproutesPartialUpdate'
            );
        }



        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/udproutes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_udp_route)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_udp_route));
            } else {
                $httpBody = $patched_udp_route;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersUdproutesPartialUpdate2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedUDPRoute|null $patched_udp_route patched_udp_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\UDPRoute
     */
    public function kubernetesClustersUdproutesPartialUpdate2($cluster_id, $id, $patched_udp_route = null, string $contentType = self::contentTypes['kubernetesClustersUdproutesPartialUpdate2'][0])
    {
        list($response) = $this->kubernetesClustersUdproutesPartialUpdate2WithHttpInfo($cluster_id, $id, $patched_udp_route, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersUdproutesPartialUpdate2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedUDPRoute|null $patched_udp_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\UDPRoute, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersUdproutesPartialUpdate2WithHttpInfo($cluster_id, $id, $patched_udp_route = null, string $contentType = self::contentTypes['kubernetesClustersUdproutesPartialUpdate2'][0])
    {
        $request = $this->kubernetesClustersUdproutesPartialUpdate2Request($cluster_id, $id, $patched_udp_route, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\UDPRoute' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\UDPRoute' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\UDPRoute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\UDPRoute';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\UDPRoute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersUdproutesPartialUpdate2Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedUDPRoute|null $patched_udp_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUdproutesPartialUpdate2Async($cluster_id, $id, $patched_udp_route = null, string $contentType = self::contentTypes['kubernetesClustersUdproutesPartialUpdate2'][0])
    {
        return $this->kubernetesClustersUdproutesPartialUpdate2AsyncWithHttpInfo($cluster_id, $id, $patched_udp_route, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersUdproutesPartialUpdate2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedUDPRoute|null $patched_udp_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUdproutesPartialUpdate2AsyncWithHttpInfo($cluster_id, $id, $patched_udp_route = null, string $contentType = self::contentTypes['kubernetesClustersUdproutesPartialUpdate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\UDPRoute';
        $request = $this->kubernetesClustersUdproutesPartialUpdate2Request($cluster_id, $id, $patched_udp_route, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersUdproutesPartialUpdate2'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedUDPRoute|null $patched_udp_route (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersUdproutesPartialUpdate2Request($cluster_id, $id, $patched_udp_route = null, string $contentType = self::contentTypes['kubernetesClustersUdproutesPartialUpdate2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersUdproutesPartialUpdate2'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersUdproutesPartialUpdate2'
            );
        }



        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/udproutes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_udp_route)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_udp_route));
            } else {
                $httpBody = $patched_udp_route;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersUdproutesRetrieve
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersUdproutesRetrieve($cluster_id, string $contentType = self::contentTypes['kubernetesClustersUdproutesRetrieve'][0])
    {
        $this->kubernetesClustersUdproutesRetrieveWithHttpInfo($cluster_id, $contentType);
    }

    /**
     * Operation kubernetesClustersUdproutesRetrieveWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersUdproutesRetrieveWithHttpInfo($cluster_id, string $contentType = self::contentTypes['kubernetesClustersUdproutesRetrieve'][0])
    {
        $request = $this->kubernetesClustersUdproutesRetrieveRequest($cluster_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersUdproutesRetrieveAsync
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUdproutesRetrieveAsync($cluster_id, string $contentType = self::contentTypes['kubernetesClustersUdproutesRetrieve'][0])
    {
        return $this->kubernetesClustersUdproutesRetrieveAsyncWithHttpInfo($cluster_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersUdproutesRetrieveAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUdproutesRetrieveAsyncWithHttpInfo($cluster_id, string $contentType = self::contentTypes['kubernetesClustersUdproutesRetrieve'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersUdproutesRetrieveRequest($cluster_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersUdproutesRetrieve'
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersUdproutesRetrieveRequest($cluster_id, string $contentType = self::contentTypes['kubernetesClustersUdproutesRetrieve'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersUdproutesRetrieve'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/udproutes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersUdproutesRetrieve2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersUdproutesRetrieve2($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersUdproutesRetrieve2'][0])
    {
        $this->kubernetesClustersUdproutesRetrieve2WithHttpInfo($cluster_id, $id, $contentType);
    }

    /**
     * Operation kubernetesClustersUdproutesRetrieve2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersUdproutesRetrieve2WithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersUdproutesRetrieve2'][0])
    {
        $request = $this->kubernetesClustersUdproutesRetrieve2Request($cluster_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersUdproutesRetrieve2Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUdproutesRetrieve2Async($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersUdproutesRetrieve2'][0])
    {
        return $this->kubernetesClustersUdproutesRetrieve2AsyncWithHttpInfo($cluster_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersUdproutesRetrieve2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUdproutesRetrieve2AsyncWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersUdproutesRetrieve2'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersUdproutesRetrieve2Request($cluster_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersUdproutesRetrieve2'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersUdproutesRetrieve2Request($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersUdproutesRetrieve2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersUdproutesRetrieve2'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersUdproutesRetrieve2'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/udproutes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersUdproutesRetrieve3
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesRetrieve3'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersUdproutesRetrieve3($cluster_id, string $contentType = self::contentTypes['kubernetesClustersUdproutesRetrieve3'][0])
    {
        $this->kubernetesClustersUdproutesRetrieve3WithHttpInfo($cluster_id, $contentType);
    }

    /**
     * Operation kubernetesClustersUdproutesRetrieve3WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesRetrieve3'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersUdproutesRetrieve3WithHttpInfo($cluster_id, string $contentType = self::contentTypes['kubernetesClustersUdproutesRetrieve3'][0])
    {
        $request = $this->kubernetesClustersUdproutesRetrieve3Request($cluster_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersUdproutesRetrieve3Async
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesRetrieve3'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUdproutesRetrieve3Async($cluster_id, string $contentType = self::contentTypes['kubernetesClustersUdproutesRetrieve3'][0])
    {
        return $this->kubernetesClustersUdproutesRetrieve3AsyncWithHttpInfo($cluster_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersUdproutesRetrieve3AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesRetrieve3'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUdproutesRetrieve3AsyncWithHttpInfo($cluster_id, string $contentType = self::contentTypes['kubernetesClustersUdproutesRetrieve3'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersUdproutesRetrieve3Request($cluster_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersUdproutesRetrieve3'
     *
     * @param  int $cluster_id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesRetrieve3'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersUdproutesRetrieve3Request($cluster_id, string $contentType = self::contentTypes['kubernetesClustersUdproutesRetrieve3'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersUdproutesRetrieve3'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/udproutes/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersUdproutesRetrieve4
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesRetrieve4'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function kubernetesClustersUdproutesRetrieve4($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersUdproutesRetrieve4'][0])
    {
        $this->kubernetesClustersUdproutesRetrieve4WithHttpInfo($cluster_id, $id, $contentType);
    }

    /**
     * Operation kubernetesClustersUdproutesRetrieve4WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesRetrieve4'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersUdproutesRetrieve4WithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersUdproutesRetrieve4'][0])
    {
        $request = $this->kubernetesClustersUdproutesRetrieve4Request($cluster_id, $id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersUdproutesRetrieve4Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesRetrieve4'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUdproutesRetrieve4Async($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersUdproutesRetrieve4'][0])
    {
        return $this->kubernetesClustersUdproutesRetrieve4AsyncWithHttpInfo($cluster_id, $id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersUdproutesRetrieve4AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesRetrieve4'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUdproutesRetrieve4AsyncWithHttpInfo($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersUdproutesRetrieve4'][0])
    {
        $returnType = '';
        $request = $this->kubernetesClustersUdproutesRetrieve4Request($cluster_id, $id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersUdproutesRetrieve4'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesRetrieve4'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersUdproutesRetrieve4Request($cluster_id, $id, string $contentType = self::contentTypes['kubernetesClustersUdproutesRetrieve4'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersUdproutesRetrieve4'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersUdproutesRetrieve4'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/udproutes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersUdproutesUpdate
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\UDPRoute $udp_route udp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\UDPRoute
     */
    public function kubernetesClustersUdproutesUpdate($cluster_id, $id, $udp_route, string $contentType = self::contentTypes['kubernetesClustersUdproutesUpdate'][0])
    {
        list($response) = $this->kubernetesClustersUdproutesUpdateWithHttpInfo($cluster_id, $id, $udp_route, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersUdproutesUpdateWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\UDPRoute $udp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\UDPRoute, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersUdproutesUpdateWithHttpInfo($cluster_id, $id, $udp_route, string $contentType = self::contentTypes['kubernetesClustersUdproutesUpdate'][0])
    {
        $request = $this->kubernetesClustersUdproutesUpdateRequest($cluster_id, $id, $udp_route, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\UDPRoute' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\UDPRoute' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\UDPRoute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\UDPRoute';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\UDPRoute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersUdproutesUpdateAsync
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\UDPRoute $udp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUdproutesUpdateAsync($cluster_id, $id, $udp_route, string $contentType = self::contentTypes['kubernetesClustersUdproutesUpdate'][0])
    {
        return $this->kubernetesClustersUdproutesUpdateAsyncWithHttpInfo($cluster_id, $id, $udp_route, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersUdproutesUpdateAsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\UDPRoute $udp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUdproutesUpdateAsyncWithHttpInfo($cluster_id, $id, $udp_route, string $contentType = self::contentTypes['kubernetesClustersUdproutesUpdate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\UDPRoute';
        $request = $this->kubernetesClustersUdproutesUpdateRequest($cluster_id, $id, $udp_route, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersUdproutesUpdate'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\UDPRoute $udp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersUdproutesUpdateRequest($cluster_id, $id, $udp_route, string $contentType = self::contentTypes['kubernetesClustersUdproutesUpdate'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersUdproutesUpdate'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersUdproutesUpdate'
            );
        }

        // verify the required parameter 'udp_route' is set
        if ($udp_route === null || (is_array($udp_route) && count($udp_route) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $udp_route when calling kubernetesClustersUdproutesUpdate'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{cluster_id}/udproutes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($udp_route)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($udp_route));
            } else {
                $httpBody = $udp_route;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersUdproutesUpdate2
     *
     * @param  int $cluster_id cluster_id (required)
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\UDPRoute $udp_route udp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\UDPRoute
     */
    public function kubernetesClustersUdproutesUpdate2($cluster_id, $id, $udp_route, string $contentType = self::contentTypes['kubernetesClustersUdproutesUpdate2'][0])
    {
        list($response) = $this->kubernetesClustersUdproutesUpdate2WithHttpInfo($cluster_id, $id, $udp_route, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersUdproutesUpdate2WithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\UDPRoute $udp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\UDPRoute, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersUdproutesUpdate2WithHttpInfo($cluster_id, $id, $udp_route, string $contentType = self::contentTypes['kubernetesClustersUdproutesUpdate2'][0])
    {
        $request = $this->kubernetesClustersUdproutesUpdate2Request($cluster_id, $id, $udp_route, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\UDPRoute' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\UDPRoute' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\UDPRoute', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\UDPRoute';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\UDPRoute',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersUdproutesUpdate2Async
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\UDPRoute $udp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUdproutesUpdate2Async($cluster_id, $id, $udp_route, string $contentType = self::contentTypes['kubernetesClustersUdproutesUpdate2'][0])
    {
        return $this->kubernetesClustersUdproutesUpdate2AsyncWithHttpInfo($cluster_id, $id, $udp_route, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersUdproutesUpdate2AsyncWithHttpInfo
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\UDPRoute $udp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUdproutesUpdate2AsyncWithHttpInfo($cluster_id, $id, $udp_route, string $contentType = self::contentTypes['kubernetesClustersUdproutesUpdate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\UDPRoute';
        $request = $this->kubernetesClustersUdproutesUpdate2Request($cluster_id, $id, $udp_route, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersUdproutesUpdate2'
     *
     * @param  int $cluster_id (required)
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\UDPRoute $udp_route (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUdproutesUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersUdproutesUpdate2Request($cluster_id, $id, $udp_route, string $contentType = self::contentTypes['kubernetesClustersUdproutesUpdate2'][0])
    {

        // verify the required parameter 'cluster_id' is set
        if ($cluster_id === null || (is_array($cluster_id) && count($cluster_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_id when calling kubernetesClustersUdproutesUpdate2'
            );
        }

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersUdproutesUpdate2'
            );
        }

        // verify the required parameter 'udp_route' is set
        if ($udp_route === null || (is_array($udp_route) && count($udp_route) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $udp_route when calling kubernetesClustersUdproutesUpdate2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{cluster_id}/udproutes/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($cluster_id !== null) {
            $resourcePath = str_replace(
                '{' . 'cluster_id' . '}',
                ObjectSerializer::toPathValue($cluster_id),
                $resourcePath
            );
        }
        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($udp_route)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($udp_route));
            } else {
                $httpBody = $udp_route;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersUpdate
     *
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\ClusterDetail $cluster_detail cluster_detail (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ClusterDetail
     */
    public function kubernetesClustersUpdate($id, $cluster_detail, string $contentType = self::contentTypes['kubernetesClustersUpdate'][0])
    {
        list($response) = $this->kubernetesClustersUpdateWithHttpInfo($id, $cluster_detail, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersUpdateWithHttpInfo
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\ClusterDetail $cluster_detail (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ClusterDetail, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersUpdateWithHttpInfo($id, $cluster_detail, string $contentType = self::contentTypes['kubernetesClustersUpdate'][0])
    {
        $request = $this->kubernetesClustersUpdateRequest($id, $cluster_detail, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\ClusterDetail' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ClusterDetail' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ClusterDetail', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ClusterDetail';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ClusterDetail',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersUpdateAsync
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\ClusterDetail $cluster_detail (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUpdateAsync($id, $cluster_detail, string $contentType = self::contentTypes['kubernetesClustersUpdate'][0])
    {
        return $this->kubernetesClustersUpdateAsyncWithHttpInfo($id, $cluster_detail, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersUpdateAsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\ClusterDetail $cluster_detail (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUpdateAsyncWithHttpInfo($id, $cluster_detail, string $contentType = self::contentTypes['kubernetesClustersUpdate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ClusterDetail';
        $request = $this->kubernetesClustersUpdateRequest($id, $cluster_detail, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersUpdate'
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\ClusterDetail $cluster_detail (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersUpdateRequest($id, $cluster_detail, string $contentType = self::contentTypes['kubernetesClustersUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersUpdate'
            );
        }

        // verify the required parameter 'cluster_detail' is set
        if ($cluster_detail === null || (is_array($cluster_detail) && count($cluster_detail) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_detail when calling kubernetesClustersUpdate'
            );
        }


        $resourcePath = '/api/kubernetes/clusters/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($cluster_detail)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($cluster_detail));
            } else {
                $httpBody = $cluster_detail;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation kubernetesClustersUpdate2
     *
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\ClusterDetail $cluster_detail cluster_detail (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\ClusterDetail
     */
    public function kubernetesClustersUpdate2($id, $cluster_detail, string $contentType = self::contentTypes['kubernetesClustersUpdate2'][0])
    {
        list($response) = $this->kubernetesClustersUpdate2WithHttpInfo($id, $cluster_detail, $contentType);
        return $response;
    }

    /**
     * Operation kubernetesClustersUpdate2WithHttpInfo
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\ClusterDetail $cluster_detail (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\ClusterDetail, HTTP status code, HTTP response headers (array of strings)
     */
    public function kubernetesClustersUpdate2WithHttpInfo($id, $cluster_detail, string $contentType = self::contentTypes['kubernetesClustersUpdate2'][0])
    {
        $request = $this->kubernetesClustersUpdate2Request($id, $cluster_detail, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\ClusterDetail' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\ClusterDetail' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\ClusterDetail', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\ClusterDetail';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\ClusterDetail',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation kubernetesClustersUpdate2Async
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\ClusterDetail $cluster_detail (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUpdate2Async($id, $cluster_detail, string $contentType = self::contentTypes['kubernetesClustersUpdate2'][0])
    {
        return $this->kubernetesClustersUpdate2AsyncWithHttpInfo($id, $cluster_detail, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation kubernetesClustersUpdate2AsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\ClusterDetail $cluster_detail (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function kubernetesClustersUpdate2AsyncWithHttpInfo($id, $cluster_detail, string $contentType = self::contentTypes['kubernetesClustersUpdate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\ClusterDetail';
        $request = $this->kubernetesClustersUpdate2Request($id, $cluster_detail, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'kubernetesClustersUpdate2'
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\ClusterDetail $cluster_detail (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['kubernetesClustersUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function kubernetesClustersUpdate2Request($id, $cluster_detail, string $contentType = self::contentTypes['kubernetesClustersUpdate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling kubernetesClustersUpdate2'
            );
        }

        // verify the required parameter 'cluster_detail' is set
        if ($cluster_detail === null || (is_array($cluster_detail) && count($cluster_detail) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $cluster_detail when calling kubernetesClustersUpdate2'
            );
        }


        $resourcePath = '/api/v1/kubernetes/clusters/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($cluster_detail)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($cluster_detail));
            } else {
                $httpBody = $cluster_detail;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
