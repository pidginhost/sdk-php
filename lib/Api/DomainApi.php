<?php
/**
 * DomainApi
 * PHP version 7.4
 *
 * @category Class
 * @package  PidginHost\\Sdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Pidgin Host API
 *
 * The Pidgin Host API allows you to manage Services and resources within the Pidgin Host cloud in a simple, programmatic way using conventional HTTP requests. All of the functionality that you are familiar with in the Pidgin Host control panel is also available through the API, allowing you to script the complex actions that your situation requires.
 *
 * The version of the OpenAPI document: 1.0.0 (v1)
 * Contact: support@pidginhost.com
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.12.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace PidginHost\\Sdk\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use PidginHost\\Sdk\ApiException;
use PidginHost\\Sdk\Configuration;
use PidginHost\\Sdk\HeaderSelector;
use PidginHost\\Sdk\ObjectSerializer;

/**
 * DomainApi Class Doc Comment
 *
 * @category Class
 * @package  PidginHost\\Sdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DomainApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'domainDomainCheckAvailabilityCreate' => [
            'application/json',
        ],
        'domainDomainCheckAvailabilityCreate2' => [
            'application/json',
        ],
        'domainDomainCreate' => [
            'application/json',
        ],
        'domainDomainCreate2' => [
            'application/json',
        ],
        'domainDomainList' => [
            'application/json',
        ],
        'domainDomainList2' => [
            'application/json',
        ],
        'domainDomainPartialUpdate' => [
            'application/json',
        ],
        'domainDomainPartialUpdate2' => [
            'application/json',
        ],
        'domainDomainRenewCreate' => [
            'application/json',
        ],
        'domainDomainRenewCreate2' => [
            'application/json',
        ],
        'domainDomainRetrieve' => [
            'application/json',
        ],
        'domainDomainRetrieve2' => [
            'application/json',
        ],
        'domainDomainTransferRoDomainCreate' => [
            'application/json',
        ],
        'domainDomainTransferRoDomainCreate2' => [
            'application/json',
        ],
        'domainDomainUpdate' => [
            'application/json',
        ],
        'domainDomainUpdate2' => [
            'application/json',
        ],
        'domainRegistrantsCreate' => [
            'application/json',
        ],
        'domainRegistrantsCreate2' => [
            'application/json',
        ],
        'domainRegistrantsDestroy' => [
            'application/json',
        ],
        'domainRegistrantsDestroy2' => [
            'application/json',
        ],
        'domainRegistrantsList' => [
            'application/json',
        ],
        'domainRegistrantsList2' => [
            'application/json',
        ],
        'domainRegistrantsPartialUpdate' => [
            'application/json',
        ],
        'domainRegistrantsPartialUpdate2' => [
            'application/json',
        ],
        'domainRegistrantsRetrieve' => [
            'application/json',
        ],
        'domainRegistrantsRetrieve2' => [
            'application/json',
        ],
        'domainRegistrantsUpdate' => [
            'application/json',
        ],
        'domainRegistrantsUpdate2' => [
            'application/json',
        ],
        'domainTldList' => [
            'application/json',
        ],
        'domainTldList2' => [
            'application/json',
        ],
        'domainTldRetrieve' => [
            'application/json',
        ],
        'domainTldRetrieve2' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation domainDomainCheckAvailabilityCreate
     *
     * @param  \PidginHost\\Sdk\Model\CheckAvailability $check_availability check_availability (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainCheckAvailabilityCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\CheckAvailability
     */
    public function domainDomainCheckAvailabilityCreate($check_availability, string $contentType = self::contentTypes['domainDomainCheckAvailabilityCreate'][0])
    {
        list($response) = $this->domainDomainCheckAvailabilityCreateWithHttpInfo($check_availability, $contentType);
        return $response;
    }

    /**
     * Operation domainDomainCheckAvailabilityCreateWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\CheckAvailability $check_availability (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainCheckAvailabilityCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\CheckAvailability, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainDomainCheckAvailabilityCreateWithHttpInfo($check_availability, string $contentType = self::contentTypes['domainDomainCheckAvailabilityCreate'][0])
    {
        $request = $this->domainDomainCheckAvailabilityCreateRequest($check_availability, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\CheckAvailability' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\CheckAvailability' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\CheckAvailability', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\CheckAvailability';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\CheckAvailability',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainDomainCheckAvailabilityCreateAsync
     *
     * @param  \PidginHost\\Sdk\Model\CheckAvailability $check_availability (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainCheckAvailabilityCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainCheckAvailabilityCreateAsync($check_availability, string $contentType = self::contentTypes['domainDomainCheckAvailabilityCreate'][0])
    {
        return $this->domainDomainCheckAvailabilityCreateAsyncWithHttpInfo($check_availability, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainDomainCheckAvailabilityCreateAsyncWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\CheckAvailability $check_availability (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainCheckAvailabilityCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainCheckAvailabilityCreateAsyncWithHttpInfo($check_availability, string $contentType = self::contentTypes['domainDomainCheckAvailabilityCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\CheckAvailability';
        $request = $this->domainDomainCheckAvailabilityCreateRequest($check_availability, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainDomainCheckAvailabilityCreate'
     *
     * @param  \PidginHost\\Sdk\Model\CheckAvailability $check_availability (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainCheckAvailabilityCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainDomainCheckAvailabilityCreateRequest($check_availability, string $contentType = self::contentTypes['domainDomainCheckAvailabilityCreate'][0])
    {

        // verify the required parameter 'check_availability' is set
        if ($check_availability === null || (is_array($check_availability) && count($check_availability) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $check_availability when calling domainDomainCheckAvailabilityCreate'
            );
        }


        $resourcePath = '/api/domain/domain/check-availability/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($check_availability)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($check_availability));
            } else {
                $httpBody = $check_availability;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainDomainCheckAvailabilityCreate2
     *
     * @param  \PidginHost\\Sdk\Model\CheckAvailability $check_availability check_availability (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainCheckAvailabilityCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\CheckAvailability
     */
    public function domainDomainCheckAvailabilityCreate2($check_availability, string $contentType = self::contentTypes['domainDomainCheckAvailabilityCreate2'][0])
    {
        list($response) = $this->domainDomainCheckAvailabilityCreate2WithHttpInfo($check_availability, $contentType);
        return $response;
    }

    /**
     * Operation domainDomainCheckAvailabilityCreate2WithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\CheckAvailability $check_availability (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainCheckAvailabilityCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\CheckAvailability, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainDomainCheckAvailabilityCreate2WithHttpInfo($check_availability, string $contentType = self::contentTypes['domainDomainCheckAvailabilityCreate2'][0])
    {
        $request = $this->domainDomainCheckAvailabilityCreate2Request($check_availability, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\CheckAvailability' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\CheckAvailability' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\CheckAvailability', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\CheckAvailability';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\CheckAvailability',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainDomainCheckAvailabilityCreate2Async
     *
     * @param  \PidginHost\\Sdk\Model\CheckAvailability $check_availability (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainCheckAvailabilityCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainCheckAvailabilityCreate2Async($check_availability, string $contentType = self::contentTypes['domainDomainCheckAvailabilityCreate2'][0])
    {
        return $this->domainDomainCheckAvailabilityCreate2AsyncWithHttpInfo($check_availability, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainDomainCheckAvailabilityCreate2AsyncWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\CheckAvailability $check_availability (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainCheckAvailabilityCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainCheckAvailabilityCreate2AsyncWithHttpInfo($check_availability, string $contentType = self::contentTypes['domainDomainCheckAvailabilityCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\CheckAvailability';
        $request = $this->domainDomainCheckAvailabilityCreate2Request($check_availability, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainDomainCheckAvailabilityCreate2'
     *
     * @param  \PidginHost\\Sdk\Model\CheckAvailability $check_availability (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainCheckAvailabilityCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainDomainCheckAvailabilityCreate2Request($check_availability, string $contentType = self::contentTypes['domainDomainCheckAvailabilityCreate2'][0])
    {

        // verify the required parameter 'check_availability' is set
        if ($check_availability === null || (is_array($check_availability) && count($check_availability) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $check_availability when calling domainDomainCheckAvailabilityCreate2'
            );
        }


        $resourcePath = '/api/v1/domain/domain/check-availability/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($check_availability)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($check_availability));
            } else {
                $httpBody = $check_availability;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainDomainCreate
     *
     * @param  \PidginHost\\Sdk\Model\DomainCreate $domain_create domain_create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\DomainCreate
     */
    public function domainDomainCreate($domain_create, string $contentType = self::contentTypes['domainDomainCreate'][0])
    {
        list($response) = $this->domainDomainCreateWithHttpInfo($domain_create, $contentType);
        return $response;
    }

    /**
     * Operation domainDomainCreateWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\DomainCreate $domain_create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\DomainCreate, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainDomainCreateWithHttpInfo($domain_create, string $contentType = self::contentTypes['domainDomainCreate'][0])
    {
        $request = $this->domainDomainCreateRequest($domain_create, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\DomainCreate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\DomainCreate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\DomainCreate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\DomainCreate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\DomainCreate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainDomainCreateAsync
     *
     * @param  \PidginHost\\Sdk\Model\DomainCreate $domain_create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainCreateAsync($domain_create, string $contentType = self::contentTypes['domainDomainCreate'][0])
    {
        return $this->domainDomainCreateAsyncWithHttpInfo($domain_create, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainDomainCreateAsyncWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\DomainCreate $domain_create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainCreateAsyncWithHttpInfo($domain_create, string $contentType = self::contentTypes['domainDomainCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\DomainCreate';
        $request = $this->domainDomainCreateRequest($domain_create, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainDomainCreate'
     *
     * @param  \PidginHost\\Sdk\Model\DomainCreate $domain_create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainDomainCreateRequest($domain_create, string $contentType = self::contentTypes['domainDomainCreate'][0])
    {

        // verify the required parameter 'domain_create' is set
        if ($domain_create === null || (is_array($domain_create) && count($domain_create) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain_create when calling domainDomainCreate'
            );
        }


        $resourcePath = '/api/domain/domain/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($domain_create)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($domain_create));
            } else {
                $httpBody = $domain_create;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainDomainCreate2
     *
     * @param  \PidginHost\\Sdk\Model\DomainCreate $domain_create domain_create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\DomainCreate
     */
    public function domainDomainCreate2($domain_create, string $contentType = self::contentTypes['domainDomainCreate2'][0])
    {
        list($response) = $this->domainDomainCreate2WithHttpInfo($domain_create, $contentType);
        return $response;
    }

    /**
     * Operation domainDomainCreate2WithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\DomainCreate $domain_create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\DomainCreate, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainDomainCreate2WithHttpInfo($domain_create, string $contentType = self::contentTypes['domainDomainCreate2'][0])
    {
        $request = $this->domainDomainCreate2Request($domain_create, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\DomainCreate' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\DomainCreate' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\DomainCreate', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\DomainCreate';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\DomainCreate',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainDomainCreate2Async
     *
     * @param  \PidginHost\\Sdk\Model\DomainCreate $domain_create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainCreate2Async($domain_create, string $contentType = self::contentTypes['domainDomainCreate2'][0])
    {
        return $this->domainDomainCreate2AsyncWithHttpInfo($domain_create, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainDomainCreate2AsyncWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\DomainCreate $domain_create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainCreate2AsyncWithHttpInfo($domain_create, string $contentType = self::contentTypes['domainDomainCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\DomainCreate';
        $request = $this->domainDomainCreate2Request($domain_create, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainDomainCreate2'
     *
     * @param  \PidginHost\\Sdk\Model\DomainCreate $domain_create (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainDomainCreate2Request($domain_create, string $contentType = self::contentTypes['domainDomainCreate2'][0])
    {

        // verify the required parameter 'domain_create' is set
        if ($domain_create === null || (is_array($domain_create) && count($domain_create) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain_create when calling domainDomainCreate2'
            );
        }


        $resourcePath = '/api/v1/domain/domain/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($domain_create)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($domain_create));
            } else {
                $httpBody = $domain_create;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainDomainList
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedDomainList
     */
    public function domainDomainList($page = null, string $contentType = self::contentTypes['domainDomainList'][0])
    {
        list($response) = $this->domainDomainListWithHttpInfo($page, $contentType);
        return $response;
    }

    /**
     * Operation domainDomainListWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedDomainList, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainDomainListWithHttpInfo($page = null, string $contentType = self::contentTypes['domainDomainList'][0])
    {
        $request = $this->domainDomainListRequest($page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedDomainList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedDomainList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedDomainList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedDomainList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedDomainList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainDomainListAsync
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainListAsync($page = null, string $contentType = self::contentTypes['domainDomainList'][0])
    {
        return $this->domainDomainListAsyncWithHttpInfo($page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainDomainListAsyncWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainListAsyncWithHttpInfo($page = null, string $contentType = self::contentTypes['domainDomainList'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedDomainList';
        $request = $this->domainDomainListRequest($page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainDomainList'
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainDomainListRequest($page = null, string $contentType = self::contentTypes['domainDomainList'][0])
    {



        $resourcePath = '/api/domain/domain/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainDomainList2
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedDomainList
     */
    public function domainDomainList2($page = null, string $contentType = self::contentTypes['domainDomainList2'][0])
    {
        list($response) = $this->domainDomainList2WithHttpInfo($page, $contentType);
        return $response;
    }

    /**
     * Operation domainDomainList2WithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedDomainList, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainDomainList2WithHttpInfo($page = null, string $contentType = self::contentTypes['domainDomainList2'][0])
    {
        $request = $this->domainDomainList2Request($page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedDomainList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedDomainList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedDomainList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedDomainList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedDomainList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainDomainList2Async
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainList2Async($page = null, string $contentType = self::contentTypes['domainDomainList2'][0])
    {
        return $this->domainDomainList2AsyncWithHttpInfo($page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainDomainList2AsyncWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainList2AsyncWithHttpInfo($page = null, string $contentType = self::contentTypes['domainDomainList2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedDomainList';
        $request = $this->domainDomainList2Request($page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainDomainList2'
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainDomainList2Request($page = null, string $contentType = self::contentTypes['domainDomainList2'][0])
    {



        $resourcePath = '/api/v1/domain/domain/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainDomainPartialUpdate
     *
     * @param  string $domain domain (required)
     * @param  \PidginHost\\Sdk\Model\PatchedDomain|null $patched_domain patched_domain (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\Domain
     */
    public function domainDomainPartialUpdate($domain, $patched_domain = null, string $contentType = self::contentTypes['domainDomainPartialUpdate'][0])
    {
        list($response) = $this->domainDomainPartialUpdateWithHttpInfo($domain, $patched_domain, $contentType);
        return $response;
    }

    /**
     * Operation domainDomainPartialUpdateWithHttpInfo
     *
     * @param  string $domain (required)
     * @param  \PidginHost\\Sdk\Model\PatchedDomain|null $patched_domain (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\Domain, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainDomainPartialUpdateWithHttpInfo($domain, $patched_domain = null, string $contentType = self::contentTypes['domainDomainPartialUpdate'][0])
    {
        $request = $this->domainDomainPartialUpdateRequest($domain, $patched_domain, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\Domain' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\Domain' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\Domain', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\Domain';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\Domain',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainDomainPartialUpdateAsync
     *
     * @param  string $domain (required)
     * @param  \PidginHost\\Sdk\Model\PatchedDomain|null $patched_domain (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainPartialUpdateAsync($domain, $patched_domain = null, string $contentType = self::contentTypes['domainDomainPartialUpdate'][0])
    {
        return $this->domainDomainPartialUpdateAsyncWithHttpInfo($domain, $patched_domain, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainDomainPartialUpdateAsyncWithHttpInfo
     *
     * @param  string $domain (required)
     * @param  \PidginHost\\Sdk\Model\PatchedDomain|null $patched_domain (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainPartialUpdateAsyncWithHttpInfo($domain, $patched_domain = null, string $contentType = self::contentTypes['domainDomainPartialUpdate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\Domain';
        $request = $this->domainDomainPartialUpdateRequest($domain, $patched_domain, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainDomainPartialUpdate'
     *
     * @param  string $domain (required)
     * @param  \PidginHost\\Sdk\Model\PatchedDomain|null $patched_domain (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainDomainPartialUpdateRequest($domain, $patched_domain = null, string $contentType = self::contentTypes['domainDomainPartialUpdate'][0])
    {

        // verify the required parameter 'domain' is set
        if ($domain === null || (is_array($domain) && count($domain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain when calling domainDomainPartialUpdate'
            );
        }
        if (!preg_match("/^[^\/]+$/", $domain)) {
            throw new \InvalidArgumentException("invalid value for \"domain\" when calling DomainApi.domainDomainPartialUpdate, must conform to the pattern /^[^\/]+$/.");
        }
        


        $resourcePath = '/api/domain/domain/{domain}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($domain !== null) {
            $resourcePath = str_replace(
                '{' . 'domain' . '}',
                ObjectSerializer::toPathValue($domain),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_domain)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_domain));
            } else {
                $httpBody = $patched_domain;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainDomainPartialUpdate2
     *
     * @param  string $domain domain (required)
     * @param  \PidginHost\\Sdk\Model\PatchedDomain|null $patched_domain patched_domain (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\Domain
     */
    public function domainDomainPartialUpdate2($domain, $patched_domain = null, string $contentType = self::contentTypes['domainDomainPartialUpdate2'][0])
    {
        list($response) = $this->domainDomainPartialUpdate2WithHttpInfo($domain, $patched_domain, $contentType);
        return $response;
    }

    /**
     * Operation domainDomainPartialUpdate2WithHttpInfo
     *
     * @param  string $domain (required)
     * @param  \PidginHost\\Sdk\Model\PatchedDomain|null $patched_domain (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\Domain, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainDomainPartialUpdate2WithHttpInfo($domain, $patched_domain = null, string $contentType = self::contentTypes['domainDomainPartialUpdate2'][0])
    {
        $request = $this->domainDomainPartialUpdate2Request($domain, $patched_domain, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\Domain' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\Domain' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\Domain', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\Domain';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\Domain',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainDomainPartialUpdate2Async
     *
     * @param  string $domain (required)
     * @param  \PidginHost\\Sdk\Model\PatchedDomain|null $patched_domain (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainPartialUpdate2Async($domain, $patched_domain = null, string $contentType = self::contentTypes['domainDomainPartialUpdate2'][0])
    {
        return $this->domainDomainPartialUpdate2AsyncWithHttpInfo($domain, $patched_domain, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainDomainPartialUpdate2AsyncWithHttpInfo
     *
     * @param  string $domain (required)
     * @param  \PidginHost\\Sdk\Model\PatchedDomain|null $patched_domain (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainPartialUpdate2AsyncWithHttpInfo($domain, $patched_domain = null, string $contentType = self::contentTypes['domainDomainPartialUpdate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\Domain';
        $request = $this->domainDomainPartialUpdate2Request($domain, $patched_domain, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainDomainPartialUpdate2'
     *
     * @param  string $domain (required)
     * @param  \PidginHost\\Sdk\Model\PatchedDomain|null $patched_domain (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainDomainPartialUpdate2Request($domain, $patched_domain = null, string $contentType = self::contentTypes['domainDomainPartialUpdate2'][0])
    {

        // verify the required parameter 'domain' is set
        if ($domain === null || (is_array($domain) && count($domain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain when calling domainDomainPartialUpdate2'
            );
        }
        if (!preg_match("/^[^\/]+$/", $domain)) {
            throw new \InvalidArgumentException("invalid value for \"domain\" when calling DomainApi.domainDomainPartialUpdate2, must conform to the pattern /^[^\/]+$/.");
        }
        


        $resourcePath = '/api/v1/domain/domain/{domain}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($domain !== null) {
            $resourcePath = str_replace(
                '{' . 'domain' . '}',
                ObjectSerializer::toPathValue($domain),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_domain)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_domain));
            } else {
                $httpBody = $patched_domain;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainDomainRenewCreate
     *
     * @param  string $domain domain (required)
     * @param  \PidginHost\\Sdk\Model\RenewDomain $renew_domain renew_domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainRenewCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\RenewDomain
     */
    public function domainDomainRenewCreate($domain, $renew_domain, string $contentType = self::contentTypes['domainDomainRenewCreate'][0])
    {
        list($response) = $this->domainDomainRenewCreateWithHttpInfo($domain, $renew_domain, $contentType);
        return $response;
    }

    /**
     * Operation domainDomainRenewCreateWithHttpInfo
     *
     * @param  string $domain (required)
     * @param  \PidginHost\\Sdk\Model\RenewDomain $renew_domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainRenewCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\RenewDomain, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainDomainRenewCreateWithHttpInfo($domain, $renew_domain, string $contentType = self::contentTypes['domainDomainRenewCreate'][0])
    {
        $request = $this->domainDomainRenewCreateRequest($domain, $renew_domain, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\RenewDomain' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\RenewDomain' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\RenewDomain', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\RenewDomain';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\RenewDomain',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainDomainRenewCreateAsync
     *
     * @param  string $domain (required)
     * @param  \PidginHost\\Sdk\Model\RenewDomain $renew_domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainRenewCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainRenewCreateAsync($domain, $renew_domain, string $contentType = self::contentTypes['domainDomainRenewCreate'][0])
    {
        return $this->domainDomainRenewCreateAsyncWithHttpInfo($domain, $renew_domain, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainDomainRenewCreateAsyncWithHttpInfo
     *
     * @param  string $domain (required)
     * @param  \PidginHost\\Sdk\Model\RenewDomain $renew_domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainRenewCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainRenewCreateAsyncWithHttpInfo($domain, $renew_domain, string $contentType = self::contentTypes['domainDomainRenewCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\RenewDomain';
        $request = $this->domainDomainRenewCreateRequest($domain, $renew_domain, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainDomainRenewCreate'
     *
     * @param  string $domain (required)
     * @param  \PidginHost\\Sdk\Model\RenewDomain $renew_domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainRenewCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainDomainRenewCreateRequest($domain, $renew_domain, string $contentType = self::contentTypes['domainDomainRenewCreate'][0])
    {

        // verify the required parameter 'domain' is set
        if ($domain === null || (is_array($domain) && count($domain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain when calling domainDomainRenewCreate'
            );
        }
        if (!preg_match("/^[^\/]+$/", $domain)) {
            throw new \InvalidArgumentException("invalid value for \"domain\" when calling DomainApi.domainDomainRenewCreate, must conform to the pattern /^[^\/]+$/.");
        }
        
        // verify the required parameter 'renew_domain' is set
        if ($renew_domain === null || (is_array($renew_domain) && count($renew_domain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $renew_domain when calling domainDomainRenewCreate'
            );
        }


        $resourcePath = '/api/domain/domain/{domain}/renew/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($domain !== null) {
            $resourcePath = str_replace(
                '{' . 'domain' . '}',
                ObjectSerializer::toPathValue($domain),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($renew_domain)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($renew_domain));
            } else {
                $httpBody = $renew_domain;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainDomainRenewCreate2
     *
     * @param  string $domain domain (required)
     * @param  \PidginHost\\Sdk\Model\RenewDomain $renew_domain renew_domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainRenewCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\RenewDomain
     */
    public function domainDomainRenewCreate2($domain, $renew_domain, string $contentType = self::contentTypes['domainDomainRenewCreate2'][0])
    {
        list($response) = $this->domainDomainRenewCreate2WithHttpInfo($domain, $renew_domain, $contentType);
        return $response;
    }

    /**
     * Operation domainDomainRenewCreate2WithHttpInfo
     *
     * @param  string $domain (required)
     * @param  \PidginHost\\Sdk\Model\RenewDomain $renew_domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainRenewCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\RenewDomain, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainDomainRenewCreate2WithHttpInfo($domain, $renew_domain, string $contentType = self::contentTypes['domainDomainRenewCreate2'][0])
    {
        $request = $this->domainDomainRenewCreate2Request($domain, $renew_domain, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\RenewDomain' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\RenewDomain' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\RenewDomain', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\RenewDomain';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\RenewDomain',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainDomainRenewCreate2Async
     *
     * @param  string $domain (required)
     * @param  \PidginHost\\Sdk\Model\RenewDomain $renew_domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainRenewCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainRenewCreate2Async($domain, $renew_domain, string $contentType = self::contentTypes['domainDomainRenewCreate2'][0])
    {
        return $this->domainDomainRenewCreate2AsyncWithHttpInfo($domain, $renew_domain, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainDomainRenewCreate2AsyncWithHttpInfo
     *
     * @param  string $domain (required)
     * @param  \PidginHost\\Sdk\Model\RenewDomain $renew_domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainRenewCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainRenewCreate2AsyncWithHttpInfo($domain, $renew_domain, string $contentType = self::contentTypes['domainDomainRenewCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\RenewDomain';
        $request = $this->domainDomainRenewCreate2Request($domain, $renew_domain, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainDomainRenewCreate2'
     *
     * @param  string $domain (required)
     * @param  \PidginHost\\Sdk\Model\RenewDomain $renew_domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainRenewCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainDomainRenewCreate2Request($domain, $renew_domain, string $contentType = self::contentTypes['domainDomainRenewCreate2'][0])
    {

        // verify the required parameter 'domain' is set
        if ($domain === null || (is_array($domain) && count($domain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain when calling domainDomainRenewCreate2'
            );
        }
        if (!preg_match("/^[^\/]+$/", $domain)) {
            throw new \InvalidArgumentException("invalid value for \"domain\" when calling DomainApi.domainDomainRenewCreate2, must conform to the pattern /^[^\/]+$/.");
        }
        
        // verify the required parameter 'renew_domain' is set
        if ($renew_domain === null || (is_array($renew_domain) && count($renew_domain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $renew_domain when calling domainDomainRenewCreate2'
            );
        }


        $resourcePath = '/api/v1/domain/domain/{domain}/renew/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($domain !== null) {
            $resourcePath = str_replace(
                '{' . 'domain' . '}',
                ObjectSerializer::toPathValue($domain),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($renew_domain)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($renew_domain));
            } else {
                $httpBody = $renew_domain;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainDomainRetrieve
     *
     * @param  string $domain domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\Domain
     */
    public function domainDomainRetrieve($domain, string $contentType = self::contentTypes['domainDomainRetrieve'][0])
    {
        list($response) = $this->domainDomainRetrieveWithHttpInfo($domain, $contentType);
        return $response;
    }

    /**
     * Operation domainDomainRetrieveWithHttpInfo
     *
     * @param  string $domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\Domain, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainDomainRetrieveWithHttpInfo($domain, string $contentType = self::contentTypes['domainDomainRetrieve'][0])
    {
        $request = $this->domainDomainRetrieveRequest($domain, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\Domain' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\Domain' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\Domain', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\Domain';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\Domain',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainDomainRetrieveAsync
     *
     * @param  string $domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainRetrieveAsync($domain, string $contentType = self::contentTypes['domainDomainRetrieve'][0])
    {
        return $this->domainDomainRetrieveAsyncWithHttpInfo($domain, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainDomainRetrieveAsyncWithHttpInfo
     *
     * @param  string $domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainRetrieveAsyncWithHttpInfo($domain, string $contentType = self::contentTypes['domainDomainRetrieve'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\Domain';
        $request = $this->domainDomainRetrieveRequest($domain, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainDomainRetrieve'
     *
     * @param  string $domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainDomainRetrieveRequest($domain, string $contentType = self::contentTypes['domainDomainRetrieve'][0])
    {

        // verify the required parameter 'domain' is set
        if ($domain === null || (is_array($domain) && count($domain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain when calling domainDomainRetrieve'
            );
        }
        if (!preg_match("/^[^\/]+$/", $domain)) {
            throw new \InvalidArgumentException("invalid value for \"domain\" when calling DomainApi.domainDomainRetrieve, must conform to the pattern /^[^\/]+$/.");
        }
        

        $resourcePath = '/api/domain/domain/{domain}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($domain !== null) {
            $resourcePath = str_replace(
                '{' . 'domain' . '}',
                ObjectSerializer::toPathValue($domain),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainDomainRetrieve2
     *
     * @param  string $domain domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\Domain
     */
    public function domainDomainRetrieve2($domain, string $contentType = self::contentTypes['domainDomainRetrieve2'][0])
    {
        list($response) = $this->domainDomainRetrieve2WithHttpInfo($domain, $contentType);
        return $response;
    }

    /**
     * Operation domainDomainRetrieve2WithHttpInfo
     *
     * @param  string $domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\Domain, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainDomainRetrieve2WithHttpInfo($domain, string $contentType = self::contentTypes['domainDomainRetrieve2'][0])
    {
        $request = $this->domainDomainRetrieve2Request($domain, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\Domain' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\Domain' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\Domain', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\Domain';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\Domain',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainDomainRetrieve2Async
     *
     * @param  string $domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainRetrieve2Async($domain, string $contentType = self::contentTypes['domainDomainRetrieve2'][0])
    {
        return $this->domainDomainRetrieve2AsyncWithHttpInfo($domain, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainDomainRetrieve2AsyncWithHttpInfo
     *
     * @param  string $domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainRetrieve2AsyncWithHttpInfo($domain, string $contentType = self::contentTypes['domainDomainRetrieve2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\Domain';
        $request = $this->domainDomainRetrieve2Request($domain, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainDomainRetrieve2'
     *
     * @param  string $domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainDomainRetrieve2Request($domain, string $contentType = self::contentTypes['domainDomainRetrieve2'][0])
    {

        // verify the required parameter 'domain' is set
        if ($domain === null || (is_array($domain) && count($domain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain when calling domainDomainRetrieve2'
            );
        }
        if (!preg_match("/^[^\/]+$/", $domain)) {
            throw new \InvalidArgumentException("invalid value for \"domain\" when calling DomainApi.domainDomainRetrieve2, must conform to the pattern /^[^\/]+$/.");
        }
        

        $resourcePath = '/api/v1/domain/domain/{domain}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($domain !== null) {
            $resourcePath = str_replace(
                '{' . 'domain' . '}',
                ObjectSerializer::toPathValue($domain),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainDomainTransferRoDomainCreate
     *
     * @param  \PidginHost\\Sdk\Model\TransferRoDomain $transfer_ro_domain transfer_ro_domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainTransferRoDomainCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\TransferRoDomain
     */
    public function domainDomainTransferRoDomainCreate($transfer_ro_domain, string $contentType = self::contentTypes['domainDomainTransferRoDomainCreate'][0])
    {
        list($response) = $this->domainDomainTransferRoDomainCreateWithHttpInfo($transfer_ro_domain, $contentType);
        return $response;
    }

    /**
     * Operation domainDomainTransferRoDomainCreateWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\TransferRoDomain $transfer_ro_domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainTransferRoDomainCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\TransferRoDomain, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainDomainTransferRoDomainCreateWithHttpInfo($transfer_ro_domain, string $contentType = self::contentTypes['domainDomainTransferRoDomainCreate'][0])
    {
        $request = $this->domainDomainTransferRoDomainCreateRequest($transfer_ro_domain, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\TransferRoDomain' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\TransferRoDomain' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\TransferRoDomain', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\TransferRoDomain';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\TransferRoDomain',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainDomainTransferRoDomainCreateAsync
     *
     * @param  \PidginHost\\Sdk\Model\TransferRoDomain $transfer_ro_domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainTransferRoDomainCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainTransferRoDomainCreateAsync($transfer_ro_domain, string $contentType = self::contentTypes['domainDomainTransferRoDomainCreate'][0])
    {
        return $this->domainDomainTransferRoDomainCreateAsyncWithHttpInfo($transfer_ro_domain, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainDomainTransferRoDomainCreateAsyncWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\TransferRoDomain $transfer_ro_domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainTransferRoDomainCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainTransferRoDomainCreateAsyncWithHttpInfo($transfer_ro_domain, string $contentType = self::contentTypes['domainDomainTransferRoDomainCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\TransferRoDomain';
        $request = $this->domainDomainTransferRoDomainCreateRequest($transfer_ro_domain, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainDomainTransferRoDomainCreate'
     *
     * @param  \PidginHost\\Sdk\Model\TransferRoDomain $transfer_ro_domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainTransferRoDomainCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainDomainTransferRoDomainCreateRequest($transfer_ro_domain, string $contentType = self::contentTypes['domainDomainTransferRoDomainCreate'][0])
    {

        // verify the required parameter 'transfer_ro_domain' is set
        if ($transfer_ro_domain === null || (is_array($transfer_ro_domain) && count($transfer_ro_domain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $transfer_ro_domain when calling domainDomainTransferRoDomainCreate'
            );
        }


        $resourcePath = '/api/domain/domain/transfer-ro-domain/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($transfer_ro_domain)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($transfer_ro_domain));
            } else {
                $httpBody = $transfer_ro_domain;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainDomainTransferRoDomainCreate2
     *
     * @param  \PidginHost\\Sdk\Model\TransferRoDomain $transfer_ro_domain transfer_ro_domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainTransferRoDomainCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\TransferRoDomain
     */
    public function domainDomainTransferRoDomainCreate2($transfer_ro_domain, string $contentType = self::contentTypes['domainDomainTransferRoDomainCreate2'][0])
    {
        list($response) = $this->domainDomainTransferRoDomainCreate2WithHttpInfo($transfer_ro_domain, $contentType);
        return $response;
    }

    /**
     * Operation domainDomainTransferRoDomainCreate2WithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\TransferRoDomain $transfer_ro_domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainTransferRoDomainCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\TransferRoDomain, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainDomainTransferRoDomainCreate2WithHttpInfo($transfer_ro_domain, string $contentType = self::contentTypes['domainDomainTransferRoDomainCreate2'][0])
    {
        $request = $this->domainDomainTransferRoDomainCreate2Request($transfer_ro_domain, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\TransferRoDomain' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\TransferRoDomain' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\TransferRoDomain', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\TransferRoDomain';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\TransferRoDomain',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainDomainTransferRoDomainCreate2Async
     *
     * @param  \PidginHost\\Sdk\Model\TransferRoDomain $transfer_ro_domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainTransferRoDomainCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainTransferRoDomainCreate2Async($transfer_ro_domain, string $contentType = self::contentTypes['domainDomainTransferRoDomainCreate2'][0])
    {
        return $this->domainDomainTransferRoDomainCreate2AsyncWithHttpInfo($transfer_ro_domain, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainDomainTransferRoDomainCreate2AsyncWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\TransferRoDomain $transfer_ro_domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainTransferRoDomainCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainTransferRoDomainCreate2AsyncWithHttpInfo($transfer_ro_domain, string $contentType = self::contentTypes['domainDomainTransferRoDomainCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\TransferRoDomain';
        $request = $this->domainDomainTransferRoDomainCreate2Request($transfer_ro_domain, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainDomainTransferRoDomainCreate2'
     *
     * @param  \PidginHost\\Sdk\Model\TransferRoDomain $transfer_ro_domain (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainTransferRoDomainCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainDomainTransferRoDomainCreate2Request($transfer_ro_domain, string $contentType = self::contentTypes['domainDomainTransferRoDomainCreate2'][0])
    {

        // verify the required parameter 'transfer_ro_domain' is set
        if ($transfer_ro_domain === null || (is_array($transfer_ro_domain) && count($transfer_ro_domain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $transfer_ro_domain when calling domainDomainTransferRoDomainCreate2'
            );
        }


        $resourcePath = '/api/v1/domain/domain/transfer-ro-domain/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($transfer_ro_domain)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($transfer_ro_domain));
            } else {
                $httpBody = $transfer_ro_domain;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainDomainUpdate
     *
     * @param  string $domain domain (required)
     * @param  \PidginHost\\Sdk\Model\Domain|null $domain2 domain2 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\Domain
     */
    public function domainDomainUpdate($domain, $domain2 = null, string $contentType = self::contentTypes['domainDomainUpdate'][0])
    {
        list($response) = $this->domainDomainUpdateWithHttpInfo($domain, $domain2, $contentType);
        return $response;
    }

    /**
     * Operation domainDomainUpdateWithHttpInfo
     *
     * @param  string $domain (required)
     * @param  \PidginHost\\Sdk\Model\Domain|null $domain2 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\Domain, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainDomainUpdateWithHttpInfo($domain, $domain2 = null, string $contentType = self::contentTypes['domainDomainUpdate'][0])
    {
        $request = $this->domainDomainUpdateRequest($domain, $domain2, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\Domain' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\Domain' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\Domain', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\Domain';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\Domain',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainDomainUpdateAsync
     *
     * @param  string $domain (required)
     * @param  \PidginHost\\Sdk\Model\Domain|null $domain2 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainUpdateAsync($domain, $domain2 = null, string $contentType = self::contentTypes['domainDomainUpdate'][0])
    {
        return $this->domainDomainUpdateAsyncWithHttpInfo($domain, $domain2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainDomainUpdateAsyncWithHttpInfo
     *
     * @param  string $domain (required)
     * @param  \PidginHost\\Sdk\Model\Domain|null $domain2 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainUpdateAsyncWithHttpInfo($domain, $domain2 = null, string $contentType = self::contentTypes['domainDomainUpdate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\Domain';
        $request = $this->domainDomainUpdateRequest($domain, $domain2, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainDomainUpdate'
     *
     * @param  string $domain (required)
     * @param  \PidginHost\\Sdk\Model\Domain|null $domain2 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainDomainUpdateRequest($domain, $domain2 = null, string $contentType = self::contentTypes['domainDomainUpdate'][0])
    {

        // verify the required parameter 'domain' is set
        if ($domain === null || (is_array($domain) && count($domain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain when calling domainDomainUpdate'
            );
        }
        if (!preg_match("/^[^\/]+$/", $domain)) {
            throw new \InvalidArgumentException("invalid value for \"domain\" when calling DomainApi.domainDomainUpdate, must conform to the pattern /^[^\/]+$/.");
        }
        


        $resourcePath = '/api/domain/domain/{domain}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($domain !== null) {
            $resourcePath = str_replace(
                '{' . 'domain' . '}',
                ObjectSerializer::toPathValue($domain),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($domain2)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($domain2));
            } else {
                $httpBody = $domain2;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainDomainUpdate2
     *
     * @param  string $domain domain (required)
     * @param  \PidginHost\\Sdk\Model\Domain|null $domain2 domain2 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\Domain
     */
    public function domainDomainUpdate2($domain, $domain2 = null, string $contentType = self::contentTypes['domainDomainUpdate2'][0])
    {
        list($response) = $this->domainDomainUpdate2WithHttpInfo($domain, $domain2, $contentType);
        return $response;
    }

    /**
     * Operation domainDomainUpdate2WithHttpInfo
     *
     * @param  string $domain (required)
     * @param  \PidginHost\\Sdk\Model\Domain|null $domain2 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\Domain, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainDomainUpdate2WithHttpInfo($domain, $domain2 = null, string $contentType = self::contentTypes['domainDomainUpdate2'][0])
    {
        $request = $this->domainDomainUpdate2Request($domain, $domain2, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\Domain' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\Domain' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\Domain', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\Domain';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\Domain',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainDomainUpdate2Async
     *
     * @param  string $domain (required)
     * @param  \PidginHost\\Sdk\Model\Domain|null $domain2 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainUpdate2Async($domain, $domain2 = null, string $contentType = self::contentTypes['domainDomainUpdate2'][0])
    {
        return $this->domainDomainUpdate2AsyncWithHttpInfo($domain, $domain2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainDomainUpdate2AsyncWithHttpInfo
     *
     * @param  string $domain (required)
     * @param  \PidginHost\\Sdk\Model\Domain|null $domain2 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainDomainUpdate2AsyncWithHttpInfo($domain, $domain2 = null, string $contentType = self::contentTypes['domainDomainUpdate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\Domain';
        $request = $this->domainDomainUpdate2Request($domain, $domain2, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainDomainUpdate2'
     *
     * @param  string $domain (required)
     * @param  \PidginHost\\Sdk\Model\Domain|null $domain2 (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainDomainUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainDomainUpdate2Request($domain, $domain2 = null, string $contentType = self::contentTypes['domainDomainUpdate2'][0])
    {

        // verify the required parameter 'domain' is set
        if ($domain === null || (is_array($domain) && count($domain) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain when calling domainDomainUpdate2'
            );
        }
        if (!preg_match("/^[^\/]+$/", $domain)) {
            throw new \InvalidArgumentException("invalid value for \"domain\" when calling DomainApi.domainDomainUpdate2, must conform to the pattern /^[^\/]+$/.");
        }
        


        $resourcePath = '/api/v1/domain/domain/{domain}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($domain !== null) {
            $resourcePath = str_replace(
                '{' . 'domain' . '}',
                ObjectSerializer::toPathValue($domain),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($domain2)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($domain2));
            } else {
                $httpBody = $domain2;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainRegistrantsCreate
     *
     * @param  \PidginHost\\Sdk\Model\DomainRegistrant $domain_registrant domain_registrant (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\DomainRegistrant
     */
    public function domainRegistrantsCreate($domain_registrant, string $contentType = self::contentTypes['domainRegistrantsCreate'][0])
    {
        list($response) = $this->domainRegistrantsCreateWithHttpInfo($domain_registrant, $contentType);
        return $response;
    }

    /**
     * Operation domainRegistrantsCreateWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\DomainRegistrant $domain_registrant (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsCreate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\DomainRegistrant, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainRegistrantsCreateWithHttpInfo($domain_registrant, string $contentType = self::contentTypes['domainRegistrantsCreate'][0])
    {
        $request = $this->domainRegistrantsCreateRequest($domain_registrant, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\DomainRegistrant' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\DomainRegistrant' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\DomainRegistrant', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\DomainRegistrant';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\DomainRegistrant',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainRegistrantsCreateAsync
     *
     * @param  \PidginHost\\Sdk\Model\DomainRegistrant $domain_registrant (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistrantsCreateAsync($domain_registrant, string $contentType = self::contentTypes['domainRegistrantsCreate'][0])
    {
        return $this->domainRegistrantsCreateAsyncWithHttpInfo($domain_registrant, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainRegistrantsCreateAsyncWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\DomainRegistrant $domain_registrant (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistrantsCreateAsyncWithHttpInfo($domain_registrant, string $contentType = self::contentTypes['domainRegistrantsCreate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\DomainRegistrant';
        $request = $this->domainRegistrantsCreateRequest($domain_registrant, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainRegistrantsCreate'
     *
     * @param  \PidginHost\\Sdk\Model\DomainRegistrant $domain_registrant (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsCreate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainRegistrantsCreateRequest($domain_registrant, string $contentType = self::contentTypes['domainRegistrantsCreate'][0])
    {

        // verify the required parameter 'domain_registrant' is set
        if ($domain_registrant === null || (is_array($domain_registrant) && count($domain_registrant) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain_registrant when calling domainRegistrantsCreate'
            );
        }


        $resourcePath = '/api/domain/registrants/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($domain_registrant)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($domain_registrant));
            } else {
                $httpBody = $domain_registrant;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainRegistrantsCreate2
     *
     * @param  \PidginHost\\Sdk\Model\DomainRegistrant $domain_registrant domain_registrant (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\DomainRegistrant
     */
    public function domainRegistrantsCreate2($domain_registrant, string $contentType = self::contentTypes['domainRegistrantsCreate2'][0])
    {
        list($response) = $this->domainRegistrantsCreate2WithHttpInfo($domain_registrant, $contentType);
        return $response;
    }

    /**
     * Operation domainRegistrantsCreate2WithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\DomainRegistrant $domain_registrant (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsCreate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\DomainRegistrant, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainRegistrantsCreate2WithHttpInfo($domain_registrant, string $contentType = self::contentTypes['domainRegistrantsCreate2'][0])
    {
        $request = $this->domainRegistrantsCreate2Request($domain_registrant, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    if ('\PidginHost\\Sdk\Model\DomainRegistrant' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\DomainRegistrant' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\DomainRegistrant', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\DomainRegistrant';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\DomainRegistrant',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainRegistrantsCreate2Async
     *
     * @param  \PidginHost\\Sdk\Model\DomainRegistrant $domain_registrant (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistrantsCreate2Async($domain_registrant, string $contentType = self::contentTypes['domainRegistrantsCreate2'][0])
    {
        return $this->domainRegistrantsCreate2AsyncWithHttpInfo($domain_registrant, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainRegistrantsCreate2AsyncWithHttpInfo
     *
     * @param  \PidginHost\\Sdk\Model\DomainRegistrant $domain_registrant (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistrantsCreate2AsyncWithHttpInfo($domain_registrant, string $contentType = self::contentTypes['domainRegistrantsCreate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\DomainRegistrant';
        $request = $this->domainRegistrantsCreate2Request($domain_registrant, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainRegistrantsCreate2'
     *
     * @param  \PidginHost\\Sdk\Model\DomainRegistrant $domain_registrant (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsCreate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainRegistrantsCreate2Request($domain_registrant, string $contentType = self::contentTypes['domainRegistrantsCreate2'][0])
    {

        // verify the required parameter 'domain_registrant' is set
        if ($domain_registrant === null || (is_array($domain_registrant) && count($domain_registrant) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain_registrant when calling domainRegistrantsCreate2'
            );
        }


        $resourcePath = '/api/v1/domain/registrants/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($domain_registrant)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($domain_registrant));
            } else {
                $httpBody = $domain_registrant;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainRegistrantsDestroy
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function domainRegistrantsDestroy($id, string $contentType = self::contentTypes['domainRegistrantsDestroy'][0])
    {
        $this->domainRegistrantsDestroyWithHttpInfo($id, $contentType);
    }

    /**
     * Operation domainRegistrantsDestroyWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsDestroy'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainRegistrantsDestroyWithHttpInfo($id, string $contentType = self::contentTypes['domainRegistrantsDestroy'][0])
    {
        $request = $this->domainRegistrantsDestroyRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation domainRegistrantsDestroyAsync
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistrantsDestroyAsync($id, string $contentType = self::contentTypes['domainRegistrantsDestroy'][0])
    {
        return $this->domainRegistrantsDestroyAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainRegistrantsDestroyAsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistrantsDestroyAsyncWithHttpInfo($id, string $contentType = self::contentTypes['domainRegistrantsDestroy'][0])
    {
        $returnType = '';
        $request = $this->domainRegistrantsDestroyRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainRegistrantsDestroy'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsDestroy'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainRegistrantsDestroyRequest($id, string $contentType = self::contentTypes['domainRegistrantsDestroy'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling domainRegistrantsDestroy'
            );
        }


        $resourcePath = '/api/domain/registrants/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainRegistrantsDestroy2
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return void
     */
    public function domainRegistrantsDestroy2($id, string $contentType = self::contentTypes['domainRegistrantsDestroy2'][0])
    {
        $this->domainRegistrantsDestroy2WithHttpInfo($id, $contentType);
    }

    /**
     * Operation domainRegistrantsDestroy2WithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsDestroy2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainRegistrantsDestroy2WithHttpInfo($id, string $contentType = self::contentTypes['domainRegistrantsDestroy2'][0])
    {
        $request = $this->domainRegistrantsDestroy2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation domainRegistrantsDestroy2Async
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistrantsDestroy2Async($id, string $contentType = self::contentTypes['domainRegistrantsDestroy2'][0])
    {
        return $this->domainRegistrantsDestroy2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainRegistrantsDestroy2AsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistrantsDestroy2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['domainRegistrantsDestroy2'][0])
    {
        $returnType = '';
        $request = $this->domainRegistrantsDestroy2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainRegistrantsDestroy2'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsDestroy2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainRegistrantsDestroy2Request($id, string $contentType = self::contentTypes['domainRegistrantsDestroy2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling domainRegistrantsDestroy2'
            );
        }


        $resourcePath = '/api/v1/domain/registrants/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            [],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainRegistrantsList
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedDomainRegistrantList
     */
    public function domainRegistrantsList($page = null, string $contentType = self::contentTypes['domainRegistrantsList'][0])
    {
        list($response) = $this->domainRegistrantsListWithHttpInfo($page, $contentType);
        return $response;
    }

    /**
     * Operation domainRegistrantsListWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedDomainRegistrantList, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainRegistrantsListWithHttpInfo($page = null, string $contentType = self::contentTypes['domainRegistrantsList'][0])
    {
        $request = $this->domainRegistrantsListRequest($page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedDomainRegistrantList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedDomainRegistrantList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedDomainRegistrantList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedDomainRegistrantList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedDomainRegistrantList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainRegistrantsListAsync
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistrantsListAsync($page = null, string $contentType = self::contentTypes['domainRegistrantsList'][0])
    {
        return $this->domainRegistrantsListAsyncWithHttpInfo($page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainRegistrantsListAsyncWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistrantsListAsyncWithHttpInfo($page = null, string $contentType = self::contentTypes['domainRegistrantsList'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedDomainRegistrantList';
        $request = $this->domainRegistrantsListRequest($page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainRegistrantsList'
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainRegistrantsListRequest($page = null, string $contentType = self::contentTypes['domainRegistrantsList'][0])
    {



        $resourcePath = '/api/domain/registrants/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainRegistrantsList2
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedDomainRegistrantList
     */
    public function domainRegistrantsList2($page = null, string $contentType = self::contentTypes['domainRegistrantsList2'][0])
    {
        list($response) = $this->domainRegistrantsList2WithHttpInfo($page, $contentType);
        return $response;
    }

    /**
     * Operation domainRegistrantsList2WithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedDomainRegistrantList, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainRegistrantsList2WithHttpInfo($page = null, string $contentType = self::contentTypes['domainRegistrantsList2'][0])
    {
        $request = $this->domainRegistrantsList2Request($page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedDomainRegistrantList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedDomainRegistrantList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedDomainRegistrantList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedDomainRegistrantList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedDomainRegistrantList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainRegistrantsList2Async
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistrantsList2Async($page = null, string $contentType = self::contentTypes['domainRegistrantsList2'][0])
    {
        return $this->domainRegistrantsList2AsyncWithHttpInfo($page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainRegistrantsList2AsyncWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistrantsList2AsyncWithHttpInfo($page = null, string $contentType = self::contentTypes['domainRegistrantsList2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedDomainRegistrantList';
        $request = $this->domainRegistrantsList2Request($page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainRegistrantsList2'
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainRegistrantsList2Request($page = null, string $contentType = self::contentTypes['domainRegistrantsList2'][0])
    {



        $resourcePath = '/api/v1/domain/registrants/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainRegistrantsPartialUpdate
     *
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedDomainRegistrant|null $patched_domain_registrant patched_domain_registrant (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\DomainRegistrant
     */
    public function domainRegistrantsPartialUpdate($id, $patched_domain_registrant = null, string $contentType = self::contentTypes['domainRegistrantsPartialUpdate'][0])
    {
        list($response) = $this->domainRegistrantsPartialUpdateWithHttpInfo($id, $patched_domain_registrant, $contentType);
        return $response;
    }

    /**
     * Operation domainRegistrantsPartialUpdateWithHttpInfo
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedDomainRegistrant|null $patched_domain_registrant (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\DomainRegistrant, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainRegistrantsPartialUpdateWithHttpInfo($id, $patched_domain_registrant = null, string $contentType = self::contentTypes['domainRegistrantsPartialUpdate'][0])
    {
        $request = $this->domainRegistrantsPartialUpdateRequest($id, $patched_domain_registrant, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\DomainRegistrant' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\DomainRegistrant' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\DomainRegistrant', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\DomainRegistrant';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\DomainRegistrant',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainRegistrantsPartialUpdateAsync
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedDomainRegistrant|null $patched_domain_registrant (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistrantsPartialUpdateAsync($id, $patched_domain_registrant = null, string $contentType = self::contentTypes['domainRegistrantsPartialUpdate'][0])
    {
        return $this->domainRegistrantsPartialUpdateAsyncWithHttpInfo($id, $patched_domain_registrant, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainRegistrantsPartialUpdateAsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedDomainRegistrant|null $patched_domain_registrant (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistrantsPartialUpdateAsyncWithHttpInfo($id, $patched_domain_registrant = null, string $contentType = self::contentTypes['domainRegistrantsPartialUpdate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\DomainRegistrant';
        $request = $this->domainRegistrantsPartialUpdateRequest($id, $patched_domain_registrant, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainRegistrantsPartialUpdate'
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedDomainRegistrant|null $patched_domain_registrant (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsPartialUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainRegistrantsPartialUpdateRequest($id, $patched_domain_registrant = null, string $contentType = self::contentTypes['domainRegistrantsPartialUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling domainRegistrantsPartialUpdate'
            );
        }



        $resourcePath = '/api/domain/registrants/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_domain_registrant)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_domain_registrant));
            } else {
                $httpBody = $patched_domain_registrant;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainRegistrantsPartialUpdate2
     *
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedDomainRegistrant|null $patched_domain_registrant patched_domain_registrant (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\DomainRegistrant
     */
    public function domainRegistrantsPartialUpdate2($id, $patched_domain_registrant = null, string $contentType = self::contentTypes['domainRegistrantsPartialUpdate2'][0])
    {
        list($response) = $this->domainRegistrantsPartialUpdate2WithHttpInfo($id, $patched_domain_registrant, $contentType);
        return $response;
    }

    /**
     * Operation domainRegistrantsPartialUpdate2WithHttpInfo
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedDomainRegistrant|null $patched_domain_registrant (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\DomainRegistrant, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainRegistrantsPartialUpdate2WithHttpInfo($id, $patched_domain_registrant = null, string $contentType = self::contentTypes['domainRegistrantsPartialUpdate2'][0])
    {
        $request = $this->domainRegistrantsPartialUpdate2Request($id, $patched_domain_registrant, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\DomainRegistrant' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\DomainRegistrant' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\DomainRegistrant', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\DomainRegistrant';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\DomainRegistrant',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainRegistrantsPartialUpdate2Async
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedDomainRegistrant|null $patched_domain_registrant (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistrantsPartialUpdate2Async($id, $patched_domain_registrant = null, string $contentType = self::contentTypes['domainRegistrantsPartialUpdate2'][0])
    {
        return $this->domainRegistrantsPartialUpdate2AsyncWithHttpInfo($id, $patched_domain_registrant, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainRegistrantsPartialUpdate2AsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedDomainRegistrant|null $patched_domain_registrant (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistrantsPartialUpdate2AsyncWithHttpInfo($id, $patched_domain_registrant = null, string $contentType = self::contentTypes['domainRegistrantsPartialUpdate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\DomainRegistrant';
        $request = $this->domainRegistrantsPartialUpdate2Request($id, $patched_domain_registrant, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainRegistrantsPartialUpdate2'
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\PatchedDomainRegistrant|null $patched_domain_registrant (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsPartialUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainRegistrantsPartialUpdate2Request($id, $patched_domain_registrant = null, string $contentType = self::contentTypes['domainRegistrantsPartialUpdate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling domainRegistrantsPartialUpdate2'
            );
        }



        $resourcePath = '/api/v1/domain/registrants/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patched_domain_registrant)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patched_domain_registrant));
            } else {
                $httpBody = $patched_domain_registrant;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainRegistrantsRetrieve
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\DomainRegistrant
     */
    public function domainRegistrantsRetrieve($id, string $contentType = self::contentTypes['domainRegistrantsRetrieve'][0])
    {
        list($response) = $this->domainRegistrantsRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation domainRegistrantsRetrieveWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\DomainRegistrant, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainRegistrantsRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['domainRegistrantsRetrieve'][0])
    {
        $request = $this->domainRegistrantsRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\DomainRegistrant' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\DomainRegistrant' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\DomainRegistrant', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\DomainRegistrant';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\DomainRegistrant',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainRegistrantsRetrieveAsync
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistrantsRetrieveAsync($id, string $contentType = self::contentTypes['domainRegistrantsRetrieve'][0])
    {
        return $this->domainRegistrantsRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainRegistrantsRetrieveAsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistrantsRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['domainRegistrantsRetrieve'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\DomainRegistrant';
        $request = $this->domainRegistrantsRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainRegistrantsRetrieve'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainRegistrantsRetrieveRequest($id, string $contentType = self::contentTypes['domainRegistrantsRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling domainRegistrantsRetrieve'
            );
        }


        $resourcePath = '/api/domain/registrants/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainRegistrantsRetrieve2
     *
     * @param  string $id id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\DomainRegistrant
     */
    public function domainRegistrantsRetrieve2($id, string $contentType = self::contentTypes['domainRegistrantsRetrieve2'][0])
    {
        list($response) = $this->domainRegistrantsRetrieve2WithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation domainRegistrantsRetrieve2WithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\DomainRegistrant, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainRegistrantsRetrieve2WithHttpInfo($id, string $contentType = self::contentTypes['domainRegistrantsRetrieve2'][0])
    {
        $request = $this->domainRegistrantsRetrieve2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\DomainRegistrant' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\DomainRegistrant' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\DomainRegistrant', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\DomainRegistrant';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\DomainRegistrant',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainRegistrantsRetrieve2Async
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistrantsRetrieve2Async($id, string $contentType = self::contentTypes['domainRegistrantsRetrieve2'][0])
    {
        return $this->domainRegistrantsRetrieve2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainRegistrantsRetrieve2AsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistrantsRetrieve2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['domainRegistrantsRetrieve2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\DomainRegistrant';
        $request = $this->domainRegistrantsRetrieve2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainRegistrantsRetrieve2'
     *
     * @param  string $id (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainRegistrantsRetrieve2Request($id, string $contentType = self::contentTypes['domainRegistrantsRetrieve2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling domainRegistrantsRetrieve2'
            );
        }


        $resourcePath = '/api/v1/domain/registrants/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainRegistrantsUpdate
     *
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\DomainRegistrant $domain_registrant domain_registrant (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\DomainRegistrant
     */
    public function domainRegistrantsUpdate($id, $domain_registrant, string $contentType = self::contentTypes['domainRegistrantsUpdate'][0])
    {
        list($response) = $this->domainRegistrantsUpdateWithHttpInfo($id, $domain_registrant, $contentType);
        return $response;
    }

    /**
     * Operation domainRegistrantsUpdateWithHttpInfo
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\DomainRegistrant $domain_registrant (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsUpdate'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\DomainRegistrant, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainRegistrantsUpdateWithHttpInfo($id, $domain_registrant, string $contentType = self::contentTypes['domainRegistrantsUpdate'][0])
    {
        $request = $this->domainRegistrantsUpdateRequest($id, $domain_registrant, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\DomainRegistrant' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\DomainRegistrant' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\DomainRegistrant', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\DomainRegistrant';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\DomainRegistrant',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainRegistrantsUpdateAsync
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\DomainRegistrant $domain_registrant (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistrantsUpdateAsync($id, $domain_registrant, string $contentType = self::contentTypes['domainRegistrantsUpdate'][0])
    {
        return $this->domainRegistrantsUpdateAsyncWithHttpInfo($id, $domain_registrant, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainRegistrantsUpdateAsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\DomainRegistrant $domain_registrant (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistrantsUpdateAsyncWithHttpInfo($id, $domain_registrant, string $contentType = self::contentTypes['domainRegistrantsUpdate'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\DomainRegistrant';
        $request = $this->domainRegistrantsUpdateRequest($id, $domain_registrant, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainRegistrantsUpdate'
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\DomainRegistrant $domain_registrant (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsUpdate'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainRegistrantsUpdateRequest($id, $domain_registrant, string $contentType = self::contentTypes['domainRegistrantsUpdate'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling domainRegistrantsUpdate'
            );
        }

        // verify the required parameter 'domain_registrant' is set
        if ($domain_registrant === null || (is_array($domain_registrant) && count($domain_registrant) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain_registrant when calling domainRegistrantsUpdate'
            );
        }


        $resourcePath = '/api/domain/registrants/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($domain_registrant)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($domain_registrant));
            } else {
                $httpBody = $domain_registrant;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainRegistrantsUpdate2
     *
     * @param  string $id id (required)
     * @param  \PidginHost\\Sdk\Model\DomainRegistrant $domain_registrant domain_registrant (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\DomainRegistrant
     */
    public function domainRegistrantsUpdate2($id, $domain_registrant, string $contentType = self::contentTypes['domainRegistrantsUpdate2'][0])
    {
        list($response) = $this->domainRegistrantsUpdate2WithHttpInfo($id, $domain_registrant, $contentType);
        return $response;
    }

    /**
     * Operation domainRegistrantsUpdate2WithHttpInfo
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\DomainRegistrant $domain_registrant (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsUpdate2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\DomainRegistrant, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainRegistrantsUpdate2WithHttpInfo($id, $domain_registrant, string $contentType = self::contentTypes['domainRegistrantsUpdate2'][0])
    {
        $request = $this->domainRegistrantsUpdate2Request($id, $domain_registrant, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\DomainRegistrant' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\DomainRegistrant' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\DomainRegistrant', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\DomainRegistrant';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\DomainRegistrant',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainRegistrantsUpdate2Async
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\DomainRegistrant $domain_registrant (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistrantsUpdate2Async($id, $domain_registrant, string $contentType = self::contentTypes['domainRegistrantsUpdate2'][0])
    {
        return $this->domainRegistrantsUpdate2AsyncWithHttpInfo($id, $domain_registrant, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainRegistrantsUpdate2AsyncWithHttpInfo
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\DomainRegistrant $domain_registrant (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainRegistrantsUpdate2AsyncWithHttpInfo($id, $domain_registrant, string $contentType = self::contentTypes['domainRegistrantsUpdate2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\DomainRegistrant';
        $request = $this->domainRegistrantsUpdate2Request($id, $domain_registrant, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainRegistrantsUpdate2'
     *
     * @param  string $id (required)
     * @param  \PidginHost\\Sdk\Model\DomainRegistrant $domain_registrant (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainRegistrantsUpdate2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainRegistrantsUpdate2Request($id, $domain_registrant, string $contentType = self::contentTypes['domainRegistrantsUpdate2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling domainRegistrantsUpdate2'
            );
        }

        // verify the required parameter 'domain_registrant' is set
        if ($domain_registrant === null || (is_array($domain_registrant) && count($domain_registrant) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $domain_registrant when calling domainRegistrantsUpdate2'
            );
        }


        $resourcePath = '/api/v1/domain/registrants/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($domain_registrant)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($domain_registrant));
            } else {
                $httpBody = $domain_registrant;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainTldList
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainTldList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedTLDList
     */
    public function domainTldList($page = null, string $contentType = self::contentTypes['domainTldList'][0])
    {
        list($response) = $this->domainTldListWithHttpInfo($page, $contentType);
        return $response;
    }

    /**
     * Operation domainTldListWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainTldList'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedTLDList, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainTldListWithHttpInfo($page = null, string $contentType = self::contentTypes['domainTldList'][0])
    {
        $request = $this->domainTldListRequest($page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedTLDList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedTLDList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedTLDList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedTLDList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedTLDList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainTldListAsync
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainTldList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainTldListAsync($page = null, string $contentType = self::contentTypes['domainTldList'][0])
    {
        return $this->domainTldListAsyncWithHttpInfo($page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainTldListAsyncWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainTldList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainTldListAsyncWithHttpInfo($page = null, string $contentType = self::contentTypes['domainTldList'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedTLDList';
        $request = $this->domainTldListRequest($page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainTldList'
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainTldList'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainTldListRequest($page = null, string $contentType = self::contentTypes['domainTldList'][0])
    {



        $resourcePath = '/api/domain/tld/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainTldList2
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainTldList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\PaginatedTLDList
     */
    public function domainTldList2($page = null, string $contentType = self::contentTypes['domainTldList2'][0])
    {
        list($response) = $this->domainTldList2WithHttpInfo($page, $contentType);
        return $response;
    }

    /**
     * Operation domainTldList2WithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainTldList2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\PaginatedTLDList, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainTldList2WithHttpInfo($page = null, string $contentType = self::contentTypes['domainTldList2'][0])
    {
        $request = $this->domainTldList2Request($page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\PaginatedTLDList' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\PaginatedTLDList' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\PaginatedTLDList', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\PaginatedTLDList';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\PaginatedTLDList',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainTldList2Async
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainTldList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainTldList2Async($page = null, string $contentType = self::contentTypes['domainTldList2'][0])
    {
        return $this->domainTldList2AsyncWithHttpInfo($page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainTldList2AsyncWithHttpInfo
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainTldList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainTldList2AsyncWithHttpInfo($page = null, string $contentType = self::contentTypes['domainTldList2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\PaginatedTLDList';
        $request = $this->domainTldList2Request($page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainTldList2'
     *
     * @param  int|null $page A page number within the paginated result set. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainTldList2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainTldList2Request($page = null, string $contentType = self::contentTypes['domainTldList2'][0])
    {



        $resourcePath = '/api/v1/domain/tld/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainTldRetrieve
     *
     * @param  int $id A unique integer value identifying this top level domain. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainTldRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\TLD
     */
    public function domainTldRetrieve($id, string $contentType = self::contentTypes['domainTldRetrieve'][0])
    {
        list($response) = $this->domainTldRetrieveWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation domainTldRetrieveWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this top level domain. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainTldRetrieve'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\TLD, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainTldRetrieveWithHttpInfo($id, string $contentType = self::contentTypes['domainTldRetrieve'][0])
    {
        $request = $this->domainTldRetrieveRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\TLD' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\TLD' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\TLD', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\TLD';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\TLD',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainTldRetrieveAsync
     *
     * @param  int $id A unique integer value identifying this top level domain. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainTldRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainTldRetrieveAsync($id, string $contentType = self::contentTypes['domainTldRetrieve'][0])
    {
        return $this->domainTldRetrieveAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainTldRetrieveAsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this top level domain. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainTldRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainTldRetrieveAsyncWithHttpInfo($id, string $contentType = self::contentTypes['domainTldRetrieve'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\TLD';
        $request = $this->domainTldRetrieveRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainTldRetrieve'
     *
     * @param  int $id A unique integer value identifying this top level domain. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainTldRetrieve'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainTldRetrieveRequest($id, string $contentType = self::contentTypes['domainTldRetrieve'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling domainTldRetrieve'
            );
        }


        $resourcePath = '/api/domain/tld/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation domainTldRetrieve2
     *
     * @param  int $id A unique integer value identifying this top level domain. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainTldRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \PidginHost\\Sdk\Model\TLD
     */
    public function domainTldRetrieve2($id, string $contentType = self::contentTypes['domainTldRetrieve2'][0])
    {
        list($response) = $this->domainTldRetrieve2WithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation domainTldRetrieve2WithHttpInfo
     *
     * @param  int $id A unique integer value identifying this top level domain. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainTldRetrieve2'] to see the possible values for this operation
     *
     * @throws \PidginHost\\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \PidginHost\\Sdk\Model\TLD, HTTP status code, HTTP response headers (array of strings)
     */
    public function domainTldRetrieve2WithHttpInfo($id, string $contentType = self::contentTypes['domainTldRetrieve2'][0])
    {
        $request = $this->domainTldRetrieve2Request($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    if ('\PidginHost\\Sdk\Model\TLD' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\PidginHost\\Sdk\Model\TLD' !== 'string') {
                            try {
                                $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                            } catch (\JsonException $exception) {
                                throw new ApiException(
                                    sprintf(
                                        'Error JSON decoding server response (%s)',
                                        $request->getUri()
                                    ),
                                    $statusCode,
                                    $response->getHeaders(),
                                    $content
                                );
                            }
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\PidginHost\\Sdk\Model\TLD', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            $returnType = '\PidginHost\\Sdk\Model\TLD';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    try {
                        $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                    } catch (\JsonException $exception) {
                        throw new ApiException(
                            sprintf(
                                'Error JSON decoding server response (%s)',
                                $request->getUri()
                            ),
                            $statusCode,
                            $response->getHeaders(),
                            $content
                        );
                    }
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\PidginHost\\Sdk\Model\TLD',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation domainTldRetrieve2Async
     *
     * @param  int $id A unique integer value identifying this top level domain. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainTldRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainTldRetrieve2Async($id, string $contentType = self::contentTypes['domainTldRetrieve2'][0])
    {
        return $this->domainTldRetrieve2AsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation domainTldRetrieve2AsyncWithHttpInfo
     *
     * @param  int $id A unique integer value identifying this top level domain. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainTldRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function domainTldRetrieve2AsyncWithHttpInfo($id, string $contentType = self::contentTypes['domainTldRetrieve2'][0])
    {
        $returnType = '\PidginHost\\Sdk\Model\TLD';
        $request = $this->domainTldRetrieve2Request($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'domainTldRetrieve2'
     *
     * @param  int $id A unique integer value identifying this top level domain. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['domainTldRetrieve2'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function domainTldRetrieve2Request($id, string $contentType = self::contentTypes['domainTldRetrieve2'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling domainTldRetrieve2'
            );
        }


        $resourcePath = '/api/v1/domain/tld/{id}/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('sessionid');
        if ($apiKey !== null) {
            
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('Authorization');
        if ($apiKey !== null) {
            $headers['Authorization'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
